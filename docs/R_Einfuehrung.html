<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="de" xml:lang="de"><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<title>Kausalanalyse und Machinelles Lernen mit R - 2&nbsp; Statistische Programmierung mit R</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>

<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./Matching.html" rel="next">
<link href="./index.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light"><script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "Keine Treffer",
    "search-matching-documents-text": "Treffer",
    "search-copy-link-title": "Link in die Suche kopieren",
    "search-hide-matches-text": "Zus√§tzliche Treffer verbergen",
    "search-more-match-text": "weitere Treffer in diesem Dokument",
    "search-more-matches-text": "weitere Treffer in diesem Dokument",
    "search-clear-button-title": "Zur√ºcksetzen",
    "search-detached-cancel-button-title": "Abbrechen",
    "search-submit-button-title": "Abschicken",
    "search-label": "Suchen"
  }
}</script><meta name="robots" content="noindex">
<script>
  MathJax = {
    tex: {
      tags: 'ams'  // should be 'ams', 'none', or 'all'
    }
  };
</script><script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.js" integrity="sha512-aoZChv+8imY/U1O7KIHXvO87EOzCuKO0GhFtpD6G2Cyjo/xPeTgdf3/bchB10iB+AojMTDkMHDPLKNxPJVqDcw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/all.min.css">
<style>
.qwebr-code-output-stdout {background-color: powderblue;}

.qwebr-button-run {
 width = 100%; 
}

</style>
<script src="https://cdn.jsdelivr.net/npm/quizdown@latest/public/build/quizdown.js"></script><script>quizdown.init();</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/monaco-editor@0.43.0/min/vs/editor/editor.main.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha512-z3gLpd7yknf1YoNbCzqRKc4qyor8gaKU1qmn+CShxbuBusANI9QpRohGBreCFkKxLhei6S9CQXFEbbKuqLg0DA==" crossorigin="anonymous" referrerpolicy="no-referrer">
<style>
  .monaco-editor pre {
    background-color: unset !important;
  }

  .qwebr-icon-status-spinner {
    color: darkgreen;
  }

  .qwebr-icon-run-code {
    color: #0d9c29
  }

  .qwebr-output-code-stdout {
    color: #111;
  }

  .qwebr-output-code-stderr {
    color: #db4133;
  }
  
  .qwebr-editor {
    border: 1px solid #EEEEEE;
  }
  
  .qwebr-button-run {
    background-color: #EEEEEE;
    border-bottom-left-radius: 0;
    border-bottom-right-radius: 0; /* Extra styling for consistency */
    display: inline-block;
    font-weight: 600;
    line-height: 1;
    color: #000;
    text-align: center;
    text-decoration: none;
    -webkit-text-decoration: none;
    -moz-text-decoration: none;
    -ms-text-decoration: none;
    -o-text-decoration: none;
    /* vertical-align: middle; */ /* Prevents a space from appearing between the code cell and button */
    -webkit-user-select: none;
    border-color: #dee2e6;
    border: 1px solid rgba(0,0,0,0);
    padding: 0.375rem 0.75rem 0.75rem;
    font-size: .8rem;
    border-top-right-radius: 0.25rem;
    border-top-left-radius: 0.25rem;
    transition: color .15s ease-in-out,
    background-color .15s ease-in-out,
    border-color .15s ease-in-out,
    box-shadow .15s ease-in-out;
  }

  .qwebr-button-run:hover {
    color: #000;
    background-color: #e3e6ea;
    border-color: #e1e5e9;
  }

  .qwebr-button-run:disabled,
  .qwebr-button-run.disabled,
  fieldset:disabled 
  .qwebr-button-run {
    pointer-events: none;
    cursor: not-allowed;
    opacity: .5
  }
  
  .qwebr-output-code-area > pre {
    background-color: #F2F2F2;
    border-radius: 15px;
    margin-top: .8rem;
    padding: .1rem;
  }
  
  .qwebr-output-code-area > pre > div {
    margin: .4rem;
    margin-left: .6rem;
  }
  
  .monaco-editor {
    z-index: 0;
    -webkit-box-shadow: 5px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 5px 5px 15px 5px rgba(0, 0, 0, 0.3);    
  }

  
  /* Custom styling for RevealJS Presentations*/

  /* Reset the style of the interactive area */
  .reveal div.qwebr-interactive-area {
    display: block;
    box-shadow: none;
    max-width: 100%;
    max-height: 100%;
    margin: 0;
    padding: 0;
  } 

  /* Provide space to entries */
  .reveal div.qwebr-output-code-area pre div {
    margin: 1px 2px 1px 10px;
  }

  /* Collapse the inside code tags to avoid extra space between line outputs */
  .reveal pre div code.qwebr-output-code-stdout, .reveal pre div code.qwebr-output-code-stderr {
    padding: 0;
    display: contents;
  }

  .reveal pre div code.qwebr-output-code-stdout {
    color: #111;
  }

  .reveal pre div code.qwebr-output-code-stderr {
    color: #db4133;
  }


  /* Create a border around console and output (does not effect graphs) */
  .reveal div.qwebr-console-area {
    border: 1px solid #EEEEEE;
    box-shadow: 2px 2px 10px #EEEEEE;
  }

  /* Cap output height and allow text to scroll */
  /* TODO: Is there a better way to fit contents/max it parallel to the monaco editor size? */
  .reveal div.qwebr-output-code-area pre {
    max-height: 400px;
    overflow: scroll;
  }
</style>
<script type="module">

  // Start a timer
  const initializeWebRTimerStart = performance.now();

  // Determine if we need to install R packages
  var installRPackagesList = ['tidyverse', 'palmerpenguins'];
  // Check to see if we have an empty array, if we do set to skip the installation.
  var setupRPackages = !(installRPackagesList.indexOf("") !== -1);
  var autoloadRPackages = true;

  // Display a startup message?
  var showStartupMessage = true;
  var showHeaderMessage = false;
  if (showStartupMessage) {

    // Get references to header elements
    const headerHTML = document.getElementById("title-block-header");
    const headerRevealJS = document.getElementById("title-slide");

    // Create the outermost div element for metadata
    const quartoTitleMeta = document.createElement("div");
    quartoTitleMeta.classList.add("quarto-title-meta");

    // Create the first inner div element
    const firstInnerDiv = document.createElement("div");
    firstInnerDiv.setAttribute("id", "qwebr-status-message-area");

    // Create the second inner div element for "WebR Status" heading and contents
    const secondInnerDiv = document.createElement("div");
    secondInnerDiv.setAttribute("id", "qwebr-status-message-title");
    secondInnerDiv.classList.add("quarto-title-meta-heading");
    secondInnerDiv.innerText = "WebR-Status";

    // Create another inner div for contents
    const secondInnerDivContents = document.createElement("div");
    secondInnerDivContents.setAttribute("id", "qwebr-status-message-body");
    secondInnerDivContents.classList.add("quarto-title-meta-contents");

    // Describe the WebR state
    var startupMessageWebR = document.createElement("p");
    startupMessageWebR.innerText = "Starte..."
    startupMessageWebR.setAttribute("id", "qwebr-status-message-text");
    // Add `aria-live` to auto-announce the startup status to screen readers
    startupMessageWebR.setAttribute("aria-live", "assertive");

    // Append the startup message to the contents
    secondInnerDivContents.appendChild(startupMessageWebR);

    // Add a status indicator for COOP and COEP Headers if needed
    if (showHeaderMessage) {
      const crossOriginMessage = document.createElement("p");
      crossOriginMessage.innerText = `${crossOriginIsolated ? 'üü¢' : 'üü°'} COOP & COEP Headers`;
      crossOriginMessage.setAttribute("id", "qwebr-coop-coep-header");
      secondInnerDivContents.appendChild(crossOriginMessage);
    }

    // Combine the inner divs and contents
    firstInnerDiv.appendChild(secondInnerDiv);
    firstInnerDiv.appendChild(secondInnerDivContents);
    quartoTitleMeta.appendChild(firstInnerDiv);

    // Determine where to insert the quartoTitleMeta element
    if (headerHTML) {
      // Append to the existing "title-block-header" element
      headerHTML.appendChild(quartoTitleMeta);
    } else if (headerRevealJS) {
      // If using RevealJS, add to the "title-slide" div
      headerRevealJS.appendChild(firstInnerDiv);
    } else {
      // If neither headerHTML nor headerRevealJS is found, insert after "webr-monaco-editor-init" script
      const monacoScript = document.getElementById("qwebr-monaco-editor-init");
      const header = document.createElement("header");
      header.setAttribute("id", "title-block-header");
      header.appendChild(quartoTitleMeta);
      monacoScript.after(header);
    }
  }

  // Retrieve the webr.mjs
  import { WebR, ChannelType } from "https://webr.r-wasm.org/v0.2.2/webr.mjs";

  // Populate WebR options with defaults or new values based on 
  // webr meta
  globalThis.webR = new WebR({
    "baseURL": "https://webr.r-wasm.org/v0.2.2/",
    "serviceWorkerUrl": "",
    "homedir": "/home/web_user", 
    "channelType": ChannelType.Automatic
  });

  // Initialization WebR
  await globalThis.webR.init();

  // Setup a shelter
  globalThis.webRCodeShelter = await new globalThis.webR.Shelter();

  // Setup a pager to allow processing help documentation 
  await globalThis.webR.evalRVoid('webr::pager_install()'); 

  // Function to set the button text
  function qwebrSetInteractiveButtonState(buttonText, enableCodeButton = true) {
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.innerHTML = buttonText;
      btn.disabled = !enableCodeButton;
    });
  }

  // Function to update the status message
  function qwebrUpdateStatusHeader(message) {
    startupMessageWebR.innerHTML = `
      <i class="fas fa-cog fa-spin qwebr-icon-status-spinner"></i>
      <span>${message}</span>`;
  }

  // Function to install a single package
  async function qwebrInstallRPackage(packageName) {
    await globalThis.webR.installPackages([packageName]);
  }

  // Function to load a single package
  async function qwebrLoadRPackage(packageName) {
    await globalThis.webR.evalRVoid(`library(${packageName});`);
  }

  // Generic function to process R packages
  async function qwebrProcessRPackagesWithStatus(packages, processType, displayStatusMessageUpdate = true) {
    // Switch between contexts
    const messagePrefix = processType === 'install' ? 'Installiere' : 'Lade';

    // Modify button state
    qwebrSetInteractiveButtonState(`<i class="fas fa-cog fa-spin qwebr-icon-status-spinner"></i> ${messagePrefix} Pakete ...`, false);

    // Iterate over packages
    for (let i = 0; i < packages.length; i++) {
      const activePackage = packages[i];
      const formattedMessage = `${messagePrefix} Paket ${i + 1} von ${packages.length}: <code style="background-color:white; color:darkgreen;">${activePackage}</code>`;
      
      // Display the update
      if (displayStatusMessageUpdate) {
        qwebrUpdateStatusHeader(formattedMessage);
      }

      // Run package installation
      if (processType === 'install') {
        await qwebrInstallRPackage(activePackage);
      } else {
        await qwebrLoadRPackage(activePackage);
      }
    }

    // Clean slate
    if (processType === 'load') {
      await globalThis.webR.flush();
    }
  }


  // Check to see if any packages need to be installed
  if (setupRPackages) {
    // Obtain only a unique list of packages
    const uniqueRPackageList = Array.from(new Set(installRPackagesList));

    // Install R packages one at a time (either silently or with a status update)
    await qwebrProcessRPackagesWithStatus(uniqueRPackageList, 'install', showStartupMessage);

    if(autoloadRPackages) {
      // Load R packages one at a time (either silently or with a status update)
      await qwebrProcessRPackagesWithStatus(uniqueRPackageList, 'load', showStartupMessage);
    }
  }

  // Stop timer
  const initializeWebRTimerEnd = performance.now();

  // Release document status as ready
  if (showStartupMessage) {
    startupMessageWebR.innerText = "‚úÖ Bereit!"
  }
  
  qwebrSetInteractiveButtonState(
    `<span>R-Code ausf√ºhren <i class="fa fa-sign-in"></i></span>`, 
    true
  );

</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
</head>
<body class="nav-sidebar floating slimcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top"><nav class="quarto-secondary-nav"><div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Seitenleiste umschalten" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
      <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./R_Einfuehrung.html"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Statistische Programmierung mit R</span></a></li></ol></nav>
      <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Seitenleiste umschalten" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
      </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav></header><!-- content --><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal sidebar-navigation floating overflow-auto"><div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./"></a><a href="./index.html">Kausalanalyse mit R</a> 
        <div class="sidebar-tools-main">
  <a href="" class="quarto-reader-toggle quarto-navigation-tool px-1" onclick="window.quartoToggleReader(); return false;" title="Lesemodus umschalten">
  <div class="quarto-reader-toggle-btn">
  <i class="bi"></i>
  </div>
</a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Suchen"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
<li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Start</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./R_Einfuehrung.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Statistische Programmierung mit R</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Matching.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Matching</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./RDD.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Regression Discontiniuty Designs</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./RegReg.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Regularisierte Regression</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Literatur.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Literatur</span></a>
  </div>
</li>
    </ul>
</div>
    <nav id="TOC" role="doc-toc" class="toc-active"><h2 id="toc-title"><a href="./index.html">√úbersicht</a></h2>
   
  <ul>
<li><a href="#lange-weite-und-tidy-datenformate" id="toc-lange-weite-und-tidy-datenformate" class="nav-link active" data-scroll-target="#lange-weite-und-tidy-datenformate"><span class="header-section-number">2.1</span> Lange, weite und ‚Äútidy‚Äù Datenformate</a></li>
  <li>
<a href="#pinguine-und-pipes" id="toc-pinguine-und-pipes" class="nav-link" data-scroll-target="#pinguine-und-pipes"><span class="header-section-number">2.2</span> Pinguine und Pipes</a>
  <ul class="collapse">
<li><a href="#dplyrmutate" id="toc-dplyrmutate" class="nav-link" data-scroll-target="#dplyrmutate"><span class="header-section-number">2.2.1</span> <code>dplyr::mutate()</code></a></li>
  <li><a href="#dplyrselect" id="toc-dplyrselect" class="nav-link" data-scroll-target="#dplyrselect"><span class="header-section-number">2.2.2</span> <code>dplyr::select()</code></a></li>
  <li><a href="#dplyrfilter" id="toc-dplyrfilter" class="nav-link" data-scroll-target="#dplyrfilter"><span class="header-section-number">2.2.3</span> <code>dplyr::filter()</code></a></li>
  <li><a href="#dplyrsummarise" id="toc-dplyrsummarise" class="nav-link" data-scroll-target="#dplyrsummarise"><span class="header-section-number">2.2.4</span> <code>dplyr::summarise()</code></a></li>
  <li><a href="#dplyrarrange" id="toc-dplyrarrange" class="nav-link" data-scroll-target="#dplyrarrange"><span class="header-section-number">2.2.5</span> <code>dplyr::arrange()</code></a></li>
  <li><a href="#operationen-mit-gruppierten-datens%C3%A4tzen" id="toc-operationen-mit-gruppierten-datens√§tzen" class="nav-link" data-scroll-target="#operationen-mit-gruppierten-datens%C3%A4tzen"><span class="header-section-number">2.2.6</span> Operationen mit gruppierten Datens√§tzen</a></li>
  </ul>
</li>
  <li><a href="#eine-explorative-analyse-mit-ggplot2" id="toc-eine-explorative-analyse-mit-ggplot2" class="nav-link" data-scroll-target="#eine-explorative-analyse-mit-ggplot2"><span class="header-section-number">2.3</span> Eine explorative Analyse mit <code>ggplot2</code></a></li>
  </ul></nav>
</nav><div id="quarto-sidebar-glass" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
    </div>
<!-- main -->
<main class="content page-columns page-full" id="quarto-document-content"><script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.43.0/min/vs/loader.js"></script><script type="module" id="qwebr-monaco-editor-init">

  // Configure the Monaco Editor's loader
  require.config({
    paths: {
      'vs': 'https://cdn.jsdelivr.net/npm/monaco-editor@0.43.0/min/vs'
    }
  });
</script><header id="title-block-header" class="quarto-title-block default"><div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title">
<span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Statistische Programmierung mit R</span>
</h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> Code</button></div></div>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header><div class="page-columns page-full"><p>Dieses Kapitel ist <em>nicht</em> als umfassende Einf√ºhrung in R gedacht, sondern behandelt Kernfunktionen aus der Paketsammlung <code>tidyverse</code>. Wenngleich die Inhalte deutlich √ºber ein Hallo-Welt-Beispiel<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> hinausgehen, betrachten wir hier grundlegene Funktionen f√ºr Datenmanipulation und Visualisierung. Diese sind Vorraussetzung f√ºr das Verst√§ndnis fortgeschrittener Code-Bausteine in sp√§teren Kapiteln. Falls Sie bereits √ºber Grundkenntnisse im Umgang mit <code>tidyverse</code> verf√ºgen, k√∂nnen Sie dieses Kapitel √ºberspringen. Sollten Sie nicht oder nur teilweise mit den hier gezeigten Befehlen vertraut sein oder keinerlei Erfahrung mit R haben, empfiehlt sich vorab eine Erarbeitung bzw. Wiederholung der Inhalte. Nachstehede Ressourcen finden wir hilfreich:</p><div class="no-row-height column-margin column-container"><li id="fn1"><p><sup>1</sup>&nbsp;https://de.wikipedia.org/wiki/Hallo-Welt-Programm</p></li></div></div>
<ul>
<li>
<p>Feedbackgest√ºtze interaktive √úbungsaufgaben bei DataCamp<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>, bspw.</p>
<ul>
<li><a href="https://campus.datacamp.com/courses/einfuhrung-in-r/">Einf√ºhrung in R</a></li>
<li><a href="https://www.datacamp.com/courses/introduction-to-data-visualization-with-ggplot2">Introduction to Data Visualization with ggplot2</a></li>
<li><a href="https://www.datacamp.com/courses/data-manipulation-with-dplyr">Data Manipulation with dplyr</a></li>
</ul>
</li>
<li>
<p>Open-source-Literatur wie</p>
<ul>
<li>der umfangreiche Leitfaden von <a href="https://methodenlehre.github.io/einfuehrung-in-R/">Ellis und Mayer (2023)</a>
</li>
<li><a href="https://r4ds.hadley.nz/">R for Data Science</a></li>
<li><a href="https://rstudio-education.github.io/hopr/">Hands-On Programming with R</a></li>
</ul>
</li>
</ul>
<div class="no-row-height column-margin column-container"><li id="fn2"><p><sup>2</sup>&nbsp;Ein Teil des hier angebotenen Katalogs (exlusive <em>Einf√ºhrung in R</em>) ist kostenpflichtig.</p></li></div><p>Wir laden zun√§chst die Paketsammlung <code>tidyverse</code>. F√ºr die Reproduktion mit dem <a href="https://www.r-project.org/">R GUI</a> oder mit <a href="https://posit.co/download/rstudio-desktop/">RStudio</a> muss das Paket vorab mit <code><a href="https://rdrr.io/r/utils/install.packages.html">install.packages()</a></code> installiert werden. In den interaktiven R-Konsolen in diesem Kapitel (und im Rest des Buchs) sind die ben√∂tigten R-Pakete bereits installiert <em>und</em> geladen, sofern nicht anders beschrieben.</p>
<div class="cell">
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># Paket tidyverse installieren</span></span>
<span><span class="co"># install.packages("tidyverse")</span></span>
<span></span>
<span><span class="co"># Paket 'tidyverse' laden</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://tidyverse.tidyverse.org">tidyverse</a></span><span class="op">)</span></span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>F√ºr das Verst√§ndnis von Code-Chunks ist es hilfreich, Zwischenergebnisse explizit zu evaluieren und in der Konsole auszugeben. Hierf√ºr umschlie√üen wir h√§ufig Code-Zeilen mit runden Klammern. Der n√§chste Chunk illustriert dies f√ºr die Variable <code>x</code>.</p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>
<div id="qwebr-interactive-area-1" class="qwebr-interactive-area">
  <div id="qwebr-console-area-1" class="qwebr-console-area">
    <div id="qwebr-editor-1" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-1">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-1" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-1" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-1");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-1");
  const editorDiv = document.getElementById("qwebr-editor-1");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-1");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `# Variable definieren...
x <- pi
# ... und evaluieren
x

# √Ñquivalent:
(
  x <- pi
)`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-1-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-1-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script><section id="lange-weite-und-tidy-datenformate" class="level2 page-columns page-full" data-number="2.1"><h2 data-number="2.1" class="anchored" data-anchor-id="lange-weite-und-tidy-datenformate">
<span class="header-section-number">2.1</span> Lange, weite und ‚Äútidy‚Äù Datenformate</h2>
<p>Wir betrachten den in <a href="#tbl-Klausurergebnisse">Tabelle&nbsp;<span>2.1</span></a> dargestellten Datensatz <em>Klausurergebnisse</em>.</p>
<div class="cell page-columns page-full">
<div class="cell-output-display page-columns page-full">
<div id="tbl-Klausurergebnisse" class="anchored page-columns page-full">

<div id="duzxblmlnf" style="padding-left:0px;padding-right:0px;padding-top:10px;padding-bottom:10px;overflow-x:auto;overflow-y:auto;width:auto;height:auto;" class="page-columns page-full">
<style>#duzxblmlnf table {
  font-family: system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

#duzxblmlnf thead, #duzxblmlnf tbody, #duzxblmlnf tfoot, #duzxblmlnf tr, #duzxblmlnf td, #duzxblmlnf th {
  border-style: none;
}

#duzxblmlnf p {
  margin: 0;
  padding: 0;
}

#duzxblmlnf .gt_table {
  display: table;
  border-collapse: collapse;
  line-height: normal;
  margin-left: auto;
  margin-right: auto;
  color: #000000;
  font-size: 16px;
  font-weight: normal;
  font-style: normal;
  background-color: #FFFFFF;
  width: auto;
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #A8A8A8;
  border-right-style: none;
  border-right-width: 2px;
  border-right-color: #D3D3D3;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #000000;
  border-left-style: none;
  border-left-width: 2px;
  border-left-color: #D3D3D3;
}

#duzxblmlnf .gt_caption {
  padding-top: 4px;
  padding-bottom: 4px;
}

#duzxblmlnf .gt_title {
  color: #000000;
  font-size: 125%;
  font-weight: initial;
  padding-top: 4px;
  padding-bottom: 4px;
  padding-left: 5px;
  padding-right: 5px;
  border-bottom-color: #FFFFFF;
  border-bottom-width: 0;
}

#duzxblmlnf .gt_subtitle {
  color: #000000;
  font-size: 85%;
  font-weight: initial;
  padding-top: 3px;
  padding-bottom: 5px;
  padding-left: 5px;
  padding-right: 5px;
  border-top-color: #FFFFFF;
  border-top-width: 0;
}

#duzxblmlnf .gt_heading {
  background-color: #FFFFFF;
  text-align: center;
  border-bottom-color: #FFFFFF;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
}

#duzxblmlnf .gt_bottom_border {
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
}

#duzxblmlnf .gt_col_headings {
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #000000;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #000000;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
}

#duzxblmlnf .gt_col_heading {
  color: #000000;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: bold;
  text-transform: inherit;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
  vertical-align: bottom;
  padding-top: 5px;
  padding-bottom: 6px;
  padding-left: 5px;
  padding-right: 5px;
  overflow-x: hidden;
}

#duzxblmlnf .gt_column_spanner_outer {
  color: #000000;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: bold;
  text-transform: inherit;
  padding-top: 0;
  padding-bottom: 0;
  padding-left: 4px;
  padding-right: 4px;
}

#duzxblmlnf .gt_column_spanner_outer:first-child {
  padding-left: 0;
}

#duzxblmlnf .gt_column_spanner_outer:last-child {
  padding-right: 0;
}

#duzxblmlnf .gt_column_spanner {
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #000000;
  vertical-align: bottom;
  padding-top: 5px;
  padding-bottom: 5px;
  overflow-x: hidden;
  display: inline-block;
  width: 100%;
}

#duzxblmlnf .gt_spanner_row {
  border-bottom-style: hidden;
}

#duzxblmlnf .gt_group_heading {
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
  color: #000000;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: initial;
  text-transform: inherit;
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #D3D3D3;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
  vertical-align: middle;
  text-align: left;
}

#duzxblmlnf .gt_empty_group_heading {
  padding: 0.5px;
  color: #000000;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: initial;
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #D3D3D3;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  vertical-align: middle;
}

#duzxblmlnf .gt_from_md > :first-child {
  margin-top: 0;
}

#duzxblmlnf .gt_from_md > :last-child {
  margin-bottom: 0;
}

#duzxblmlnf .gt_row {
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
  margin: 10px;
  border-top-style: solid;
  border-top-width: 1px;
  border-top-color: #FFFFFF;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
  vertical-align: middle;
  overflow-x: hidden;
}

#duzxblmlnf .gt_stub {
  color: #000000;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: initial;
  text-transform: inherit;
  border-right-style: solid;
  border-right-width: 2px;
  border-right-color: #D3D3D3;
  padding-left: 5px;
  padding-right: 5px;
}

#duzxblmlnf .gt_stub_row_group {
  color: #000000;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: initial;
  text-transform: inherit;
  border-right-style: solid;
  border-right-width: 2px;
  border-right-color: #D3D3D3;
  padding-left: 5px;
  padding-right: 5px;
  vertical-align: top;
}

#duzxblmlnf .gt_row_group_first td {
  border-top-width: 2px;
}

#duzxblmlnf .gt_row_group_first th {
  border-top-width: 2px;
}

#duzxblmlnf .gt_summary_row {
  color: #000000;
  background-color: #FFFFFF;
  text-transform: inherit;
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
}

#duzxblmlnf .gt_first_summary_row {
  border-top-style: solid;
  border-top-color: #D3D3D3;
}

#duzxblmlnf .gt_first_summary_row.thick {
  border-top-width: 2px;
}

#duzxblmlnf .gt_last_summary_row {
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
}

#duzxblmlnf .gt_grand_summary_row {
  color: #000000;
  background-color: #FFFFFF;
  text-transform: inherit;
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
}

#duzxblmlnf .gt_first_grand_summary_row {
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
  border-top-style: double;
  border-top-width: 6px;
  border-top-color: #D3D3D3;
}

#duzxblmlnf .gt_last_grand_summary_row_top {
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
  border-bottom-style: double;
  border-bottom-width: 6px;
  border-bottom-color: #D3D3D3;
}

#duzxblmlnf .gt_striped {
  background-color: rgba(128, 128, 128, 0.05);
}

#duzxblmlnf .gt_table_body {
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #D3D3D3;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #000000;
}

#duzxblmlnf .gt_footnotes {
  color: #000000;
  background-color: #FFFFFF;
  border-bottom-style: none;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  border-left-style: none;
  border-left-width: 2px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 2px;
  border-right-color: #D3D3D3;
}

#duzxblmlnf .gt_footnote {
  margin: 0px;
  font-size: 90%;
  padding-top: 4px;
  padding-bottom: 4px;
  padding-left: 5px;
  padding-right: 5px;
}

#duzxblmlnf .gt_sourcenotes {
  color: #000000;
  background-color: #FFFFFF;
  border-bottom-style: none;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  border-left-style: none;
  border-left-width: 2px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 2px;
  border-right-color: #D3D3D3;
}

#duzxblmlnf .gt_sourcenote {
  font-size: 90%;
  padding-top: 4px;
  padding-bottom: 4px;
  padding-left: 5px;
  padding-right: 5px;
}

#duzxblmlnf .gt_left {
  text-align: left;
}

#duzxblmlnf .gt_center {
  text-align: center;
}

#duzxblmlnf .gt_right {
  text-align: right;
  font-variant-numeric: tabular-nums;
}

#duzxblmlnf .gt_font_normal {
  font-weight: normal;
}

#duzxblmlnf .gt_font_bold {
  font-weight: bold;
}

#duzxblmlnf .gt_font_italic {
  font-style: italic;
}

#duzxblmlnf .gt_super {
  font-size: 65%;
}

#duzxblmlnf .gt_footnote_marks {
  font-size: 75%;
  vertical-align: 0.4em;
  position: initial;
}

#duzxblmlnf .gt_asterisk {
  font-size: 100%;
  vertical-align: 0;
}

#duzxblmlnf .gt_indent_1 {
  text-indent: 5px;
}

#duzxblmlnf .gt_indent_2 {
  text-indent: 10px;
}

#duzxblmlnf .gt_indent_3 {
  text-indent: 15px;
}

#duzxblmlnf .gt_indent_4 {
  text-indent: 20px;
}

#duzxblmlnf .gt_indent_5 {
  text-indent: 25px;
}
</style>
<table class="gt_table" data-quarto-disable-processing="false" data-quarto-bootstrap="false">

  <thead><tr class="gt_col_headings">
<th class="gt_col_heading gt_columns_bottom_border gt_left" rowspan="1" colspan="1" scope="col" id="Name">Name</th>
      <th class="gt_col_heading gt_columns_bottom_border gt_right" rowspan="1" colspan="1" scope="col" id="Mikro">Mikro</th>
      <th class="gt_col_heading gt_columns_bottom_border gt_right" rowspan="1" colspan="1" scope="col" id="Makro">Makro</th>
      <th class="gt_col_heading gt_columns_bottom_border gt_right" rowspan="1" colspan="1" scope="col" id="Mathe">Mathe</th>
    </tr></thead>
<tbody class="gt_table_body">
<tr>
<td headers="Name" class="gt_row gt_left">Tim</td>
<td headers="Mikro" class="gt_row gt_right">NA</td>
<td headers="Makro" class="gt_row gt_right">1.3</td>
<td headers="Mathe" class="gt_row gt_right">3</td>
</tr>
<tr>
<td headers="Name" class="gt_row gt_left">Lena</td>
<td headers="Mikro" class="gt_row gt_right">1</td>
<td headers="Makro" class="gt_row gt_right">3</td>
<td headers="Mathe" class="gt_row gt_right">NA</td>
</tr>
<tr>
<td headers="Name" class="gt_row gt_left">Ricarda</td>
<td headers="Mikro" class="gt_row gt_right">2</td>
<td headers="Makro" class="gt_row gt_right">1.7</td>
<td headers="Mathe" class="gt_row gt_right">1.3</td>
</tr>
<tr>
<td headers="Name" class="gt_row gt_left">Simon</td>
<td headers="Mikro" class="gt_row gt_right">2.3</td>
<td headers="Makro" class="gt_row gt_right">3.3</td>
<td headers="Mathe" class="gt_row gt_right">NA</td>
</tr>
</tbody>
</table>
<div class="quarto-table-caption margin-caption">Tabelle&nbsp;2.1:  <p>Datensatz <em>Klausurergebnisse</em></p> </div></div>
</div>
</div>
</div>
<p>Der Datensatz ist noch nicht in der R-Arbeitsumgebung verf√ºgbar. Mit der Funktion <code><a href="https://tibble.tidyverse.org/reference/tribble.html">tribble()</a></code> k√∂nnen wir <a href="#tbl-Klausurergebnisse">Tabelle&nbsp;<span>2.1</span></a> h√§ndisch als R-Objekt der Klasse <code>tibble</code> definieren</p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>
<div id="qwebr-interactive-area-2" class="qwebr-interactive-area">
  <div id="qwebr-console-area-2" class="qwebr-console-area">
    <div id="qwebr-editor-2" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-2">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-2" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-2" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-2");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-2");
  const editorDiv = document.getElementById("qwebr-editor-2");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-2");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `# 'klasurergebnisse' als tibble definieren
(
  klausurergebnisse <- tribble(
    ~Name,    ~Mikro, ~Makro, ~Mathe,
    "Tim",        NA,    1.3,    3.0,
    "Lena",      1.0,    3.0,     NA,
    "Ricarda",   2.0,    1.7,    1.3,
    "Simon",     2.3,    3.3,     NA
  )
)`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-2-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-2-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script><p><code>klausurergebnisse</code> enh√§lt die Klausurnoten der vier Studierenden (Boebachtungen) spaltenweise <em>pro Modul</em>, d.h. die Spaltennamen <code>Mikro</code>, <code>Makro</code> und <code>Mathe</code> sind Auspr√§gungen der Variable <em>Modul</em>. Der Datensatz liegt also <em>nicht</em> im s.g. <em>Tidy-Format</em> vor.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tidy-Format
</div>
</div>
<div class="callout-body-container callout-body">
<p>Tidy-Format: Jede Spalte ist <strong><em>eine</em></strong> Variable, jede Reihe ist <strong><em>eine</em></strong> Beobachtung und jede Zelle enth√§lt einen <strong><em>einen</em></strong> Wert. Datens√§tze im Tidy-Format sind h√§ufig lang: Die Zeilendimension ist gr√∂√üer als die Spaltendimension.</p>
</div>
</div>
<p>Das Tidy-Format ist hilfreich f√ºr statistische Analysen mit <code>tidyverse</code>-Funktionen wie bspw. <code><a href="https://ggplot2.tidyverse.org/reference/ggplot.html">ggplot()</a></code>. Wir nutzen die Funktion <code><a href="https://tidyr.tidyverse.org/reference/pivot_longer.html">tidyr::pivot_longer()</a></code>, um <code>klausurergebnisse</code> ein (langes) Tidy-Format zu transformieren.</p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>
<div id="qwebr-interactive-area-3" class="qwebr-interactive-area">
  <div id="qwebr-console-area-3" class="qwebr-console-area">
    <div id="qwebr-editor-3" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-3">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-3" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-3" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-3");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-3");
  const editorDiv = document.getElementById("qwebr-editor-3");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-3");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `# 'klausurergebnisse' in Tidy-Format √ºberf√ºhren
(
  long <- pivot_longer(
    data = klausurergebnisse, 
    cols = Mikro:Mathe, 
    names_to = "Modul", 
    values_to = "Note"
  )
)`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-3-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-3-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script><p>Beachte, dass die Spalte <code>Name</code> die Zugeh√∂rigkeit der Auspr√§gungen (<code>Note</code>) jeder Variable (<code>Modul</code>) zu einer Beobachtung identifiziert. Mit dieser Information k√∂nnen wir den langen Datensatz wieder in das urspr√ºngliche (weite) Format zur√ºckf√ºhren. Wir nutzen hierzu <code><a href="https://tidyr.tidyverse.org/reference/pivot_wider.html">tidyr::pivot_wider()</a></code>.</p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>
<div id="qwebr-interactive-area-4" class="qwebr-interactive-area">
  <div id="qwebr-console-area-4" class="qwebr-console-area">
    <div id="qwebr-editor-4" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-4">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-4" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-4" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-4");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-4");
  const editorDiv = document.getElementById("qwebr-editor-4");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-4");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `# langes Format in das Ausgangsformat transformieren
(
  wide <- pivot_wider(
    data = long,
    id_cols = "Name",
    names_from = "Modul", 
    values_from = "Note"
  )
)`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-4-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-4-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script><p>Wenn die Zuweisung von Zwischenergebnissen in Variablen nicht ben√∂tigt wird, kann eine Verkettung von Funktionsaufrufen die Verst√§ndlichkeit des Codes verbessern. Hierzu wird der <a href="https://magrittr.tidyverse.org/reference/pipe.html">Pipe-Operator</a> <code>%&gt;%</code> genutzt. Wir wiederholen die Transformationen mit den <code>tidyr::pivot_*</code>-Funktion bei Verwendung von <code>%&gt;%</code>.</p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>
<div id="qwebr-interactive-area-5" class="qwebr-interactive-area">
  <div id="qwebr-console-area-5" class="qwebr-console-area">
    <div id="qwebr-editor-5" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-5">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-5" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-5" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-5");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-5");
  const editorDiv = document.getElementById("qwebr-editor-5");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-5");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `# langes Format mit %>%
(
  long <- klausurergebnisse %>% 
    pivot_longer(
      cols = Mikro:Mathe, 
      names_to = "Modul", 
      values_to = "Note"
    )
)

# weites Format mit %>%
(
  wide <- long %>% 
    pivot_wider(
      id_cols = "Name",
      names_from = "Modul", 
      values_from = "Note"
    )
)`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-5-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-5-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script><p>Ein Beispiel f√ºr den Nachteil des weiten Formats im Umgang mit <code>tidyverse</code>-Paketen ist die Funktion <code><a href="https://tidyr.tidyverse.org/reference/drop_na.html">tidyr::drop_na()</a></code>. Diese entfernt s√§mtliche <em>Zeilen</em> eines Datensatzes, die <code>NA</code>-Eintr√§ge (d.h. fehlende Werte) aufweisen. Beachte, dass diese Operation im urspr√ºnglichen weiten Format zum Entfernen ganzer Beobachtungen aus <code>wide</code> f√ºhrt.</p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>
<div id="qwebr-interactive-area-6" class="qwebr-interactive-area">
  <div id="qwebr-console-area-6" class="qwebr-console-area">
    <div id="qwebr-editor-6" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-6">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-6" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-6" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-6");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-6");
  const editorDiv = document.getElementById("qwebr-editor-6");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-6");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `# NA-Eintr√§ge aus dem "weiten" Format entfernen
wide %>% 
  drop_na()`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-6-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-6-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script><p>Im Tidy-Format <code>long</code> hingegen bleiben die √ºbrigen Informationen betroffener Beobachtungen erhalten.</p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>
<div id="qwebr-interactive-area-7" class="qwebr-interactive-area">
  <div id="qwebr-console-area-7" class="qwebr-console-area">
    <div id="qwebr-editor-7" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-7">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-7" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-7" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-7");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-7");
  const editorDiv = document.getElementById("qwebr-editor-7");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-7");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `# NA-Eintr√§ge aus dem "langen" Format entfernen
long %>% 
  drop_na()`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-7-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-7-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script></section><section id="pinguine-und-pipes" class="level2 page-columns page-full" data-number="2.2"><h2 data-number="2.2" class="anchored" data-anchor-id="pinguine-und-pipes">
<span class="header-section-number">2.2</span> Pinguine und Pipes</h2>
<p>In diesem Abschnitt zeigen wir die Verwendung h√§ufig verwendeter <code>dplyr</code>-Funktionen (s.g. <em>Verben</em>) f√ºr die Transformation von Datens√§tzen: <code><a href="https://dplyr.tidyverse.org/reference/mutate.html">mutate()</a></code>, <code><a href="https://dplyr.tidyverse.org/reference/select.html">select()</a></code>, <code><a href="https://dplyr.tidyverse.org/reference/filter.html">filter()</a></code>,<code><a href="https://dplyr.tidyverse.org/reference/summarise.html">summarise()</a></code> und <code><a href="https://dplyr.tidyverse.org/reference/arrange.html">arrange()</a></code>.</p>
<p>F√ºr die Illustration verwenden wir den Datensatz <code>penguins</code> aus dem R-Paket <code>palmerpenguins</code>. Dieser Datensatz wurde im Zeitraum 2007 bis 2009 von Dr.&nbsp;Kristen Gorman im Rahmen des <em>Palmer Station Long Term Ecological Research Program</em> zusammengetragen und enth√§lt Gr√∂√üenmessungen f√ºr drei Pinguinarten, die auf den Inseln des <a href="https://en.wikipedia.org/wiki/Palmer_Archipelago">Palmer-Archipels</a> in der Antarktis beobachtet wurden.</p>
<div class="cell">
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># Paket 'palmerpenguins' installieren</span></span>
<span><span class="co"># install.packages("palmerpenguins")</span></span>
<span></span>
<span><span class="co"># Paket 'palmerpenguins' laden</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://allisonhorst.github.io/palmerpenguins/">palmerpenguins</a></span><span class="op">)</span></span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Mit <code><a href="https://rdrr.io/r/utils/data.html">data()</a></code> wird der Datensatz in der Arbeitsumgebung verf√ºgbar gemacht. Wir nutzen <code><a href="https://pillar.r-lib.org/reference/glimpse.html">glimpse()</a></code>, um einen √úberblick zu erhalten.</p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>
<div id="qwebr-interactive-area-8" class="qwebr-interactive-area">
  <div id="qwebr-console-area-8" class="qwebr-console-area">
    <div id="qwebr-editor-8" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-8">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-8" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-8" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-8");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-8");
  const editorDiv = document.getElementById("qwebr-editor-8");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-8");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `# Datensatz in der Arbeitsumgebung verf√ºgbar machen
data(penguins)

# √úbersicht anzeigen lassen
glimpse(penguins)`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-8-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-8-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script><section id="dplyrmutate" class="level3" data-number="2.2.1"><h3 data-number="2.2.1" class="anchored" data-anchor-id="dplyrmutate">
<span class="header-section-number">2.2.1</span> <code>dplyr::mutate()</code>
</h3>
<p>Mit <code><a href="https://dplyr.tidyverse.org/reference/mutate.html">mutate()</a></code> k√∂nnen bestehende Variablen √ºberschrieben oder neue Variablen als Funktion bestehender Variablen definiert werden. <code><a href="https://dplyr.tidyverse.org/reference/mutate.html">mutate()</a></code> operiert in der Spaltendimension des Datensatz.</p>
<p>Wir definieren eine neue Variable <code>body_mass_kg</code> als Transformation <code>body_mass_g/1000</code>.</p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>
<div id="qwebr-interactive-area-9" class="qwebr-interactive-area">
  <div id="qwebr-console-area-9" class="qwebr-console-area">
    <div id="qwebr-editor-9" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-9">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-9" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-9" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-9");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-9");
  const editorDiv = document.getElementById("qwebr-editor-9");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-9");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `# Neue Variable mit Gewicht in Kg definieren
penguins %>% 
  mutate(
    body_mass_kg = body_mass_g/1000
  ) %>%
  glimpse()`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-9-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-9-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script><p>Mit <code><a href="https://dplyr.tidyverse.org/reference/across.html">across()</a></code> kann die dieselbe Operation auf mehrere Variablen angewendet werden.</p>
<p>Im nachstehenden Beispiel √§ndern wir den typ (<code>type</code>) der Variablen <code>species</code>, <code>island</code>, <code>sex</code> und <code>year</code> zu <code>character</code>.</p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>
<div id="qwebr-interactive-area-10" class="qwebr-interactive-area">
  <div id="qwebr-console-area-10" class="qwebr-console-area">
    <div id="qwebr-editor-10" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-10">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-10" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-10" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-10");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-10");
  const editorDiv = document.getElementById("qwebr-editor-10");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-10");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `# species, island, sex und year in Typ 'character' umwandeln
penguins %>% 
  mutate(
    across(
      c(species, island, sex, year), 
      .fns = as.character
    )
  ) %>%
  glimpse()`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-10-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-10-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script><p><code><a href="https://dplyr.tidyverse.org/reference/transmute.html">transmute()</a></code> ist eine Variante von <code><a href="https://dplyr.tidyverse.org/reference/mutate.html">mutate()</a></code>, die lediglich die transformierten Variablen beibeh√§lt.</p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>
<div id="qwebr-interactive-area-11" class="qwebr-interactive-area">
  <div id="qwebr-console-area-11" class="qwebr-console-area">
    <div id="qwebr-editor-11" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-11">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-11" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-11" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-11");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-11");
  const editorDiv = document.getElementById("qwebr-editor-11");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-11");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `# Nur transformierte Variablen behalten
penguins %>% 
  transmute(
    body_mass_kg = body_mass_g/1000
  )`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-11-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-11-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script></section><section id="dplyrselect" class="level3 page-columns page-full" data-number="2.2.2"><h3 data-number="2.2.2" class="anchored" data-anchor-id="dplyrselect">
<span class="header-section-number">2.2.2</span> <code>dplyr::select()</code>
</h3>
<p>Mit <code><a href="https://dplyr.tidyverse.org/reference/select.html">select()</a></code> werden Variablen aus dem Datensatz ausgew√§hlt. Dies geschieht entweder √ºber den Variablennamen‚Ä¶</p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>
<div id="qwebr-interactive-area-12" class="qwebr-interactive-area">
  <div id="qwebr-console-area-12" class="qwebr-console-area">
    <div id="qwebr-editor-12" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-12">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-12" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-12" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-12");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-12");
  const editorDiv = document.getElementById("qwebr-editor-12");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-12");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `# 'species' ausw√§hlen
penguins %>% 
  select(species)`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-12-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-12-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script><div class="page-columns page-full"><p>‚Ä¶ oder √ºber eine Indexmenge.<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></p><div class="no-row-height column-margin column-container"><li id="fn3"><p><sup>3</sup>&nbsp;Hilfreich: <code><a href="https://dplyr.tidyverse.org/reference/pull.html">dplyr::pull()</a></code> selektiert eine Variable und wandelt diese in einen Vektor um.</p></li></div></div>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>
<div id="qwebr-interactive-area-13" class="qwebr-interactive-area">
  <div id="qwebr-console-area-13" class="qwebr-console-area">
    <div id="qwebr-editor-13" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-13">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-13" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-13" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-13");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-13");
  const editorDiv = document.getElementById("qwebr-editor-13");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-13");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `# Teilmenge von Variablen per Index ausw√§hlen
penguins %>% 
  select(
    c(1, 2, 3)
  )`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-13-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-13-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script><p>Variablen k√∂nnen anhand eines Muster im Namen selektiert werden. Die Selektion von <code>ends_with("mm")</code> bezieht nur Variablen mit Endung <code>mm</code> im Namen ein:</p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>
<div id="qwebr-interactive-area-14" class="qwebr-interactive-area">
  <div id="qwebr-console-area-14" class="qwebr-console-area">
    <div id="qwebr-editor-14" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-14">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-14" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-14" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-14");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-14");
  const editorDiv = document.getElementById("qwebr-editor-14");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-14");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `# Nur in mm gemessene Variablen auslesen
penguins %>% 
  select(
    ends_with("mm")
  )`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-14-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-14-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script><p>Mit <code><a href="https://tidyselect.r-lib.org/reference/where.html">where()</a></code> k√∂nnen wir Variablen aufgrund bestimmter Eigenschaften ihrer Auspr√§gungen selektieren.</p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>
<div id="qwebr-interactive-area-15" class="qwebr-interactive-area">
  <div id="qwebr-console-area-15" class="qwebr-console-area">
    <div id="qwebr-editor-15" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-15">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-15" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-15" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-15");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-15");
  const editorDiv = document.getElementById("qwebr-editor-15");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-15");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `# Nur numerische Variablen ausw√§hlen
penguins %>% 
  select(
    where(is.numeric)
  )`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-15-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-15-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script></section><section id="dplyrfilter" class="level3" data-number="2.2.3"><h3 data-number="2.2.3" class="anchored" data-anchor-id="dplyrfilter">
<span class="header-section-number">2.2.3</span> <code>dplyr::filter()</code>
</h3>
<p>Das Verb <code><a href="https://dplyr.tidyverse.org/reference/filter.html">filter()</a></code> filtert den Datensatz in der Zeilendimension. So k√∂nnen Beobachtungen ausgew√§lt werden, deren Merkmalsauspr√§gungen bestimmte Kriterien erf√ºllen. Hierzu muss <code><a href="https://dplyr.tidyverse.org/reference/filter.html">filter()</a></code> ein logischer (<code>logical</code>) Ausdruck √ºbergeben werden. H√§ufig erfolgt dies √ºber Vergleichsoperatoren.</p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>
<div id="qwebr-interactive-area-16" class="qwebr-interactive-area">
  <div id="qwebr-console-area-16" class="qwebr-console-area">
    <div id="qwebr-editor-16" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-16">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-16" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-16" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-16");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-16");
  const editorDiv = document.getElementById("qwebr-editor-16");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-16");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `# Nur Pinguine mit bill_length_mm >= 39
penguins %>% 
  filter(
    bill_length_mm >= 39
  )`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-16-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-16-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script><style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>
<div id="qwebr-interactive-area-17" class="qwebr-interactive-area">
  <div id="qwebr-console-area-17" class="qwebr-console-area">
    <div id="qwebr-editor-17" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-17">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-17" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-17" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-17");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-17");
  const editorDiv = document.getElementById("qwebr-editor-17");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-17");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `# Nur Pinguine mit bill_length_mm <= 40
penguins %>% 
  filter(
    bill_length_mm <= 40
  )`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-17-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-17-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script><p>Oft ist es praktisch, mehrere Kriterien zu kombinieren.</p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>
<div id="qwebr-interactive-area-18" class="qwebr-interactive-area">
  <div id="qwebr-console-area-18" class="qwebr-console-area">
    <div id="qwebr-editor-18" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-18">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-18" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-18" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-18");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-18");
  const editorDiv = document.getElementById("qwebr-editor-18");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-18");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `# Kombinierter Filter -- Variante 1
penguins %>% 
  filter(
    bill_length_mm >= 39 & bill_length_mm <= 40
  )`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-18-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-18-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script><p>Analog: komma-getrennte Kriterien werden intern √ºber den Und-Operator (<code>&amp;</code>) verkn√ºpft.</p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>
<div id="qwebr-interactive-area-19" class="qwebr-interactive-area">
  <div id="qwebr-console-area-19" class="qwebr-console-area">
    <div id="qwebr-editor-19" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-19">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-19" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-19" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-19");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-19");
  const editorDiv = document.getElementById("qwebr-editor-19");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-19");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `# Kombinierter Filter -- Variante 2
penguins %>% 
  filter(
    bill_length_mm >= 39, 
    bill_length_mm <= 40
  )`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-19-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-19-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script><p>√Ñhnlich wie bei <code><a href="https://dplyr.tidyverse.org/reference/select.html">select()</a></code> verwenden wir h√§ufig n√ºtzliche Funktionen, welche die Interpretation des Codes erleichtern. <code><a href="https://dplyr.tidyverse.org/reference/between.html">dplyr::between()</a></code> erlaubt filtern innerhalb eines Intervals.</p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>
<div id="qwebr-interactive-area-20" class="qwebr-interactive-area">
  <div id="qwebr-console-area-20" class="qwebr-console-area">
    <div id="qwebr-editor-20" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-20">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-20" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-20" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-20");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-20");
  const editorDiv = document.getElementById("qwebr-editor-20");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-20");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `# Filtern mit Hilfsfunktion
penguins %>% 
  filter(
    between(
      bill_length_mm, left = 39, right = 40
    )
  )`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-20-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-20-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script><p>Mit diesen Verben sind wir bereits in der Lage, den Datensatz gem√§√ü folgender Vorschrift zu bereinigen:</p>
<ol type="1">
<li>Entfernen der Ma√üeinheiten aus den Variablennamen</li>
<li>Entfernen von Pinguinen mit fehlenden Werten (<code>NA</code>)</li>
<li>Entfernen von Pinguinen mit einem Gewicht <em>oberhalb</em> des 95%-Stichprobenquantils</li>
</ol>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>
<div id="qwebr-interactive-area-21" class="qwebr-interactive-area">
  <div id="qwebr-console-area-21" class="qwebr-console-area">
    <div id="qwebr-editor-21" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-21">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-21" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-21" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-21");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-21");
  const editorDiv = document.getElementById("qwebr-editor-21");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-21");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `# Schritt 1
(
  penguins_cleaned <- penguins %>% 
    rename(
      bill_length = bill_length_mm,
      bill_depth  = bill_depth_mm,
      flipper_length = flipper_length_mm,
      body_mass = body_mass_g
    )
)`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-21-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-21-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script><style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>
<div id="qwebr-interactive-area-22" class="qwebr-interactive-area">
  <div id="qwebr-console-area-22" class="qwebr-console-area">
    <div id="qwebr-editor-22" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-22">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-22" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-22" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-22");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-22");
  const editorDiv = document.getElementById("qwebr-editor-22");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-22");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `# Schritt 2
(
  penguins_cleaned <- penguins_cleaned %>%
    drop_na()
)`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-22-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-22-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script><style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>
<div id="qwebr-interactive-area-23" class="qwebr-interactive-area">
  <div id="qwebr-console-area-23" class="qwebr-console-area">
    <div id="qwebr-editor-23" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-23">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-23" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-23" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-23");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-23");
  const editorDiv = document.getElementById("qwebr-editor-23");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-23");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `# Schritt 3
penguins_cleaned %>% 
  filter(
    body_mass < quantile(body_mass, probs = .95)
  ) %>%
  glimpse()`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-23-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-23-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script><p>Durch die Verkettung mit <code>%&gt;%</code> k√∂nnen wir s√§mtliche Schritte f√ºr die Bereinigung ohne das Abspeichern von Zwischenergebnissen durchf√ºhren.</p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>
<div id="qwebr-interactive-area-24" class="qwebr-interactive-area">
  <div id="qwebr-console-area-24" class="qwebr-console-area">
    <div id="qwebr-editor-24" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-24">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-24" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-24" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-24");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-24");
  const editorDiv = document.getElementById("qwebr-editor-24");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-24");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `# Verketter Funktionsaufruf f√ºr Datensatzbereinigung
penguins_cleaned <- penguins %>% 
  rename(
    bill_length = bill_length_mm,
    bill_depth  = bill_depth_mm,
    flipper_length = flipper_length_mm,
    body_mass = body_mass_g
  ) %>% 
  drop_na() %>% 
  filter(
    body_mass < quantile(body_mass, .95)
  )

penguins_cleaned %>% 
  glimpse()`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-24-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-24-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script></section><section id="dplyrsummarise" class="level3 page-columns page-full" data-number="2.2.4"><h3 data-number="2.2.4" class="anchored" data-anchor-id="dplyrsummarise">
<span class="header-section-number">2.2.4</span> <code>dplyr::summarise()</code>
</h3>
<div class="page-columns page-full"><p>Das Verb <code><a href="https://dplyr.tidyverse.org/reference/summarise.html">summarise()</a></code> fasst Variablen √ºber Beobachtungen hinweg zusammen. Der nachstehende Code-Chunk erzeugt eine Tabelle mit Stichprobenmittelwert und -standardabweichung von <code>flipper_length_mm</code>.<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> Um zu vermeiden, dass die Auswertung aufgrund fehlender Werte (<code>NA</code>) in <code>flipper_length_mm</code> scheitert, lassen wir <code>NA</code>s mit <code>na.rm = TRUE</code> bei der Berechnung unber√ºcksichtigt (wir verwenden weiterhin den unbereinigten Datensatz <code>penguins</code>).</p><div class="no-row-height column-margin column-container"><li id="fn4"><p><sup>4</sup>&nbsp;<code><a href="https://dplyr.tidyverse.org/reference/summarise.html">dplyr::summarise()</a></code> darf nicht mit <code><a href="https://rdrr.io/r/base/summary.html">base::summary()</a></code> verwechselt werden!</p></li></div></div>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>
<div id="qwebr-interactive-area-25" class="qwebr-interactive-area">
  <div id="qwebr-console-area-25" class="qwebr-console-area">
    <div id="qwebr-editor-25" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-25">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-25" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-25" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-25");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-25");
  const editorDiv = document.getElementById("qwebr-editor-25");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-25");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `# statistische Zusammenfassung mit 'summarise()'
penguins %>% 
  select(flipper_length_mm) %>% 
  summarise(
    mean = mean(flipper_length_mm, na.rm = TRUE), 
    sd = sd(flipper_length_mm, na.rm = TRUE)
  )`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-25-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-25-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script><p>Varianten von <code><a href="https://dplyr.tidyverse.org/reference/summarise.html">summarise()</a></code> k√∂nnen √ºber mehrere Variablen angewendet werden. Wir verwenden <code><a href="https://dplyr.tidyverse.org/reference/across.html">across()</a></code> und <code><a href="https://tidyselect.r-lib.org/reference/where.html">where()</a></code>, um lediglich numerische Variablen mit den in der liste definierten Funktionen zusammenzufassen. Beachte, dass <code>\(x) mean(x)</code> eine anonyme Funktion definiert.</p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>
<div id="qwebr-interactive-area-26" class="qwebr-interactive-area">
  <div id="qwebr-console-area-26" class="qwebr-console-area">
    <div id="qwebr-editor-26" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-26">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-26" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-26" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-26");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-26");
  const editorDiv = document.getElementById("qwebr-editor-26");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-26");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `penguins %>% 
  summarise(
    across(
      where(is.numeric), 
      .fns = list(
        mean = \\(x) mean(x, na.rm = TRUE), 
        sd = \\(x) sd(x, na.rm = TRUE)
      )
    )
  ) %>%
  glimpse()`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-26-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-26-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script></section><section id="dplyrarrange" class="level3" data-number="2.2.5"><h3 data-number="2.2.5" class="anchored" data-anchor-id="dplyrarrange">
<span class="header-section-number">2.2.5</span> <code>dplyr::arrange()</code>
</h3>
<p>Mit <code><a href="https://dplyr.tidyverse.org/reference/arrange.html">arrange()</a></code> k√∂nnen Datens√§tze in Abh√§ngigkeit der beobachteten Auspr√§gungen von Variablen sortiert werden.</p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>
<div id="qwebr-interactive-area-27" class="qwebr-interactive-area">
  <div id="qwebr-console-area-27" class="qwebr-console-area">
    <div id="qwebr-editor-27" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-27">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-27" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-27" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-27");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-27");
  const editorDiv = document.getElementById("qwebr-editor-27");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-27");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `# Datensatz aufsteigend nach 'body_mass_g' sortieren
penguins %>% 
  arrange(body_mass_g)`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-27-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-27-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script><p>Die Funktion <code><a href="https://dplyr.tidyverse.org/reference/desc.html">dplyr::desc()</a></code> kehrt die Reihenfolge zu einer absteigenden Sortierung um.</p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>
<div id="qwebr-interactive-area-28" class="qwebr-interactive-area">
  <div id="qwebr-console-area-28" class="qwebr-console-area">
    <div id="qwebr-editor-28" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-28">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-28" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-28" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-28");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-28");
  const editorDiv = document.getElementById("qwebr-editor-28");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-28");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `# Absteigende Sortierung nach 'body_mass_g'
penguins %>% 
  arrange(
    desc(body_mass_g)
  )`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-28-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-28-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script><p>Komplexe Sortier-Muster werden durch √úbergabe von Variablennamen in der gew√ºnschten Reihenfolge erreicht.</p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>
<div id="qwebr-interactive-area-29" class="qwebr-interactive-area">
  <div id="qwebr-console-area-29" class="qwebr-console-area">
    <div id="qwebr-editor-29" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-29">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-29" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-29" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-29");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-29");
  const editorDiv = document.getElementById("qwebr-editor-29");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-29");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `# Erst Sortierung nach 'sex', dann gruppenweise absteigend 
# nach 'body_mass_g' sortieren
penguins %>% 
  arrange(
    sex, desc(body_mass_g)
  )`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-29-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-29-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script></section><section id="operationen-mit-gruppierten-datens√§tzen" class="level3" data-number="2.2.6"><h3 data-number="2.2.6" class="anchored" data-anchor-id="operationen-mit-gruppierten-datens√§tzen">
<span class="header-section-number">2.2.6</span> Operationen mit gruppierten Datens√§tzen</h3>
<p>F√ºr manche Transformationen ist eine Gruppierung der Daten hilfreich. Wir illustrieren nachfolgend die unterschiedlichen Verhaltensweisen ausgew√§hlter Verben durch Vergleiche von gruppierten und nicht-gruppierten Anwendungen.</p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>
<div id="qwebr-interactive-area-30" class="qwebr-interactive-area">
  <div id="qwebr-console-area-30" class="qwebr-console-area">
    <div id="qwebr-editor-30" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-30">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-30" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-30" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-30");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-30");
  const editorDiv = document.getElementById("qwebr-editor-30");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-30");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `# Datensatz gruppieren
penguins_grouped <- penguins %>% 
  group_by(species)

# Datensatz hat nun die Eigenschaft 'Groups'
glimpse(penguins_grouped)`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-30-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-30-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script><p><code>species</code> hat drei Auspr√§gungen. Entsprechend ist <code>penguins_grouped</code> nun in drei Gruppen eingeteilt.</p>
<p>Bei gruppierten Datens√§tzen fasst <code><a href="https://dplyr.tidyverse.org/reference/summarise.html">summarise()</a></code> die Variablen pro Guppe zusammen.</p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>
<div id="qwebr-interactive-area-31" class="qwebr-interactive-area">
  <div id="qwebr-console-area-31" class="qwebr-console-area">
    <div id="qwebr-editor-31" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-31">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-31" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-31" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-31");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-31");
  const editorDiv = document.getElementById("qwebr-editor-31");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-31");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `# summarise -- ungruppiert:
penguins %>%
  summarise(
    across(
      where(is.numeric), \\(x) mean(x, na.rm = T)
      )
    )`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-31-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-31-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script><style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>
<div id="qwebr-interactive-area-32" class="qwebr-interactive-area">
  <div id="qwebr-console-area-32" class="qwebr-console-area">
    <div id="qwebr-editor-32" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-32">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-32" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-32" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-32");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-32");
  const editorDiv = document.getElementById("qwebr-editor-32");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-32");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `# summarise -- gruppiert:    
penguins_grouped %>%
  summarise(
    across(
      where(is.numeric), 
      ~ mean(., na.rm = T)
    )
  )`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-32-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-32-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script><p><code><a href="https://dplyr.tidyverse.org/reference/mutate.html">mutate()</a></code> definiert bzw. transformiert f√ºr jede Gruppe separat. Im dies zu veranschaulichen, ziehen wir eine Zufallsstichprobe von 10 Pinguinen aus der Datensatz.</p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>
<div id="qwebr-interactive-area-33" class="qwebr-interactive-area">
  <div id="qwebr-console-area-33" class="qwebr-console-area">
    <div id="qwebr-editor-33" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-33">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-33" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-33" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-33");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-33");
  const editorDiv = document.getElementById("qwebr-editor-33");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-33");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `# Zufallsstichprobe generieren
set.seed(123)
(
  penguins_sample <- penguins %>%
    slice_sample(n = 10)  
)`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-33-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-33-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script><style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>
<div id="qwebr-interactive-area-34" class="qwebr-interactive-area">
  <div id="qwebr-console-area-34" class="qwebr-console-area">
    <div id="qwebr-editor-34" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-34">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-34" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-34" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-34");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-34");
  const editorDiv = document.getElementById("qwebr-editor-34");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-34");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `# mutate() -- ungruppiert:
penguins_sample %>%
  transmute(
    mean = mean(bill_length_mm)
  )`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-34-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-34-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script><p>F√ºr den ungruppierten Datensatz berechnet <code><a href="https://dplyr.tidyverse.org/reference/mutate.html">mutate()</a></code> das Stichprobenmittel von <code>bill_length_mm</code> √ºber <em>alle</em> zehn Datenpunkte und wei√üt diesen Wert jeweils in der Variable <code>mean</code> zu.</p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>
<div id="qwebr-interactive-area-35" class="qwebr-interactive-area">
  <div id="qwebr-console-area-35" class="qwebr-console-area">
    <div id="qwebr-editor-35" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-35">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-35" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-35" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-35");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-35");
  const editorDiv = document.getElementById("qwebr-editor-35");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-35");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `# mutate() -- gruppiert
penguins_sample %>%
  group_by(species) %>%
  transmute(
    mean = mean(bill_length_mm)
  )`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-35-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-35-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script><p>Bei gruppierten Daten berechnet <code><a href="https://dplyr.tidyverse.org/reference/mutate.html">mutate()</a></code> das Stichprobenmittel <em>pro Gruppe</em> und weist die Mittelwerte entsprechend zu.</p>
</section></section><section id="eine-explorative-analyse-mit-ggplot2" class="level2" data-number="2.3"><h2 data-number="2.3" class="anchored" data-anchor-id="eine-explorative-analyse-mit-ggplot2">
<span class="header-section-number">2.3</span> Eine explorative Analyse mit <code>ggplot2</code>
</h2>
<p>Der bereinigte Datensatz <code>penguins_cleaned</code> eignet sich gut f√ºr eine graphische Auswertung mit dem R-Paket <code>ggplot2</code>, welches Bestandteil des <code>tidyverse</code> ist. Nachfolgend untersuchen wir Zusammenh√§nge zwischen den K√∂rperma√üen der Pinguine.</p>
<p>Wir erstellen zun√§chst einen einfachen Punkteplot des Gewichts (<code>body_mass</code>) und der Schnabeltiefe (<code>bill_depth</code>).</p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>
<div id="qwebr-interactive-area-36" class="qwebr-interactive-area">
  <div id="qwebr-console-area-36" class="qwebr-console-area">
    <div id="qwebr-editor-36" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-36">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-36" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-36" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-36");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-36");
  const editorDiv = document.getElementById("qwebr-editor-36");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-36");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `# Punkteplot: body_mass vs. bill_depth
penguins_cleaned %>%
  ggplot(
    mapping = aes(
      x = body_mass, 
      y = bill_depth
    )
  ) +
  geom_point()`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-36-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-36-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script><p>Die Grafik zeigt einen positiven Zusammenhang zwischen dem Gewicht und der Schnabeltiefe. Als n√§chstes passen wir den Code so an, dass die Datenpunkte entsprechend der Art (<code>species</code>) eingef√§rbt sind.</p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>
<div id="qwebr-interactive-area-37" class="qwebr-interactive-area">
  <div id="qwebr-console-area-37" class="qwebr-console-area">
    <div id="qwebr-editor-37" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-37">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-37" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-37" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-37");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-37");
  const editorDiv = document.getElementById("qwebr-editor-37");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-37");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `# Punkteplot: Farbliche Darstellung verschiedener Arten
penguins_cleaned %>%
  ggplot(
    mapping = aes(
      x = body_mass, 
      y = bill_depth, 
      color = species
    )
  ) +
  geom_point()`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-37-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-37-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script><p>Offenbar gibt es deutliche Unterschiede in der (gemeinsamen) Verteilung von Gewicht und Schnabeltiefe zwischen den verschiedenen Arten.</p>
<p>Um den Zusammenhang zwischen Gewicht und Schnabeltiefe zu untersuchen, sch√§tzen wir lineare Regressionen <span class="math display">\[body\_mass = \beta_0 + \beta_1 bill\_depth + u\]</span> separat f√ºr jede der drei Pinguinarten mit der KQ-Methode. Anschlie√üend zeichnen wir die gesch√§tzten Regressionsgeraden ein.</p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>
<div id="qwebr-interactive-area-38" class="qwebr-interactive-area">
  <div id="qwebr-console-area-38" class="qwebr-console-area">
    <div id="qwebr-editor-38" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-38">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-38" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-38" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-38");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-38");
  const editorDiv = document.getElementById("qwebr-editor-38");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-38");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `# Lineare Regression per Art
penguins_cleaned %>%
  ggplot(
    aes(
      x = body_mass, 
      y = bill_depth, 
      color = species
    )
  ) +
  geom_point() +
  geom_smooth(method = "lm", se = F)`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-38-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-38-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script><p>Die Sch√§tzungen bekr√§ftigen die Vermutung, dass der lineare Zusammenhang zwischen Gewicht und Schnabeltiefe sich nicht zwischen den verschiedenen Pinguinarten unterscheidet: Pinguine der Art <em>Gentoo</em> sind im Mittel schwerer als Pinguine der √ºbrigen Arten, haben jedoch eine geringere Schnabeltiefe.</p>
<p>Der nachfolgende Code f√ºgt der Grafik eine Regressionsline <em>√ºber alle</em> Arten hinzu. Wir setzen hierbei das Argment <code>inherit_aes = FALSE</code> und legen damit fest, dass die Regression f√ºr <code>body_mass</code> und <code>bill_depth</code> ohne Differenzierung per <code>species</code> durchgef√ºhrt wird.</p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>
<div id="qwebr-interactive-area-39" class="qwebr-interactive-area">
  <div id="qwebr-console-area-39" class="qwebr-console-area">
    <div id="qwebr-editor-39" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-39">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-39" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-39" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-39");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-39");
  const editorDiv = document.getElementById("qwebr-editor-39");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-39");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `# Zusatz: Globale Regression
penguins_cleaned %>%
  ggplot(
    mapping = aes(
      x = body_mass, 
      y = bill_depth, 
      color = species
    )
  ) +
  geom_point() +
  geom_smooth(method = "lm", se = F) +
  # Regression f√ºr alle Datenpunkte
  geom_smooth(
    mapping = aes(
      x = body_mass, 
      y = bill_depth
    ),
    method = "lm", 
    se = F, 
    inherit.aes = F
  )`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-39-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-39-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script><p>Offenbar ist die vorherige Analyse per Spezies sinnvoller: Die Regression √ºber alle Arten suggeriert einen negativen Zusammenhang zwischen Gewicht und Schnabeltiefe.</p>
<p><em>Facetting</em> mit <code><a href="https://ggplot2.tidyverse.org/reference/facet_wrap.html">facet_wrap()</a></code> erlaubt eine Untersuchung des Zusammenhangs je Insel (<code>island</code>), auf der die Messung erfolgt ist.</p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>
<div id="qwebr-interactive-area-40" class="qwebr-interactive-area">
  <div id="qwebr-console-area-40" class="qwebr-console-area">
    <div id="qwebr-editor-40" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-40">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-40" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-40" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-40");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-40");
  const editorDiv = document.getElementById("qwebr-editor-40");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-40");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `# Facettierung des per In
penguins_cleaned %>%
  ggplot(
    mapping = aes(
      x = body_mass, 
      y = bill_depth, 
      color = species)
  ) +
  geom_point() +
  geom_smooth(method = "lm", se = F) +
  facet_wrap(~ island)`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-40-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-40-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script><p>Wir sehen, dass es hinsichtlich des Zusammenhangs von Gewicht und Schnabeltiefe keine wesentlichen Diskrepanzen zwischen den drei Inseln gibt. Dar√ºber hinaus l√§sst sich anhand der Facetten leicht erkennen, wie die drei Arten √ºber die Inseln verteilt sind.</p>


<!-- -->

</section></main><!-- /main --><script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "Óßã";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Kopiert");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Kopiert");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script><nav class="page-navigation"><div class="nav-page nav-page-previous">
      <a href="./index.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Start</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./Matching.html" class="pagination-link">
        <span class="nav-page-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Matching</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Quellcode</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb3" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="an">webr:</span><span class="co"> </span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co">  show-startup-message: true</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co">  packages: ['tidyverse', 'palmerpenguins']</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="fu"># Statistische Programmierung mit R</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="co">#| results: "asis"</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a><span class="fu">source</span>(<span class="st">"setup.R"</span>)</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(tidyverse)</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(kableExtra)</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(modelsummary)</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(gt)</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>Dieses Kapitel ist *nicht* als umfassende Einf√ºhrung in R gedacht, sondern behandelt Kernfunktionen aus der Paketsammlung <span class="in">`tidyverse`</span>. Wenngleich die Inhalte deutlich √ºber ein Hallo-Welt-Beispiel^<span class="co">[</span><span class="ot">https://de.wikipedia.org/wiki/Hallo-Welt-Programm</span><span class="co">]</span> hinausgehen, betrachten wir hier grundlegene Funktionen f√ºr Datenmanipulation und Visualisierung. Diese sind Vorraussetzung f√ºr das Verst√§ndnis fortgeschrittener Code-Bausteine in sp√§teren Kapiteln. Falls Sie bereits √ºber Grundkenntnisse im Umgang mit <span class="in">`tidyverse`</span> verf√ºgen, k√∂nnen Sie dieses Kapitel √ºberspringen. Sollten Sie nicht oder nur teilweise mit den hier gezeigten Befehlen vertraut sein oder keinerlei Erfahrung mit R haben, empfiehlt sich vorab eine Erarbeitung bzw. Wiederholung der Inhalte. Nachstehede Ressourcen finden wir hilfreich:</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Feedbackgest√ºtze interaktive √úbungsaufgaben bei DataCamp^<span class="co">[</span><span class="ot">Ein Teil des hier angebotenen Katalogs (exlusive *Einf√ºhrung in R*) ist kostenpflichtig.</span><span class="co">]</span>, bspw. </span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a><span class="ss">    - </span><span class="co">[</span><span class="ot">Einf√ºhrung in R</span><span class="co">](https://campus.datacamp.com/courses/einfuhrung-in-r/)</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a><span class="ss">    - </span><span class="co">[</span><span class="ot">Introduction to Data Visualization with ggplot2</span><span class="co">](https://www.datacamp.com/courses/introduction-to-data-visualization-with-ggplot2)</span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a><span class="ss">    - </span><span class="co">[</span><span class="ot">Data Manipulation with dplyr</span><span class="co">](https://www.datacamp.com/courses/data-manipulation-with-dplyr)</span></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Open-source-Literatur wie </span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a><span class="ss">    - </span>der umfangreiche Leitfaden von <span class="co">[</span><span class="ot">Ellis und Mayer (2023)</span><span class="co">](https://methodenlehre.github.io/einfuehrung-in-R/)</span></span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a><span class="ss">    - </span><span class="co">[</span><span class="ot">R for Data Science</span><span class="co">](https://r4ds.hadley.nz/)</span></span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a><span class="ss">    - </span><span class="co">[</span><span class="ot">Hands-On Programming with R</span><span class="co">](https://rstudio-education.github.io/hopr/)</span></span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a>Wir laden zun√§chst die Paketsammlung <span class="in">`tidyverse`</span>. F√ºr die Reproduktion mit dem <span class="co">[</span><span class="ot">R GUI</span><span class="co">](https://www.r-project.org/)</span> oder mit <span class="co">[</span><span class="ot">RStudio</span><span class="co">](https://posit.co/download/rstudio-desktop/)</span> muss das Paket vorab mit <span class="in">`install.packages()`</span> installiert werden. In den interaktiven R-Konsolen in diesem Kapitel (und im Rest des Buchs) sind die ben√∂tigten R-Pakete bereits installiert *und* geladen, sofern nicht anders beschrieben. </span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-40"><a href="#cb3-40" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb3-41"><a href="#cb3-41" aria-hidden="true" tabindex="-1"></a><span class="co"># Paket tidyverse installieren</span></span>
<span id="cb3-42"><a href="#cb3-42" aria-hidden="true" tabindex="-1"></a><span class="co"># install.packages("tidyverse")</span></span>
<span id="cb3-43"><a href="#cb3-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-44"><a href="#cb3-44" aria-hidden="true" tabindex="-1"></a><span class="co"># Paket 'tidyverse' laden</span></span>
<span id="cb3-45"><a href="#cb3-45" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(tidyverse)</span>
<span id="cb3-46"><a href="#cb3-46" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-47"><a href="#cb3-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-48"><a href="#cb3-48" aria-hidden="true" tabindex="-1"></a>F√ºr das Verst√§ndnis von Code-Chunks ist es hilfreich, Zwischenergebnisse explizit zu evaluieren und in der Konsole auszugeben. Hierf√ºr umschlie√üen wir h√§ufig Code-Zeilen mit runden Klammern. Der n√§chste Chunk illustriert dies f√ºr die Variable <span class="in">`x`</span>.</span>
<span id="cb3-49"><a href="#cb3-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-50"><a href="#cb3-50" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb3-51"><a href="#cb3-51" aria-hidden="true" tabindex="-1"></a><span class="in"># Variable definieren...</span></span>
<span id="cb3-52"><a href="#cb3-52" aria-hidden="true" tabindex="-1"></a><span class="in">x &lt;- pi</span></span>
<span id="cb3-53"><a href="#cb3-53" aria-hidden="true" tabindex="-1"></a><span class="in"># ... und evaluieren</span></span>
<span id="cb3-54"><a href="#cb3-54" aria-hidden="true" tabindex="-1"></a><span class="in">x</span></span>
<span id="cb3-55"><a href="#cb3-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-56"><a href="#cb3-56" aria-hidden="true" tabindex="-1"></a><span class="in"># √Ñquivalent:</span></span>
<span id="cb3-57"><a href="#cb3-57" aria-hidden="true" tabindex="-1"></a><span class="in">(</span></span>
<span id="cb3-58"><a href="#cb3-58" aria-hidden="true" tabindex="-1"></a><span class="in">  x &lt;- pi</span></span>
<span id="cb3-59"><a href="#cb3-59" aria-hidden="true" tabindex="-1"></a><span class="in">)</span></span>
<span id="cb3-60"><a href="#cb3-60" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-61"><a href="#cb3-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-62"><a href="#cb3-62" aria-hidden="true" tabindex="-1"></a><span class="fu">## Lange, weite und "tidy" Datenformate</span></span>
<span id="cb3-63"><a href="#cb3-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-64"><a href="#cb3-64" aria-hidden="true" tabindex="-1"></a>Wir betrachten den in @tbl-Klausurergebnisse dargestellten Datensatz *Klausurergebnisse*.</span>
<span id="cb3-65"><a href="#cb3-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-66"><a href="#cb3-66" aria-hidden="true" tabindex="-1"></a><span class="in">```{r, echo=F, eval = T}</span></span>
<span id="cb3-67"><a href="#cb3-67" aria-hidden="true" tabindex="-1"></a><span class="co">#| tbl-cap: "Datensatz *Klausurergebnisse*"</span></span>
<span id="cb3-68"><a href="#cb3-68" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: tbl-Klausurergebnisse</span></span>
<span id="cb3-69"><a href="#cb3-69" aria-hidden="true" tabindex="-1"></a>klausurergebnisse <span class="ot">&lt;-</span> <span class="fu">tribble</span>(</span>
<span id="cb3-70"><a href="#cb3-70" aria-hidden="true" tabindex="-1"></a>  <span class="sc">~</span>Name,    <span class="sc">~</span>Mikro, <span class="sc">~</span>Makro, <span class="sc">~</span>Mathe,</span>
<span id="cb3-71"><a href="#cb3-71" aria-hidden="true" tabindex="-1"></a>  <span class="st">"Tim"</span>,        <span class="cn">NA</span>,    <span class="fl">1.3</span>,    <span class="fl">3.0</span>,</span>
<span id="cb3-72"><a href="#cb3-72" aria-hidden="true" tabindex="-1"></a>  <span class="st">"Lena"</span>,      <span class="fl">1.0</span>,    <span class="fl">3.0</span>,     <span class="cn">NA</span>,</span>
<span id="cb3-73"><a href="#cb3-73" aria-hidden="true" tabindex="-1"></a>  <span class="st">"Ricarda"</span>,   <span class="fl">2.0</span>,    <span class="fl">1.7</span>,    <span class="fl">1.3</span>,</span>
<span id="cb3-74"><a href="#cb3-74" aria-hidden="true" tabindex="-1"></a>  <span class="st">"Simon"</span>,     <span class="fl">2.3</span>,    <span class="fl">3.3</span>,     <span class="cn">NA</span></span>
<span id="cb3-75"><a href="#cb3-75" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb3-76"><a href="#cb3-76" aria-hidden="true" tabindex="-1"></a><span class="fu">gt</span>(klausurergebnisse) <span class="sc">%&gt;%</span> </span>
<span id="cb3-77"><a href="#cb3-77" aria-hidden="true" tabindex="-1"></a>  <span class="fu">tabopts</span>()</span>
<span id="cb3-78"><a href="#cb3-78" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-79"><a href="#cb3-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-80"><a href="#cb3-80" aria-hidden="true" tabindex="-1"></a>Der Datensatz ist noch nicht in der R-Arbeitsumgebung verf√ºgbar. Mit der Funktion <span class="in">`tribble()`</span> k√∂nnen wir @tbl-Klausurergebnisse h√§ndisch als R-Objekt der Klasse <span class="in">`tibble`</span> definieren</span>
<span id="cb3-81"><a href="#cb3-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-82"><a href="#cb3-82" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb3-83"><a href="#cb3-83" aria-hidden="true" tabindex="-1"></a><span class="in"># 'klasurergebnisse' als tibble definieren</span></span>
<span id="cb3-84"><a href="#cb3-84" aria-hidden="true" tabindex="-1"></a><span class="in">(</span></span>
<span id="cb3-85"><a href="#cb3-85" aria-hidden="true" tabindex="-1"></a><span class="in">  klausurergebnisse &lt;- tribble(</span></span>
<span id="cb3-86"><a href="#cb3-86" aria-hidden="true" tabindex="-1"></a><span class="in">    ~Name,    ~Mikro, ~Makro, ~Mathe,</span></span>
<span id="cb3-87"><a href="#cb3-87" aria-hidden="true" tabindex="-1"></a><span class="in">    "Tim",        NA,    1.3,    3.0,</span></span>
<span id="cb3-88"><a href="#cb3-88" aria-hidden="true" tabindex="-1"></a><span class="in">    "Lena",      1.0,    3.0,     NA,</span></span>
<span id="cb3-89"><a href="#cb3-89" aria-hidden="true" tabindex="-1"></a><span class="in">    "Ricarda",   2.0,    1.7,    1.3,</span></span>
<span id="cb3-90"><a href="#cb3-90" aria-hidden="true" tabindex="-1"></a><span class="in">    "Simon",     2.3,    3.3,     NA</span></span>
<span id="cb3-91"><a href="#cb3-91" aria-hidden="true" tabindex="-1"></a><span class="in">  )</span></span>
<span id="cb3-92"><a href="#cb3-92" aria-hidden="true" tabindex="-1"></a><span class="in">)</span></span>
<span id="cb3-93"><a href="#cb3-93" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-94"><a href="#cb3-94" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-95"><a href="#cb3-95" aria-hidden="true" tabindex="-1"></a><span class="in">`klausurergebnisse`</span> enh√§lt die Klausurnoten der vier Studierenden (Boebachtungen) spaltenweise *pro Modul*, d.h. die Spaltennamen `Mikro`, `Makro` und `Mathe` sind Auspr√§gungen der Variable *Modul*. Der Datensatz liegt also *nicht* im s.g. *Tidy-Format* vor.</span>
<span id="cb3-96"><a href="#cb3-96" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-97"><a href="#cb3-97" aria-hidden="true" tabindex="-1"></a>::: {.callout-tip}</span>
<span id="cb3-98"><a href="#cb3-98" aria-hidden="true" tabindex="-1"></a><span class="fu">## Tidy-Format</span></span>
<span id="cb3-99"><a href="#cb3-99" aria-hidden="true" tabindex="-1"></a>Tidy-Format: Jede Spalte ist ***eine*** Variable, jede Reihe ist ***eine*** Beobachtung und jede Zelle enth√§lt einen ***einen*** Wert. Datens√§tze im Tidy-Format sind h√§ufig lang: Die Zeilendimension ist gr√∂√üer als die Spaltendimension.</span>
<span id="cb3-100"><a href="#cb3-100" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb3-101"><a href="#cb3-101" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-102"><a href="#cb3-102" aria-hidden="true" tabindex="-1"></a>Das Tidy-Format ist hilfreich f√ºr statistische Analysen mit <span class="in">`tidyverse`</span>-Funktionen wie bspw. <span class="in">`ggplot()`</span>. Wir nutzen die Funktion <span class="in">`tidyr::pivot_longer()`</span>, um <span class="in">`klausurergebnisse`</span> ein (langes) Tidy-Format zu transformieren.</span>
<span id="cb3-103"><a href="#cb3-103" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-104"><a href="#cb3-104" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb3-105"><a href="#cb3-105" aria-hidden="true" tabindex="-1"></a><span class="in"># 'klausurergebnisse' in Tidy-Format √ºberf√ºhren</span></span>
<span id="cb3-106"><a href="#cb3-106" aria-hidden="true" tabindex="-1"></a><span class="in">(</span></span>
<span id="cb3-107"><a href="#cb3-107" aria-hidden="true" tabindex="-1"></a><span class="in">  long &lt;- pivot_longer(</span></span>
<span id="cb3-108"><a href="#cb3-108" aria-hidden="true" tabindex="-1"></a><span class="in">    data = klausurergebnisse, </span></span>
<span id="cb3-109"><a href="#cb3-109" aria-hidden="true" tabindex="-1"></a><span class="in">    cols = Mikro:Mathe, </span></span>
<span id="cb3-110"><a href="#cb3-110" aria-hidden="true" tabindex="-1"></a><span class="in">    names_to = "Modul", </span></span>
<span id="cb3-111"><a href="#cb3-111" aria-hidden="true" tabindex="-1"></a><span class="in">    values_to = "Note"</span></span>
<span id="cb3-112"><a href="#cb3-112" aria-hidden="true" tabindex="-1"></a><span class="in">  )</span></span>
<span id="cb3-113"><a href="#cb3-113" aria-hidden="true" tabindex="-1"></a><span class="in">)</span></span>
<span id="cb3-114"><a href="#cb3-114" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-115"><a href="#cb3-115" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-116"><a href="#cb3-116" aria-hidden="true" tabindex="-1"></a>Beachte, dass die Spalte <span class="in">`Name`</span> die Zugeh√∂rigkeit der Auspr√§gungen (<span class="in">`Note`</span>) jeder Variable (<span class="in">`Modul`</span>) zu einer Beobachtung identifiziert. Mit dieser Information k√∂nnen wir den langen Datensatz wieder in das urspr√ºngliche (weite) Format zur√ºckf√ºhren. Wir nutzen hierzu <span class="in">`tidyr::pivot_wider()`</span>.  </span>
<span id="cb3-117"><a href="#cb3-117" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-118"><a href="#cb3-118" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb3-119"><a href="#cb3-119" aria-hidden="true" tabindex="-1"></a><span class="in"># langes Format in das Ausgangsformat transformieren</span></span>
<span id="cb3-120"><a href="#cb3-120" aria-hidden="true" tabindex="-1"></a><span class="in">(</span></span>
<span id="cb3-121"><a href="#cb3-121" aria-hidden="true" tabindex="-1"></a><span class="in">  wide &lt;- pivot_wider(</span></span>
<span id="cb3-122"><a href="#cb3-122" aria-hidden="true" tabindex="-1"></a><span class="in">    data = long,</span></span>
<span id="cb3-123"><a href="#cb3-123" aria-hidden="true" tabindex="-1"></a><span class="in">    id_cols = "Name",</span></span>
<span id="cb3-124"><a href="#cb3-124" aria-hidden="true" tabindex="-1"></a><span class="in">    names_from = "Modul", </span></span>
<span id="cb3-125"><a href="#cb3-125" aria-hidden="true" tabindex="-1"></a><span class="in">    values_from = "Note"</span></span>
<span id="cb3-126"><a href="#cb3-126" aria-hidden="true" tabindex="-1"></a><span class="in">  )</span></span>
<span id="cb3-127"><a href="#cb3-127" aria-hidden="true" tabindex="-1"></a><span class="in">)</span></span>
<span id="cb3-128"><a href="#cb3-128" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-129"><a href="#cb3-129" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-130"><a href="#cb3-130" aria-hidden="true" tabindex="-1"></a>Wenn die Zuweisung von Zwischenergebnissen in Variablen nicht ben√∂tigt wird, kann eine Verkettung von Funktionsaufrufen die Verst√§ndlichkeit des Codes verbessern. Hierzu wird der <span class="co">[</span><span class="ot">Pipe-Operator</span><span class="co">](https://magrittr.tidyverse.org/reference/pipe.html)</span> <span class="in">`%&gt;%`</span> genutzt. Wir wiederholen die Transformationen mit den <span class="in">`tidyr::pivot_*`</span>-Funktion bei Verwendung von <span class="in">`%&gt;%`</span>.</span>
<span id="cb3-131"><a href="#cb3-131" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-132"><a href="#cb3-132" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb3-133"><a href="#cb3-133" aria-hidden="true" tabindex="-1"></a><span class="in"># langes Format mit %&gt;%</span></span>
<span id="cb3-134"><a href="#cb3-134" aria-hidden="true" tabindex="-1"></a><span class="in">(</span></span>
<span id="cb3-135"><a href="#cb3-135" aria-hidden="true" tabindex="-1"></a><span class="in">  long &lt;- klausurergebnisse %&gt;% </span></span>
<span id="cb3-136"><a href="#cb3-136" aria-hidden="true" tabindex="-1"></a><span class="in">    pivot_longer(</span></span>
<span id="cb3-137"><a href="#cb3-137" aria-hidden="true" tabindex="-1"></a><span class="in">      cols = Mikro:Mathe, </span></span>
<span id="cb3-138"><a href="#cb3-138" aria-hidden="true" tabindex="-1"></a><span class="in">      names_to = "Modul", </span></span>
<span id="cb3-139"><a href="#cb3-139" aria-hidden="true" tabindex="-1"></a><span class="in">      values_to = "Note"</span></span>
<span id="cb3-140"><a href="#cb3-140" aria-hidden="true" tabindex="-1"></a><span class="in">    )</span></span>
<span id="cb3-141"><a href="#cb3-141" aria-hidden="true" tabindex="-1"></a><span class="in">)</span></span>
<span id="cb3-142"><a href="#cb3-142" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-143"><a href="#cb3-143" aria-hidden="true" tabindex="-1"></a><span class="in"># weites Format mit %&gt;%</span></span>
<span id="cb3-144"><a href="#cb3-144" aria-hidden="true" tabindex="-1"></a><span class="in">(</span></span>
<span id="cb3-145"><a href="#cb3-145" aria-hidden="true" tabindex="-1"></a><span class="in">  wide &lt;- long %&gt;% </span></span>
<span id="cb3-146"><a href="#cb3-146" aria-hidden="true" tabindex="-1"></a><span class="in">    pivot_wider(</span></span>
<span id="cb3-147"><a href="#cb3-147" aria-hidden="true" tabindex="-1"></a><span class="in">      id_cols = "Name",</span></span>
<span id="cb3-148"><a href="#cb3-148" aria-hidden="true" tabindex="-1"></a><span class="in">      names_from = "Modul", </span></span>
<span id="cb3-149"><a href="#cb3-149" aria-hidden="true" tabindex="-1"></a><span class="in">      values_from = "Note"</span></span>
<span id="cb3-150"><a href="#cb3-150" aria-hidden="true" tabindex="-1"></a><span class="in">    )</span></span>
<span id="cb3-151"><a href="#cb3-151" aria-hidden="true" tabindex="-1"></a><span class="in">)</span></span>
<span id="cb3-152"><a href="#cb3-152" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-153"><a href="#cb3-153" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-154"><a href="#cb3-154" aria-hidden="true" tabindex="-1"></a>Ein Beispiel f√ºr den Nachteil des weiten Formats im Umgang mit <span class="in">`tidyverse`</span>-Paketen ist die Funktion <span class="in">`tidyr::drop_na()`</span>. Diese entfernt s√§mtliche *Zeilen* eines Datensatzes, die <span class="in">`NA`</span>-Eintr√§ge (d.h. fehlende Werte) aufweisen. Beachte, dass diese Operation im urspr√ºnglichen weiten Format zum Entfernen ganzer Beobachtungen aus <span class="in">`wide`</span> f√ºhrt.</span>
<span id="cb3-155"><a href="#cb3-155" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-156"><a href="#cb3-156" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb3-157"><a href="#cb3-157" aria-hidden="true" tabindex="-1"></a><span class="in"># NA-Eintr√§ge aus dem "weiten" Format entfernen</span></span>
<span id="cb3-158"><a href="#cb3-158" aria-hidden="true" tabindex="-1"></a><span class="in">wide %&gt;% </span></span>
<span id="cb3-159"><a href="#cb3-159" aria-hidden="true" tabindex="-1"></a><span class="in">  drop_na()</span></span>
<span id="cb3-160"><a href="#cb3-160" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-161"><a href="#cb3-161" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-162"><a href="#cb3-162" aria-hidden="true" tabindex="-1"></a>Im Tidy-Format <span class="in">`long`</span> hingegen bleiben die √ºbrigen Informationen betroffener Beobachtungen erhalten.</span>
<span id="cb3-163"><a href="#cb3-163" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-164"><a href="#cb3-164" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb3-165"><a href="#cb3-165" aria-hidden="true" tabindex="-1"></a><span class="in"># NA-Eintr√§ge aus dem "langen" Format entfernen</span></span>
<span id="cb3-166"><a href="#cb3-166" aria-hidden="true" tabindex="-1"></a><span class="in">long %&gt;% </span></span>
<span id="cb3-167"><a href="#cb3-167" aria-hidden="true" tabindex="-1"></a><span class="in">  drop_na()</span></span>
<span id="cb3-168"><a href="#cb3-168" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-169"><a href="#cb3-169" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-170"><a href="#cb3-170" aria-hidden="true" tabindex="-1"></a><span class="fu">## Pinguine und Pipes</span></span>
<span id="cb3-171"><a href="#cb3-171" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-172"><a href="#cb3-172" aria-hidden="true" tabindex="-1"></a>In diesem Abschnitt zeigen wir die Verwendung h√§ufig verwendeter <span class="in">`dplyr`</span>-Funktionen (s.g. *Verben*) f√ºr die Transformation von Datens√§tzen: <span class="in">`mutate()`</span>, <span class="in">`select()`</span>, <span class="in">`filter()`</span>,<span class="in">` summarise()`</span> und <span class="in">`arrange()`</span>.</span>
<span id="cb3-173"><a href="#cb3-173" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-174"><a href="#cb3-174" aria-hidden="true" tabindex="-1"></a>F√ºr die Illustration verwenden wir den Datensatz <span class="in">`penguins`</span> aus dem R-Paket <span class="in">`palmerpenguins`</span>. Dieser Datensatz wurde im Zeitraum 2007 bis 2009 von Dr. Kristen Gorman im Rahmen des *Palmer Station Long Term Ecological Research Program* zusammengetragen und enth√§lt Gr√∂√üenmessungen f√ºr drei Pinguinarten, die auf den Inseln des <span class="co">[</span><span class="ot">Palmer-Archipels</span><span class="co">](https://en.wikipedia.org/wiki/Palmer_Archipelago)</span> in der Antarktis beobachtet wurden.</span>
<span id="cb3-175"><a href="#cb3-175" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-178"><a href="#cb3-178" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb3-179"><a href="#cb3-179" aria-hidden="true" tabindex="-1"></a><span class="co"># Paket 'palmerpenguins' installieren</span></span>
<span id="cb3-180"><a href="#cb3-180" aria-hidden="true" tabindex="-1"></a><span class="co"># install.packages("palmerpenguins")</span></span>
<span id="cb3-181"><a href="#cb3-181" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-182"><a href="#cb3-182" aria-hidden="true" tabindex="-1"></a><span class="co"># Paket 'palmerpenguins' laden</span></span>
<span id="cb3-183"><a href="#cb3-183" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(palmerpenguins)</span>
<span id="cb3-184"><a href="#cb3-184" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-185"><a href="#cb3-185" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-186"><a href="#cb3-186" aria-hidden="true" tabindex="-1"></a>Mit <span class="in">`data()`</span> wird der Datensatz in der Arbeitsumgebung verf√ºgbar gemacht. Wir nutzen <span class="in">`glimpse()`</span>, um einen √úberblick zu erhalten.</span>
<span id="cb3-187"><a href="#cb3-187" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-188"><a href="#cb3-188" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb3-189"><a href="#cb3-189" aria-hidden="true" tabindex="-1"></a><span class="in"># Datensatz in der Arbeitsumgebung verf√ºgbar machen</span></span>
<span id="cb3-190"><a href="#cb3-190" aria-hidden="true" tabindex="-1"></a><span class="in">data(penguins)</span></span>
<span id="cb3-191"><a href="#cb3-191" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-192"><a href="#cb3-192" aria-hidden="true" tabindex="-1"></a><span class="in"># √úbersicht anzeigen lassen</span></span>
<span id="cb3-193"><a href="#cb3-193" aria-hidden="true" tabindex="-1"></a><span class="in">glimpse(penguins)</span></span>
<span id="cb3-194"><a href="#cb3-194" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-195"><a href="#cb3-195" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-196"><a href="#cb3-196" aria-hidden="true" tabindex="-1"></a><span class="fu">### `dplyr::mutate()`</span></span>
<span id="cb3-197"><a href="#cb3-197" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-198"><a href="#cb3-198" aria-hidden="true" tabindex="-1"></a>Mit <span class="in">`mutate()`</span> k√∂nnen bestehende Variablen √ºberschrieben oder neue Variablen als Funktion bestehender Variablen definiert werden. <span class="in">`mutate()`</span> operiert in der Spaltendimension des Datensatz. </span>
<span id="cb3-199"><a href="#cb3-199" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-200"><a href="#cb3-200" aria-hidden="true" tabindex="-1"></a>Wir definieren eine neue Variable <span class="in">`body_mass_kg`</span> als Transformation <span class="in">`body_mass_g/1000`</span>.</span>
<span id="cb3-201"><a href="#cb3-201" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-202"><a href="#cb3-202" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb3-203"><a href="#cb3-203" aria-hidden="true" tabindex="-1"></a><span class="in"># Neue Variable mit Gewicht in Kg definieren</span></span>
<span id="cb3-204"><a href="#cb3-204" aria-hidden="true" tabindex="-1"></a><span class="in">penguins %&gt;% </span></span>
<span id="cb3-205"><a href="#cb3-205" aria-hidden="true" tabindex="-1"></a><span class="in">  mutate(</span></span>
<span id="cb3-206"><a href="#cb3-206" aria-hidden="true" tabindex="-1"></a><span class="in">    body_mass_kg = body_mass_g/1000</span></span>
<span id="cb3-207"><a href="#cb3-207" aria-hidden="true" tabindex="-1"></a><span class="in">  ) %&gt;%</span></span>
<span id="cb3-208"><a href="#cb3-208" aria-hidden="true" tabindex="-1"></a><span class="in">  glimpse()</span></span>
<span id="cb3-209"><a href="#cb3-209" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-210"><a href="#cb3-210" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-211"><a href="#cb3-211" aria-hidden="true" tabindex="-1"></a>Mit <span class="in">`across()`</span> kann die dieselbe Operation auf mehrere Variablen angewendet werden. </span>
<span id="cb3-212"><a href="#cb3-212" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-213"><a href="#cb3-213" aria-hidden="true" tabindex="-1"></a>Im nachstehenden Beispiel √§ndern wir den typ (<span class="in">`type`</span>) der Variablen <span class="in">`species`</span>, <span class="in">`island`</span>, <span class="in">`sex`</span> und <span class="in">`year`</span> zu <span class="in">`character`</span>. </span>
<span id="cb3-214"><a href="#cb3-214" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-215"><a href="#cb3-215" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb3-216"><a href="#cb3-216" aria-hidden="true" tabindex="-1"></a><span class="in"># species, island, sex und year in Typ 'character' umwandeln</span></span>
<span id="cb3-217"><a href="#cb3-217" aria-hidden="true" tabindex="-1"></a><span class="in">penguins %&gt;% </span></span>
<span id="cb3-218"><a href="#cb3-218" aria-hidden="true" tabindex="-1"></a><span class="in">  mutate(</span></span>
<span id="cb3-219"><a href="#cb3-219" aria-hidden="true" tabindex="-1"></a><span class="in">    across(</span></span>
<span id="cb3-220"><a href="#cb3-220" aria-hidden="true" tabindex="-1"></a><span class="in">      c(species, island, sex, year), </span></span>
<span id="cb3-221"><a href="#cb3-221" aria-hidden="true" tabindex="-1"></a><span class="in">      .fns = as.character</span></span>
<span id="cb3-222"><a href="#cb3-222" aria-hidden="true" tabindex="-1"></a><span class="in">    )</span></span>
<span id="cb3-223"><a href="#cb3-223" aria-hidden="true" tabindex="-1"></a><span class="in">  ) %&gt;%</span></span>
<span id="cb3-224"><a href="#cb3-224" aria-hidden="true" tabindex="-1"></a><span class="in">  glimpse()</span></span>
<span id="cb3-225"><a href="#cb3-225" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-226"><a href="#cb3-226" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-227"><a href="#cb3-227" aria-hidden="true" tabindex="-1"></a><span class="in">`transmute()`</span> ist eine Variante von <span class="in">`mutate()`</span>, die lediglich die transformierten Variablen beibeh√§lt.</span>
<span id="cb3-228"><a href="#cb3-228" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-229"><a href="#cb3-229" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb3-230"><a href="#cb3-230" aria-hidden="true" tabindex="-1"></a><span class="in"># Nur transformierte Variablen behalten</span></span>
<span id="cb3-231"><a href="#cb3-231" aria-hidden="true" tabindex="-1"></a><span class="in">penguins %&gt;% </span></span>
<span id="cb3-232"><a href="#cb3-232" aria-hidden="true" tabindex="-1"></a><span class="in">  transmute(</span></span>
<span id="cb3-233"><a href="#cb3-233" aria-hidden="true" tabindex="-1"></a><span class="in">    body_mass_kg = body_mass_g/1000</span></span>
<span id="cb3-234"><a href="#cb3-234" aria-hidden="true" tabindex="-1"></a><span class="in">  )</span></span>
<span id="cb3-235"><a href="#cb3-235" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-236"><a href="#cb3-236" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-237"><a href="#cb3-237" aria-hidden="true" tabindex="-1"></a><span class="fu">### `dplyr::select()`</span></span>
<span id="cb3-238"><a href="#cb3-238" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-239"><a href="#cb3-239" aria-hidden="true" tabindex="-1"></a>Mit <span class="in">`select()`</span> werden Variablen aus dem Datensatz ausgew√§hlt. Dies geschieht entweder √ºber den Variablennamen...</span>
<span id="cb3-240"><a href="#cb3-240" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-241"><a href="#cb3-241" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb3-242"><a href="#cb3-242" aria-hidden="true" tabindex="-1"></a><span class="in"># 'species' ausw√§hlen</span></span>
<span id="cb3-243"><a href="#cb3-243" aria-hidden="true" tabindex="-1"></a><span class="in">penguins %&gt;% </span></span>
<span id="cb3-244"><a href="#cb3-244" aria-hidden="true" tabindex="-1"></a><span class="in">  select(species)</span></span>
<span id="cb3-245"><a href="#cb3-245" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-246"><a href="#cb3-246" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-247"><a href="#cb3-247" aria-hidden="true" tabindex="-1"></a>... oder √ºber eine Indexmenge.^<span class="co">[</span><span class="ot">Hilfreich: `dplyr::pull()` selektiert eine Variable und wandelt diese in einen Vektor um.</span><span class="co">]</span></span>
<span id="cb3-248"><a href="#cb3-248" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-249"><a href="#cb3-249" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb3-250"><a href="#cb3-250" aria-hidden="true" tabindex="-1"></a><span class="in"># Teilmenge von Variablen per Index ausw√§hlen</span></span>
<span id="cb3-251"><a href="#cb3-251" aria-hidden="true" tabindex="-1"></a><span class="in">penguins %&gt;% </span></span>
<span id="cb3-252"><a href="#cb3-252" aria-hidden="true" tabindex="-1"></a><span class="in">  select(</span></span>
<span id="cb3-253"><a href="#cb3-253" aria-hidden="true" tabindex="-1"></a><span class="in">    c(1, 2, 3)</span></span>
<span id="cb3-254"><a href="#cb3-254" aria-hidden="true" tabindex="-1"></a><span class="in">  )</span></span>
<span id="cb3-255"><a href="#cb3-255" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-256"><a href="#cb3-256" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-257"><a href="#cb3-257" aria-hidden="true" tabindex="-1"></a>Variablen k√∂nnen anhand eines Muster im Namen selektiert werden. Die Selektion von <span class="in">`ends_with("mm")`</span> bezieht nur Variablen mit Endung <span class="in">`mm`</span> im Namen ein:</span>
<span id="cb3-258"><a href="#cb3-258" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-259"><a href="#cb3-259" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb3-260"><a href="#cb3-260" aria-hidden="true" tabindex="-1"></a><span class="in"># Nur in mm gemessene Variablen auslesen</span></span>
<span id="cb3-261"><a href="#cb3-261" aria-hidden="true" tabindex="-1"></a><span class="in">penguins %&gt;% </span></span>
<span id="cb3-262"><a href="#cb3-262" aria-hidden="true" tabindex="-1"></a><span class="in">  select(</span></span>
<span id="cb3-263"><a href="#cb3-263" aria-hidden="true" tabindex="-1"></a><span class="in">    ends_with("mm")</span></span>
<span id="cb3-264"><a href="#cb3-264" aria-hidden="true" tabindex="-1"></a><span class="in">  )</span></span>
<span id="cb3-265"><a href="#cb3-265" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-266"><a href="#cb3-266" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-267"><a href="#cb3-267" aria-hidden="true" tabindex="-1"></a>Mit <span class="in">`where()`</span> k√∂nnen wir Variablen aufgrund bestimmter Eigenschaften ihrer Auspr√§gungen selektieren. </span>
<span id="cb3-268"><a href="#cb3-268" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-269"><a href="#cb3-269" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb3-270"><a href="#cb3-270" aria-hidden="true" tabindex="-1"></a><span class="in"># Nur numerische Variablen ausw√§hlen</span></span>
<span id="cb3-271"><a href="#cb3-271" aria-hidden="true" tabindex="-1"></a><span class="in">penguins %&gt;% </span></span>
<span id="cb3-272"><a href="#cb3-272" aria-hidden="true" tabindex="-1"></a><span class="in">  select(</span></span>
<span id="cb3-273"><a href="#cb3-273" aria-hidden="true" tabindex="-1"></a><span class="in">    where(is.numeric)</span></span>
<span id="cb3-274"><a href="#cb3-274" aria-hidden="true" tabindex="-1"></a><span class="in">  )</span></span>
<span id="cb3-275"><a href="#cb3-275" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-276"><a href="#cb3-276" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-277"><a href="#cb3-277" aria-hidden="true" tabindex="-1"></a><span class="fu">### `dplyr::filter()`</span></span>
<span id="cb3-278"><a href="#cb3-278" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-279"><a href="#cb3-279" aria-hidden="true" tabindex="-1"></a>Das Verb <span class="in">`filter()`</span> filtert den Datensatz in der Zeilendimension. So k√∂nnen Beobachtungen ausgew√§lt werden, deren Merkmalsauspr√§gungen bestimmte Kriterien erf√ºllen. Hierzu muss <span class="in">`filter()`</span> ein logischer (<span class="in">`logical`</span>) Ausdruck √ºbergeben werden. H√§ufig erfolgt dies √ºber Vergleichsoperatoren.</span>
<span id="cb3-280"><a href="#cb3-280" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-281"><a href="#cb3-281" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb3-282"><a href="#cb3-282" aria-hidden="true" tabindex="-1"></a><span class="in"># Nur Pinguine mit bill_length_mm &gt;= 39</span></span>
<span id="cb3-283"><a href="#cb3-283" aria-hidden="true" tabindex="-1"></a><span class="in">penguins %&gt;% </span></span>
<span id="cb3-284"><a href="#cb3-284" aria-hidden="true" tabindex="-1"></a><span class="in">  filter(</span></span>
<span id="cb3-285"><a href="#cb3-285" aria-hidden="true" tabindex="-1"></a><span class="in">    bill_length_mm &gt;= 39</span></span>
<span id="cb3-286"><a href="#cb3-286" aria-hidden="true" tabindex="-1"></a><span class="in">  )</span></span>
<span id="cb3-287"><a href="#cb3-287" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-288"><a href="#cb3-288" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-289"><a href="#cb3-289" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb3-290"><a href="#cb3-290" aria-hidden="true" tabindex="-1"></a><span class="in"># Nur Pinguine mit bill_length_mm &lt;= 40</span></span>
<span id="cb3-291"><a href="#cb3-291" aria-hidden="true" tabindex="-1"></a><span class="in">penguins %&gt;% </span></span>
<span id="cb3-292"><a href="#cb3-292" aria-hidden="true" tabindex="-1"></a><span class="in">  filter(</span></span>
<span id="cb3-293"><a href="#cb3-293" aria-hidden="true" tabindex="-1"></a><span class="in">    bill_length_mm &lt;= 40</span></span>
<span id="cb3-294"><a href="#cb3-294" aria-hidden="true" tabindex="-1"></a><span class="in">  )</span></span>
<span id="cb3-295"><a href="#cb3-295" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-296"><a href="#cb3-296" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-297"><a href="#cb3-297" aria-hidden="true" tabindex="-1"></a>Oft ist es praktisch, mehrere Kriterien zu kombinieren.</span>
<span id="cb3-298"><a href="#cb3-298" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-299"><a href="#cb3-299" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb3-300"><a href="#cb3-300" aria-hidden="true" tabindex="-1"></a><span class="in"># Kombinierter Filter -- Variante 1</span></span>
<span id="cb3-301"><a href="#cb3-301" aria-hidden="true" tabindex="-1"></a><span class="in">penguins %&gt;% </span></span>
<span id="cb3-302"><a href="#cb3-302" aria-hidden="true" tabindex="-1"></a><span class="in">  filter(</span></span>
<span id="cb3-303"><a href="#cb3-303" aria-hidden="true" tabindex="-1"></a><span class="in">    bill_length_mm &gt;= 39 &amp; bill_length_mm &lt;= 40</span></span>
<span id="cb3-304"><a href="#cb3-304" aria-hidden="true" tabindex="-1"></a><span class="in">  )</span></span>
<span id="cb3-305"><a href="#cb3-305" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-306"><a href="#cb3-306" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-307"><a href="#cb3-307" aria-hidden="true" tabindex="-1"></a>Analog: komma-getrennte Kriterien werden intern √ºber den Und-Operator (<span class="in">`&amp;`</span>) verkn√ºpft.</span>
<span id="cb3-308"><a href="#cb3-308" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-309"><a href="#cb3-309" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb3-310"><a href="#cb3-310" aria-hidden="true" tabindex="-1"></a><span class="in"># Kombinierter Filter -- Variante 2</span></span>
<span id="cb3-311"><a href="#cb3-311" aria-hidden="true" tabindex="-1"></a><span class="in">penguins %&gt;% </span></span>
<span id="cb3-312"><a href="#cb3-312" aria-hidden="true" tabindex="-1"></a><span class="in">  filter(</span></span>
<span id="cb3-313"><a href="#cb3-313" aria-hidden="true" tabindex="-1"></a><span class="in">    bill_length_mm &gt;= 39, </span></span>
<span id="cb3-314"><a href="#cb3-314" aria-hidden="true" tabindex="-1"></a><span class="in">    bill_length_mm &lt;= 40</span></span>
<span id="cb3-315"><a href="#cb3-315" aria-hidden="true" tabindex="-1"></a><span class="in">  )</span></span>
<span id="cb3-316"><a href="#cb3-316" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-317"><a href="#cb3-317" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-318"><a href="#cb3-318" aria-hidden="true" tabindex="-1"></a>√Ñhnlich wie bei <span class="in">`select()`</span> verwenden wir h√§ufig n√ºtzliche Funktionen, welche die Interpretation des Codes erleichtern. <span class="in">`dplyr::between()`</span> erlaubt filtern innerhalb eines Intervals.</span>
<span id="cb3-319"><a href="#cb3-319" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-320"><a href="#cb3-320" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb3-321"><a href="#cb3-321" aria-hidden="true" tabindex="-1"></a><span class="in"># Filtern mit Hilfsfunktion</span></span>
<span id="cb3-322"><a href="#cb3-322" aria-hidden="true" tabindex="-1"></a><span class="in">penguins %&gt;% </span></span>
<span id="cb3-323"><a href="#cb3-323" aria-hidden="true" tabindex="-1"></a><span class="in">  filter(</span></span>
<span id="cb3-324"><a href="#cb3-324" aria-hidden="true" tabindex="-1"></a><span class="in">    between(</span></span>
<span id="cb3-325"><a href="#cb3-325" aria-hidden="true" tabindex="-1"></a><span class="in">      bill_length_mm, left = 39, right = 40</span></span>
<span id="cb3-326"><a href="#cb3-326" aria-hidden="true" tabindex="-1"></a><span class="in">    )</span></span>
<span id="cb3-327"><a href="#cb3-327" aria-hidden="true" tabindex="-1"></a><span class="in">  )</span></span>
<span id="cb3-328"><a href="#cb3-328" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-329"><a href="#cb3-329" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-330"><a href="#cb3-330" aria-hidden="true" tabindex="-1"></a>Mit diesen Verben sind wir bereits in der Lage, den Datensatz gem√§√ü folgender Vorschrift zu bereinigen: </span>
<span id="cb3-331"><a href="#cb3-331" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-332"><a href="#cb3-332" aria-hidden="true" tabindex="-1"></a><span class="ss">  1. </span>Entfernen der Ma√üeinheiten aus den Variablennamen</span>
<span id="cb3-333"><a href="#cb3-333" aria-hidden="true" tabindex="-1"></a><span class="ss">  2. </span>Entfernen von Pinguinen mit fehlenden Werten (<span class="in">`NA`</span>)</span>
<span id="cb3-334"><a href="#cb3-334" aria-hidden="true" tabindex="-1"></a><span class="ss">  3. </span>Entfernen von Pinguinen mit einem Gewicht *oberhalb* des 95\%-Stichprobenquantils</span>
<span id="cb3-335"><a href="#cb3-335" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-336"><a href="#cb3-336" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb3-337"><a href="#cb3-337" aria-hidden="true" tabindex="-1"></a><span class="in"># Schritt 1</span></span>
<span id="cb3-338"><a href="#cb3-338" aria-hidden="true" tabindex="-1"></a><span class="in">(</span></span>
<span id="cb3-339"><a href="#cb3-339" aria-hidden="true" tabindex="-1"></a><span class="in">  penguins_cleaned &lt;- penguins %&gt;% </span></span>
<span id="cb3-340"><a href="#cb3-340" aria-hidden="true" tabindex="-1"></a><span class="in">    rename(</span></span>
<span id="cb3-341"><a href="#cb3-341" aria-hidden="true" tabindex="-1"></a><span class="in">      bill_length = bill_length_mm,</span></span>
<span id="cb3-342"><a href="#cb3-342" aria-hidden="true" tabindex="-1"></a><span class="in">      bill_depth  = bill_depth_mm,</span></span>
<span id="cb3-343"><a href="#cb3-343" aria-hidden="true" tabindex="-1"></a><span class="in">      flipper_length = flipper_length_mm,</span></span>
<span id="cb3-344"><a href="#cb3-344" aria-hidden="true" tabindex="-1"></a><span class="in">      body_mass = body_mass_g</span></span>
<span id="cb3-345"><a href="#cb3-345" aria-hidden="true" tabindex="-1"></a><span class="in">    )</span></span>
<span id="cb3-346"><a href="#cb3-346" aria-hidden="true" tabindex="-1"></a><span class="in">)</span></span>
<span id="cb3-347"><a href="#cb3-347" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-348"><a href="#cb3-348" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-349"><a href="#cb3-349" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb3-350"><a href="#cb3-350" aria-hidden="true" tabindex="-1"></a><span class="in"># Schritt 2</span></span>
<span id="cb3-351"><a href="#cb3-351" aria-hidden="true" tabindex="-1"></a><span class="in">(</span></span>
<span id="cb3-352"><a href="#cb3-352" aria-hidden="true" tabindex="-1"></a><span class="in">  penguins_cleaned &lt;- penguins_cleaned %&gt;%</span></span>
<span id="cb3-353"><a href="#cb3-353" aria-hidden="true" tabindex="-1"></a><span class="in">    drop_na()</span></span>
<span id="cb3-354"><a href="#cb3-354" aria-hidden="true" tabindex="-1"></a><span class="in">)</span></span>
<span id="cb3-355"><a href="#cb3-355" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-356"><a href="#cb3-356" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-357"><a href="#cb3-357" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb3-358"><a href="#cb3-358" aria-hidden="true" tabindex="-1"></a><span class="in"># Schritt 3</span></span>
<span id="cb3-359"><a href="#cb3-359" aria-hidden="true" tabindex="-1"></a><span class="in">penguins_cleaned %&gt;% </span></span>
<span id="cb3-360"><a href="#cb3-360" aria-hidden="true" tabindex="-1"></a><span class="in">  filter(</span></span>
<span id="cb3-361"><a href="#cb3-361" aria-hidden="true" tabindex="-1"></a><span class="in">    body_mass &lt; quantile(body_mass, probs = .95)</span></span>
<span id="cb3-362"><a href="#cb3-362" aria-hidden="true" tabindex="-1"></a><span class="in">  ) %&gt;%</span></span>
<span id="cb3-363"><a href="#cb3-363" aria-hidden="true" tabindex="-1"></a><span class="in">  glimpse()</span></span>
<span id="cb3-364"><a href="#cb3-364" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-365"><a href="#cb3-365" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-366"><a href="#cb3-366" aria-hidden="true" tabindex="-1"></a>Durch die Verkettung mit <span class="in">`%&gt;%`</span> k√∂nnen wir s√§mtliche Schritte f√ºr die Bereinigung ohne das Abspeichern von Zwischenergebnissen durchf√ºhren.</span>
<span id="cb3-367"><a href="#cb3-367" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-368"><a href="#cb3-368" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb3-369"><a href="#cb3-369" aria-hidden="true" tabindex="-1"></a><span class="in"># Verketter Funktionsaufruf f√ºr Datensatzbereinigung</span></span>
<span id="cb3-370"><a href="#cb3-370" aria-hidden="true" tabindex="-1"></a><span class="in">penguins_cleaned &lt;- penguins %&gt;% </span></span>
<span id="cb3-371"><a href="#cb3-371" aria-hidden="true" tabindex="-1"></a><span class="in">  rename(</span></span>
<span id="cb3-372"><a href="#cb3-372" aria-hidden="true" tabindex="-1"></a><span class="in">    bill_length = bill_length_mm,</span></span>
<span id="cb3-373"><a href="#cb3-373" aria-hidden="true" tabindex="-1"></a><span class="in">    bill_depth  = bill_depth_mm,</span></span>
<span id="cb3-374"><a href="#cb3-374" aria-hidden="true" tabindex="-1"></a><span class="in">    flipper_length = flipper_length_mm,</span></span>
<span id="cb3-375"><a href="#cb3-375" aria-hidden="true" tabindex="-1"></a><span class="in">    body_mass = body_mass_g</span></span>
<span id="cb3-376"><a href="#cb3-376" aria-hidden="true" tabindex="-1"></a><span class="in">  ) %&gt;% </span></span>
<span id="cb3-377"><a href="#cb3-377" aria-hidden="true" tabindex="-1"></a><span class="in">  drop_na() %&gt;% </span></span>
<span id="cb3-378"><a href="#cb3-378" aria-hidden="true" tabindex="-1"></a><span class="in">  filter(</span></span>
<span id="cb3-379"><a href="#cb3-379" aria-hidden="true" tabindex="-1"></a><span class="in">    body_mass &lt; quantile(body_mass, .95)</span></span>
<span id="cb3-380"><a href="#cb3-380" aria-hidden="true" tabindex="-1"></a><span class="in">  )</span></span>
<span id="cb3-381"><a href="#cb3-381" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-382"><a href="#cb3-382" aria-hidden="true" tabindex="-1"></a><span class="in">penguins_cleaned %&gt;% </span></span>
<span id="cb3-383"><a href="#cb3-383" aria-hidden="true" tabindex="-1"></a><span class="in">  glimpse()</span></span>
<span id="cb3-384"><a href="#cb3-384" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-385"><a href="#cb3-385" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-386"><a href="#cb3-386" aria-hidden="true" tabindex="-1"></a><span class="fu">### `dplyr::summarise()`</span></span>
<span id="cb3-387"><a href="#cb3-387" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-388"><a href="#cb3-388" aria-hidden="true" tabindex="-1"></a>Das Verb <span class="in">`summarise()`</span> fasst Variablen √ºber Beobachtungen hinweg zusammen. Der nachstehende Code-Chunk erzeugt eine Tabelle mit Stichprobenmittelwert und -standardabweichung von <span class="in">`flipper_length_mm`</span>.^<span class="co">[</span><span class="ot">`dplyr::summarise()` darf nicht mit `base::summary()` verwechselt werden!</span><span class="co">]</span> Um zu vermeiden, dass die Auswertung aufgrund fehlender Werte (<span class="in">`NA`</span>) in <span class="in">`flipper_length_mm`</span> scheitert, lassen wir <span class="in">`NA`</span>s mit <span class="in">`na.rm = TRUE`</span> bei der Berechnung unber√ºcksichtigt (wir verwenden weiterhin den unbereinigten Datensatz <span class="in">`penguins`</span>).</span>
<span id="cb3-389"><a href="#cb3-389" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-390"><a href="#cb3-390" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb3-391"><a href="#cb3-391" aria-hidden="true" tabindex="-1"></a><span class="in"># statistische Zusammenfassung mit 'summarise()'</span></span>
<span id="cb3-392"><a href="#cb3-392" aria-hidden="true" tabindex="-1"></a><span class="in">penguins %&gt;% </span></span>
<span id="cb3-393"><a href="#cb3-393" aria-hidden="true" tabindex="-1"></a><span class="in">  select(flipper_length_mm) %&gt;% </span></span>
<span id="cb3-394"><a href="#cb3-394" aria-hidden="true" tabindex="-1"></a><span class="in">  summarise(</span></span>
<span id="cb3-395"><a href="#cb3-395" aria-hidden="true" tabindex="-1"></a><span class="in">    mean = mean(flipper_length_mm, na.rm = TRUE), </span></span>
<span id="cb3-396"><a href="#cb3-396" aria-hidden="true" tabindex="-1"></a><span class="in">    sd = sd(flipper_length_mm, na.rm = TRUE)</span></span>
<span id="cb3-397"><a href="#cb3-397" aria-hidden="true" tabindex="-1"></a><span class="in">  )</span></span>
<span id="cb3-398"><a href="#cb3-398" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-399"><a href="#cb3-399" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-400"><a href="#cb3-400" aria-hidden="true" tabindex="-1"></a>Varianten von <span class="in">`summarise()`</span> k√∂nnen √ºber mehrere Variablen angewendet werden. Wir verwenden <span class="in">`across()`</span> und <span class="in">`where()`</span>, um lediglich numerische Variablen mit den in der liste definierten Funktionen zusammenzufassen. Beachte, dass <span class="in">`\(x) mean(x)`</span> eine anonyme Funktion definiert.</span>
<span id="cb3-401"><a href="#cb3-401" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-402"><a href="#cb3-402" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb3-403"><a href="#cb3-403" aria-hidden="true" tabindex="-1"></a><span class="in">penguins %&gt;% </span></span>
<span id="cb3-404"><a href="#cb3-404" aria-hidden="true" tabindex="-1"></a><span class="in">  summarise(</span></span>
<span id="cb3-405"><a href="#cb3-405" aria-hidden="true" tabindex="-1"></a><span class="in">    across(</span></span>
<span id="cb3-406"><a href="#cb3-406" aria-hidden="true" tabindex="-1"></a><span class="in">      where(is.numeric), </span></span>
<span id="cb3-407"><a href="#cb3-407" aria-hidden="true" tabindex="-1"></a><span class="in">      .fns = list(</span></span>
<span id="cb3-408"><a href="#cb3-408" aria-hidden="true" tabindex="-1"></a><span class="in">        mean = \(x) mean(x, na.rm = TRUE), </span></span>
<span id="cb3-409"><a href="#cb3-409" aria-hidden="true" tabindex="-1"></a><span class="in">        sd = \(x) sd(x, na.rm = TRUE)</span></span>
<span id="cb3-410"><a href="#cb3-410" aria-hidden="true" tabindex="-1"></a><span class="in">      )</span></span>
<span id="cb3-411"><a href="#cb3-411" aria-hidden="true" tabindex="-1"></a><span class="in">    )</span></span>
<span id="cb3-412"><a href="#cb3-412" aria-hidden="true" tabindex="-1"></a><span class="in">  ) %&gt;%</span></span>
<span id="cb3-413"><a href="#cb3-413" aria-hidden="true" tabindex="-1"></a><span class="in">  glimpse()</span></span>
<span id="cb3-414"><a href="#cb3-414" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-415"><a href="#cb3-415" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-416"><a href="#cb3-416" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-417"><a href="#cb3-417" aria-hidden="true" tabindex="-1"></a><span class="fu">### `dplyr::arrange()`</span></span>
<span id="cb3-418"><a href="#cb3-418" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-419"><a href="#cb3-419" aria-hidden="true" tabindex="-1"></a>Mit <span class="in">`arrange()`</span> k√∂nnen Datens√§tze in Abh√§ngigkeit der beobachteten Auspr√§gungen von Variablen sortiert werden.</span>
<span id="cb3-420"><a href="#cb3-420" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-421"><a href="#cb3-421" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb3-422"><a href="#cb3-422" aria-hidden="true" tabindex="-1"></a><span class="in"># Datensatz aufsteigend nach 'body_mass_g' sortieren</span></span>
<span id="cb3-423"><a href="#cb3-423" aria-hidden="true" tabindex="-1"></a><span class="in">penguins %&gt;% </span></span>
<span id="cb3-424"><a href="#cb3-424" aria-hidden="true" tabindex="-1"></a><span class="in">  arrange(body_mass_g)</span></span>
<span id="cb3-425"><a href="#cb3-425" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-426"><a href="#cb3-426" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-427"><a href="#cb3-427" aria-hidden="true" tabindex="-1"></a>Die Funktion <span class="in">`dplyr::desc()`</span> kehrt die Reihenfolge zu einer absteigenden Sortierung um.</span>
<span id="cb3-428"><a href="#cb3-428" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-429"><a href="#cb3-429" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb3-430"><a href="#cb3-430" aria-hidden="true" tabindex="-1"></a><span class="in"># Absteigende Sortierung nach 'body_mass_g'</span></span>
<span id="cb3-431"><a href="#cb3-431" aria-hidden="true" tabindex="-1"></a><span class="in">penguins %&gt;% </span></span>
<span id="cb3-432"><a href="#cb3-432" aria-hidden="true" tabindex="-1"></a><span class="in">  arrange(</span></span>
<span id="cb3-433"><a href="#cb3-433" aria-hidden="true" tabindex="-1"></a><span class="in">    desc(body_mass_g)</span></span>
<span id="cb3-434"><a href="#cb3-434" aria-hidden="true" tabindex="-1"></a><span class="in">  )</span></span>
<span id="cb3-435"><a href="#cb3-435" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-436"><a href="#cb3-436" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-437"><a href="#cb3-437" aria-hidden="true" tabindex="-1"></a>Komplexe Sortier-Muster werden durch √úbergabe von Variablennamen in der gew√ºnschten Reihenfolge erreicht.</span>
<span id="cb3-438"><a href="#cb3-438" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-439"><a href="#cb3-439" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb3-440"><a href="#cb3-440" aria-hidden="true" tabindex="-1"></a><span class="in"># Erst Sortierung nach 'sex', dann gruppenweise absteigend </span></span>
<span id="cb3-441"><a href="#cb3-441" aria-hidden="true" tabindex="-1"></a><span class="in"># nach 'body_mass_g' sortieren</span></span>
<span id="cb3-442"><a href="#cb3-442" aria-hidden="true" tabindex="-1"></a><span class="in">penguins %&gt;% </span></span>
<span id="cb3-443"><a href="#cb3-443" aria-hidden="true" tabindex="-1"></a><span class="in">  arrange(</span></span>
<span id="cb3-444"><a href="#cb3-444" aria-hidden="true" tabindex="-1"></a><span class="in">    sex, desc(body_mass_g)</span></span>
<span id="cb3-445"><a href="#cb3-445" aria-hidden="true" tabindex="-1"></a><span class="in">  )</span></span>
<span id="cb3-446"><a href="#cb3-446" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-447"><a href="#cb3-447" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-448"><a href="#cb3-448" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-449"><a href="#cb3-449" aria-hidden="true" tabindex="-1"></a><span class="fu">### Operationen mit gruppierten Datens√§tzen</span></span>
<span id="cb3-450"><a href="#cb3-450" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-451"><a href="#cb3-451" aria-hidden="true" tabindex="-1"></a>F√ºr manche Transformationen ist eine Gruppierung der Daten hilfreich. Wir illustrieren nachfolgend die unterschiedlichen Verhaltensweisen ausgew√§hlter Verben durch Vergleiche von gruppierten und nicht-gruppierten Anwendungen.</span>
<span id="cb3-452"><a href="#cb3-452" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb3-453"><a href="#cb3-453" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb3-454"><a href="#cb3-454" aria-hidden="true" tabindex="-1"></a><span class="in"># Datensatz gruppieren</span></span>
<span id="cb3-455"><a href="#cb3-455" aria-hidden="true" tabindex="-1"></a><span class="in">penguins_grouped &lt;- penguins %&gt;% </span></span>
<span id="cb3-456"><a href="#cb3-456" aria-hidden="true" tabindex="-1"></a><span class="in">  group_by(species)</span></span>
<span id="cb3-457"><a href="#cb3-457" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-458"><a href="#cb3-458" aria-hidden="true" tabindex="-1"></a><span class="in"># Datensatz hat nun die Eigenschaft 'Groups'</span></span>
<span id="cb3-459"><a href="#cb3-459" aria-hidden="true" tabindex="-1"></a><span class="in">glimpse(penguins_grouped)</span></span>
<span id="cb3-460"><a href="#cb3-460" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-461"><a href="#cb3-461" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-462"><a href="#cb3-462" aria-hidden="true" tabindex="-1"></a><span class="in">`species`</span> hat drei Auspr√§gungen. Entsprechend ist <span class="in">`penguins_grouped`</span> nun in drei Gruppen eingeteilt.</span>
<span id="cb3-463"><a href="#cb3-463" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-464"><a href="#cb3-464" aria-hidden="true" tabindex="-1"></a>Bei gruppierten Datens√§tzen fasst <span class="in">`summarise()`</span> die Variablen pro Guppe zusammen.</span>
<span id="cb3-465"><a href="#cb3-465" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-466"><a href="#cb3-466" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb3-467"><a href="#cb3-467" aria-hidden="true" tabindex="-1"></a><span class="in"># summarise -- ungruppiert:</span></span>
<span id="cb3-468"><a href="#cb3-468" aria-hidden="true" tabindex="-1"></a><span class="in">penguins %&gt;%</span></span>
<span id="cb3-469"><a href="#cb3-469" aria-hidden="true" tabindex="-1"></a><span class="in">  summarise(</span></span>
<span id="cb3-470"><a href="#cb3-470" aria-hidden="true" tabindex="-1"></a><span class="in">    across(</span></span>
<span id="cb3-471"><a href="#cb3-471" aria-hidden="true" tabindex="-1"></a><span class="in">      where(is.numeric), \(x) mean(x, na.rm = T)</span></span>
<span id="cb3-472"><a href="#cb3-472" aria-hidden="true" tabindex="-1"></a><span class="in">      )</span></span>
<span id="cb3-473"><a href="#cb3-473" aria-hidden="true" tabindex="-1"></a><span class="in">    )</span></span>
<span id="cb3-474"><a href="#cb3-474" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-475"><a href="#cb3-475" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-476"><a href="#cb3-476" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb3-477"><a href="#cb3-477" aria-hidden="true" tabindex="-1"></a><span class="in"># summarise -- gruppiert:    </span></span>
<span id="cb3-478"><a href="#cb3-478" aria-hidden="true" tabindex="-1"></a><span class="in">penguins_grouped %&gt;%</span></span>
<span id="cb3-479"><a href="#cb3-479" aria-hidden="true" tabindex="-1"></a><span class="in">  summarise(</span></span>
<span id="cb3-480"><a href="#cb3-480" aria-hidden="true" tabindex="-1"></a><span class="in">    across(</span></span>
<span id="cb3-481"><a href="#cb3-481" aria-hidden="true" tabindex="-1"></a><span class="in">      where(is.numeric), </span></span>
<span id="cb3-482"><a href="#cb3-482" aria-hidden="true" tabindex="-1"></a><span class="in">      ~ mean(., na.rm = T)</span></span>
<span id="cb3-483"><a href="#cb3-483" aria-hidden="true" tabindex="-1"></a><span class="in">    )</span></span>
<span id="cb3-484"><a href="#cb3-484" aria-hidden="true" tabindex="-1"></a><span class="in">  )</span></span>
<span id="cb3-485"><a href="#cb3-485" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-486"><a href="#cb3-486" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-487"><a href="#cb3-487" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-488"><a href="#cb3-488" aria-hidden="true" tabindex="-1"></a><span class="in">`mutate()`</span> definiert bzw. transformiert f√ºr jede Gruppe separat. Im dies zu veranschaulichen, ziehen wir eine Zufallsstichprobe von 10 Pinguinen aus der Datensatz.</span>
<span id="cb3-489"><a href="#cb3-489" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-490"><a href="#cb3-490" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb3-491"><a href="#cb3-491" aria-hidden="true" tabindex="-1"></a><span class="in"># Zufallsstichprobe generieren</span></span>
<span id="cb3-492"><a href="#cb3-492" aria-hidden="true" tabindex="-1"></a><span class="in">set.seed(123)</span></span>
<span id="cb3-493"><a href="#cb3-493" aria-hidden="true" tabindex="-1"></a><span class="in">(</span></span>
<span id="cb3-494"><a href="#cb3-494" aria-hidden="true" tabindex="-1"></a><span class="in">  penguins_sample &lt;- penguins %&gt;%</span></span>
<span id="cb3-495"><a href="#cb3-495" aria-hidden="true" tabindex="-1"></a><span class="in">    slice_sample(n = 10)  </span></span>
<span id="cb3-496"><a href="#cb3-496" aria-hidden="true" tabindex="-1"></a><span class="in">)</span></span>
<span id="cb3-497"><a href="#cb3-497" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-498"><a href="#cb3-498" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-499"><a href="#cb3-499" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb3-500"><a href="#cb3-500" aria-hidden="true" tabindex="-1"></a><span class="in"># mutate() -- ungruppiert:</span></span>
<span id="cb3-501"><a href="#cb3-501" aria-hidden="true" tabindex="-1"></a><span class="in">penguins_sample %&gt;%</span></span>
<span id="cb3-502"><a href="#cb3-502" aria-hidden="true" tabindex="-1"></a><span class="in">  transmute(</span></span>
<span id="cb3-503"><a href="#cb3-503" aria-hidden="true" tabindex="-1"></a><span class="in">    mean = mean(bill_length_mm)</span></span>
<span id="cb3-504"><a href="#cb3-504" aria-hidden="true" tabindex="-1"></a><span class="in">  )</span></span>
<span id="cb3-505"><a href="#cb3-505" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-506"><a href="#cb3-506" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-507"><a href="#cb3-507" aria-hidden="true" tabindex="-1"></a>F√ºr den ungruppierten Datensatz berechnet <span class="in">`mutate()`</span> das Stichprobenmittel von <span class="in">`bill_length_mm`</span> √ºber *alle* zehn Datenpunkte und wei√üt diesen Wert jeweils in der Variable <span class="in">`mean`</span> zu.</span>
<span id="cb3-508"><a href="#cb3-508" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-509"><a href="#cb3-509" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb3-510"><a href="#cb3-510" aria-hidden="true" tabindex="-1"></a><span class="in"># mutate() -- gruppiert</span></span>
<span id="cb3-511"><a href="#cb3-511" aria-hidden="true" tabindex="-1"></a><span class="in">penguins_sample %&gt;%</span></span>
<span id="cb3-512"><a href="#cb3-512" aria-hidden="true" tabindex="-1"></a><span class="in">  group_by(species) %&gt;%</span></span>
<span id="cb3-513"><a href="#cb3-513" aria-hidden="true" tabindex="-1"></a><span class="in">  transmute(</span></span>
<span id="cb3-514"><a href="#cb3-514" aria-hidden="true" tabindex="-1"></a><span class="in">    mean = mean(bill_length_mm)</span></span>
<span id="cb3-515"><a href="#cb3-515" aria-hidden="true" tabindex="-1"></a><span class="in">  )</span></span>
<span id="cb3-516"><a href="#cb3-516" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-517"><a href="#cb3-517" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-518"><a href="#cb3-518" aria-hidden="true" tabindex="-1"></a>Bei gruppierten Daten berechnet <span class="in">`mutate()`</span> das Stichprobenmittel *pro Gruppe* und weist die Mittelwerte entsprechend zu.</span>
<span id="cb3-519"><a href="#cb3-519" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-520"><a href="#cb3-520" aria-hidden="true" tabindex="-1"></a><span class="fu">## Eine explorative Analyse mit `ggplot2`</span></span>
<span id="cb3-521"><a href="#cb3-521" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-522"><a href="#cb3-522" aria-hidden="true" tabindex="-1"></a>Der bereinigte Datensatz <span class="in">`penguins_cleaned`</span> eignet sich gut f√ºr eine graphische Auswertung mit dem R-Paket <span class="in">`ggplot2`</span>, welches Bestandteil des <span class="in">`tidyverse`</span> ist. Nachfolgend untersuchen wir Zusammenh√§nge zwischen den K√∂rperma√üen der Pinguine.</span>
<span id="cb3-523"><a href="#cb3-523" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-524"><a href="#cb3-524" aria-hidden="true" tabindex="-1"></a>Wir erstellen zun√§chst einen einfachen Punkteplot des Gewichts (<span class="in">`body_mass`</span>) und der Schnabeltiefe (<span class="in">`bill_depth`</span>).</span>
<span id="cb3-525"><a href="#cb3-525" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-526"><a href="#cb3-526" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb3-527"><a href="#cb3-527" aria-hidden="true" tabindex="-1"></a><span class="in"># Punkteplot: body_mass vs. bill_depth</span></span>
<span id="cb3-528"><a href="#cb3-528" aria-hidden="true" tabindex="-1"></a><span class="in">penguins_cleaned %&gt;%</span></span>
<span id="cb3-529"><a href="#cb3-529" aria-hidden="true" tabindex="-1"></a><span class="in">  ggplot(</span></span>
<span id="cb3-530"><a href="#cb3-530" aria-hidden="true" tabindex="-1"></a><span class="in">    mapping = aes(</span></span>
<span id="cb3-531"><a href="#cb3-531" aria-hidden="true" tabindex="-1"></a><span class="in">      x = body_mass, </span></span>
<span id="cb3-532"><a href="#cb3-532" aria-hidden="true" tabindex="-1"></a><span class="in">      y = bill_depth</span></span>
<span id="cb3-533"><a href="#cb3-533" aria-hidden="true" tabindex="-1"></a><span class="in">    )</span></span>
<span id="cb3-534"><a href="#cb3-534" aria-hidden="true" tabindex="-1"></a><span class="in">  ) +</span></span>
<span id="cb3-535"><a href="#cb3-535" aria-hidden="true" tabindex="-1"></a><span class="in">  geom_point()</span></span>
<span id="cb3-536"><a href="#cb3-536" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-537"><a href="#cb3-537" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-538"><a href="#cb3-538" aria-hidden="true" tabindex="-1"></a>Die Grafik zeigt einen positiven Zusammenhang zwischen dem Gewicht und der Schnabeltiefe. Als n√§chstes passen wir den Code so an, dass die Datenpunkte entsprechend der Art (<span class="in">`species`</span>) eingef√§rbt sind.</span>
<span id="cb3-539"><a href="#cb3-539" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-540"><a href="#cb3-540" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb3-541"><a href="#cb3-541" aria-hidden="true" tabindex="-1"></a><span class="in"># Punkteplot: Farbliche Darstellung verschiedener Arten</span></span>
<span id="cb3-542"><a href="#cb3-542" aria-hidden="true" tabindex="-1"></a><span class="in">penguins_cleaned %&gt;%</span></span>
<span id="cb3-543"><a href="#cb3-543" aria-hidden="true" tabindex="-1"></a><span class="in">  ggplot(</span></span>
<span id="cb3-544"><a href="#cb3-544" aria-hidden="true" tabindex="-1"></a><span class="in">    mapping = aes(</span></span>
<span id="cb3-545"><a href="#cb3-545" aria-hidden="true" tabindex="-1"></a><span class="in">      x = body_mass, </span></span>
<span id="cb3-546"><a href="#cb3-546" aria-hidden="true" tabindex="-1"></a><span class="in">      y = bill_depth, </span></span>
<span id="cb3-547"><a href="#cb3-547" aria-hidden="true" tabindex="-1"></a><span class="in">      color = species</span></span>
<span id="cb3-548"><a href="#cb3-548" aria-hidden="true" tabindex="-1"></a><span class="in">    )</span></span>
<span id="cb3-549"><a href="#cb3-549" aria-hidden="true" tabindex="-1"></a><span class="in">  ) +</span></span>
<span id="cb3-550"><a href="#cb3-550" aria-hidden="true" tabindex="-1"></a><span class="in">  geom_point()</span></span>
<span id="cb3-551"><a href="#cb3-551" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-552"><a href="#cb3-552" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-553"><a href="#cb3-553" aria-hidden="true" tabindex="-1"></a>Offenbar gibt es deutliche Unterschiede in der (gemeinsamen) Verteilung von Gewicht und Schnabeltiefe zwischen den verschiedenen Arten.</span>
<span id="cb3-554"><a href="#cb3-554" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-555"><a href="#cb3-555" aria-hidden="true" tabindex="-1"></a>Um den Zusammenhang zwischen Gewicht und Schnabeltiefe zu untersuchen, sch√§tzen wir lineare Regressionen $$body<span class="sc">\_</span>mass = \beta_0 + \beta_1 bill<span class="sc">\_</span>depth + u$$ separat f√ºr jede der drei Pinguinarten mit der KQ-Methode. Anschlie√üend zeichnen wir die gesch√§tzten Regressionsgeraden ein.</span>
<span id="cb3-556"><a href="#cb3-556" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-557"><a href="#cb3-557" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb3-558"><a href="#cb3-558" aria-hidden="true" tabindex="-1"></a><span class="in"># Lineare Regression per Art</span></span>
<span id="cb3-559"><a href="#cb3-559" aria-hidden="true" tabindex="-1"></a><span class="in">penguins_cleaned %&gt;%</span></span>
<span id="cb3-560"><a href="#cb3-560" aria-hidden="true" tabindex="-1"></a><span class="in">  ggplot(</span></span>
<span id="cb3-561"><a href="#cb3-561" aria-hidden="true" tabindex="-1"></a><span class="in">    aes(</span></span>
<span id="cb3-562"><a href="#cb3-562" aria-hidden="true" tabindex="-1"></a><span class="in">      x = body_mass, </span></span>
<span id="cb3-563"><a href="#cb3-563" aria-hidden="true" tabindex="-1"></a><span class="in">      y = bill_depth, </span></span>
<span id="cb3-564"><a href="#cb3-564" aria-hidden="true" tabindex="-1"></a><span class="in">      color = species</span></span>
<span id="cb3-565"><a href="#cb3-565" aria-hidden="true" tabindex="-1"></a><span class="in">    )</span></span>
<span id="cb3-566"><a href="#cb3-566" aria-hidden="true" tabindex="-1"></a><span class="in">  ) +</span></span>
<span id="cb3-567"><a href="#cb3-567" aria-hidden="true" tabindex="-1"></a><span class="in">  geom_point() +</span></span>
<span id="cb3-568"><a href="#cb3-568" aria-hidden="true" tabindex="-1"></a><span class="in">  geom_smooth(method = "lm", se = F)</span></span>
<span id="cb3-569"><a href="#cb3-569" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-570"><a href="#cb3-570" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-571"><a href="#cb3-571" aria-hidden="true" tabindex="-1"></a>Die Sch√§tzungen bekr√§ftigen die Vermutung, dass der lineare Zusammenhang zwischen Gewicht und Schnabeltiefe sich nicht zwischen den verschiedenen Pinguinarten unterscheidet: Pinguine der Art *Gentoo* sind im Mittel schwerer als Pinguine der √ºbrigen Arten, haben jedoch eine geringere Schnabeltiefe. </span>
<span id="cb3-572"><a href="#cb3-572" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-573"><a href="#cb3-573" aria-hidden="true" tabindex="-1"></a>Der nachfolgende Code f√ºgt der Grafik eine Regressionsline *√ºber alle* Arten hinzu. Wir setzen hierbei das Argment <span class="in">`inherit_aes = FALSE`</span> und legen damit fest, dass die Regression f√ºr <span class="in">`body_mass`</span> und <span class="in">`bill_depth`</span> ohne Differenzierung per <span class="in">`species`</span> durchgef√ºhrt wird.</span>
<span id="cb3-574"><a href="#cb3-574" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-575"><a href="#cb3-575" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb3-576"><a href="#cb3-576" aria-hidden="true" tabindex="-1"></a><span class="in"># Zusatz: Globale Regression</span></span>
<span id="cb3-577"><a href="#cb3-577" aria-hidden="true" tabindex="-1"></a><span class="in">penguins_cleaned %&gt;%</span></span>
<span id="cb3-578"><a href="#cb3-578" aria-hidden="true" tabindex="-1"></a><span class="in">  ggplot(</span></span>
<span id="cb3-579"><a href="#cb3-579" aria-hidden="true" tabindex="-1"></a><span class="in">    mapping = aes(</span></span>
<span id="cb3-580"><a href="#cb3-580" aria-hidden="true" tabindex="-1"></a><span class="in">      x = body_mass, </span></span>
<span id="cb3-581"><a href="#cb3-581" aria-hidden="true" tabindex="-1"></a><span class="in">      y = bill_depth, </span></span>
<span id="cb3-582"><a href="#cb3-582" aria-hidden="true" tabindex="-1"></a><span class="in">      color = species</span></span>
<span id="cb3-583"><a href="#cb3-583" aria-hidden="true" tabindex="-1"></a><span class="in">    )</span></span>
<span id="cb3-584"><a href="#cb3-584" aria-hidden="true" tabindex="-1"></a><span class="in">  ) +</span></span>
<span id="cb3-585"><a href="#cb3-585" aria-hidden="true" tabindex="-1"></a><span class="in">  geom_point() +</span></span>
<span id="cb3-586"><a href="#cb3-586" aria-hidden="true" tabindex="-1"></a><span class="in">  geom_smooth(method = "lm", se = F) +</span></span>
<span id="cb3-587"><a href="#cb3-587" aria-hidden="true" tabindex="-1"></a><span class="in">  # Regression f√ºr alle Datenpunkte</span></span>
<span id="cb3-588"><a href="#cb3-588" aria-hidden="true" tabindex="-1"></a><span class="in">  geom_smooth(</span></span>
<span id="cb3-589"><a href="#cb3-589" aria-hidden="true" tabindex="-1"></a><span class="in">    mapping = aes(</span></span>
<span id="cb3-590"><a href="#cb3-590" aria-hidden="true" tabindex="-1"></a><span class="in">      x = body_mass, </span></span>
<span id="cb3-591"><a href="#cb3-591" aria-hidden="true" tabindex="-1"></a><span class="in">      y = bill_depth</span></span>
<span id="cb3-592"><a href="#cb3-592" aria-hidden="true" tabindex="-1"></a><span class="in">    ),</span></span>
<span id="cb3-593"><a href="#cb3-593" aria-hidden="true" tabindex="-1"></a><span class="in">    method = "lm", </span></span>
<span id="cb3-594"><a href="#cb3-594" aria-hidden="true" tabindex="-1"></a><span class="in">    se = F, </span></span>
<span id="cb3-595"><a href="#cb3-595" aria-hidden="true" tabindex="-1"></a><span class="in">    inherit.aes = F</span></span>
<span id="cb3-596"><a href="#cb3-596" aria-hidden="true" tabindex="-1"></a><span class="in">  )</span></span>
<span id="cb3-597"><a href="#cb3-597" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-598"><a href="#cb3-598" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-599"><a href="#cb3-599" aria-hidden="true" tabindex="-1"></a>Offenbar ist die vorherige Analyse per Spezies sinnvoller: Die Regression √ºber alle Arten suggeriert einen negativen Zusammenhang zwischen Gewicht und Schnabeltiefe.</span>
<span id="cb3-600"><a href="#cb3-600" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-601"><a href="#cb3-601" aria-hidden="true" tabindex="-1"></a>*Facetting* mit <span class="in">`facet_wrap()`</span> erlaubt eine Untersuchung des Zusammenhangs je Insel (<span class="in">`island`</span>), auf der die Messung erfolgt ist.</span>
<span id="cb3-602"><a href="#cb3-602" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-603"><a href="#cb3-603" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb3-604"><a href="#cb3-604" aria-hidden="true" tabindex="-1"></a><span class="in"># Facettierung des per In</span></span>
<span id="cb3-605"><a href="#cb3-605" aria-hidden="true" tabindex="-1"></a><span class="in">penguins_cleaned %&gt;%</span></span>
<span id="cb3-606"><a href="#cb3-606" aria-hidden="true" tabindex="-1"></a><span class="in">  ggplot(</span></span>
<span id="cb3-607"><a href="#cb3-607" aria-hidden="true" tabindex="-1"></a><span class="in">    mapping = aes(</span></span>
<span id="cb3-608"><a href="#cb3-608" aria-hidden="true" tabindex="-1"></a><span class="in">      x = body_mass, </span></span>
<span id="cb3-609"><a href="#cb3-609" aria-hidden="true" tabindex="-1"></a><span class="in">      y = bill_depth, </span></span>
<span id="cb3-610"><a href="#cb3-610" aria-hidden="true" tabindex="-1"></a><span class="in">      color = species)</span></span>
<span id="cb3-611"><a href="#cb3-611" aria-hidden="true" tabindex="-1"></a><span class="in">  ) +</span></span>
<span id="cb3-612"><a href="#cb3-612" aria-hidden="true" tabindex="-1"></a><span class="in">  geom_point() +</span></span>
<span id="cb3-613"><a href="#cb3-613" aria-hidden="true" tabindex="-1"></a><span class="in">  geom_smooth(method = "lm", se = F) +</span></span>
<span id="cb3-614"><a href="#cb3-614" aria-hidden="true" tabindex="-1"></a><span class="in">  facet_wrap(~ island)</span></span>
<span id="cb3-615"><a href="#cb3-615" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb3-616"><a href="#cb3-616" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-617"><a href="#cb3-617" aria-hidden="true" tabindex="-1"></a>Wir sehen, dass es hinsichtlich des Zusammenhangs von Gewicht und Schnabeltiefe keine wesentlichen Diskrepanzen zwischen den drei Inseln gibt. Dar√ºber hinaus l√§sst sich anhand der Facetten leicht erkennen, wie die drei Arten √ºber die Inseln verteilt sind.</span>
</code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->



</body></html>