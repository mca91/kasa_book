<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="de" xml:lang="de"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Kausalanalyse und Machinelles Lernen mit R - 3&nbsp; Matching</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./RDD.html" rel="next">
<link href="./R_Einfuehrung.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "Keine Treffer",
    "search-matching-documents-text": "Treffer",
    "search-copy-link-title": "Link in die Suche kopieren",
    "search-hide-matches-text": "Zus√§tzliche Treffer verbergen",
    "search-more-match-text": "weitere Treffer in diesem Dokument",
    "search-more-matches-text": "weitere Treffer in diesem Dokument",
    "search-clear-button-title": "Zur√ºcksetzen",
    "search-detached-cancel-button-title": "Abbrechen",
    "search-submit-button-title": "Abschicken",
    "search-label": "Suchen"
  }
}</script>

<meta name="robots" content="noindex">

<script>
  MathJax = {
    tex: {
      tags: 'ams'  // should be 'ams', 'none', or 'all'
    }
  };
</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.js" integrity="sha512-aoZChv+8imY/U1O7KIHXvO87EOzCuKO0GhFtpD6G2Cyjo/xPeTgdf3/bchB10iB+AojMTDkMHDPLKNxPJVqDcw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/all.min.css">

<style>
.qwebr-code-output-stdout {background-color: powderblue;}

.qwebr-button-run {
 width = 100%; 
}

</style>

<script src="https://cdn.jsdelivr.net/npm/quizdown@latest/public/build/quizdown.js"></script>
<script>quizdown.init();</script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/monaco-editor@0.43.0/min/vs/editor/editor.main.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha512-z3gLpd7yknf1YoNbCzqRKc4qyor8gaKU1qmn+CShxbuBusANI9QpRohGBreCFkKxLhei6S9CQXFEbbKuqLg0DA==" crossorigin="anonymous" referrerpolicy="no-referrer">
<style>
  .monaco-editor pre {
    background-color: unset !important;
  }

  .qwebr-icon-status-spinner {
    color: darkgreen;
  }

  .qwebr-icon-run-code {
    color: #0d9c29
  }

  .qwebr-output-code-stdout {
    color: #111;
  }

  .qwebr-output-code-stderr {
    color: #db4133;
  }
  
  .qwebr-editor {
    border: 1px solid #EEEEEE;
  }
  
  .qwebr-button-run {
    background-color: #EEEEEE;
    border-bottom-left-radius: 0;
    border-bottom-right-radius: 0; /* Extra styling for consistency */
    display: inline-block;
    font-weight: 600;
    line-height: 1;
    color: #000;
    text-align: center;
    text-decoration: none;
    -webkit-text-decoration: none;
    -moz-text-decoration: none;
    -ms-text-decoration: none;
    -o-text-decoration: none;
    /* vertical-align: middle; */ /* Prevents a space from appearing between the code cell and button */
    -webkit-user-select: none;
    border-color: #dee2e6;
    border: 1px solid rgba(0,0,0,0);
    padding: 0.375rem 0.75rem 0.75rem;
    font-size: .8rem;
    border-top-right-radius: 0.25rem;
    border-top-left-radius: 0.25rem;
    transition: color .15s ease-in-out,
    background-color .15s ease-in-out,
    border-color .15s ease-in-out,
    box-shadow .15s ease-in-out;
  }

  .qwebr-button-run:hover {
    color: #000;
    background-color: #e3e6ea;
    border-color: #e1e5e9;
  }

  .qwebr-button-run:disabled,
  .qwebr-button-run.disabled,
  fieldset:disabled 
  .qwebr-button-run {
    pointer-events: none;
    cursor: not-allowed;
    opacity: .5
  }
  
  .qwebr-output-code-area > pre {
    background-color: #F2F2F2;
    border-radius: 15px;
    margin-top: .8rem;
    padding: .1rem;
  }
  
  .qwebr-output-code-area > pre > div {
    margin: .4rem;
    margin-left: .6rem;
  }
  
  .monaco-editor {
    z-index: 0;
    -webkit-box-shadow: 5px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 5px 5px 15px 5px rgba(0, 0, 0, 0.3);    
  }

  
  /* Custom styling for RevealJS Presentations*/

  /* Reset the style of the interactive area */
  .reveal div.qwebr-interactive-area {
    display: block;
    box-shadow: none;
    max-width: 100%;
    max-height: 100%;
    margin: 0;
    padding: 0;
  } 

  /* Provide space to entries */
  .reveal div.qwebr-output-code-area pre div {
    margin: 1px 2px 1px 10px;
  }

  /* Collapse the inside code tags to avoid extra space between line outputs */
  .reveal pre div code.qwebr-output-code-stdout, .reveal pre div code.qwebr-output-code-stderr {
    padding: 0;
    display: contents;
  }

  .reveal pre div code.qwebr-output-code-stdout {
    color: #111;
  }

  .reveal pre div code.qwebr-output-code-stderr {
    color: #db4133;
  }


  /* Create a border around console and output (does not effect graphs) */
  .reveal div.qwebr-console-area {
    border: 1px solid #EEEEEE;
    box-shadow: 2px 2px 10px #EEEEEE;
  }

  /* Cap output height and allow text to scroll */
  /* TODO: Is there a better way to fit contents/max it parallel to the monaco editor size? */
  .reveal div.qwebr-output-code-area pre {
    max-height: 400px;
    overflow: scroll;
  }
</style>

<script type="module">

  // Start a timer
  const initializeWebRTimerStart = performance.now();

  // Determine if we need to install R packages
  var installRPackagesList = ['boot', 'cobalt', 'marginaleffects', 'MatchIt', 'sandwich', 'tidyverse'];
  // Check to see if we have an empty array, if we do set to skip the installation.
  var setupRPackages = !(installRPackagesList.indexOf("") !== -1);
  var autoloadRPackages = true;

  // Display a startup message?
  var showStartupMessage = true;
  var showHeaderMessage = false;
  if (showStartupMessage) {

    // Get references to header elements
    const headerHTML = document.getElementById("title-block-header");
    const headerRevealJS = document.getElementById("title-slide");

    // Create the outermost div element for metadata
    const quartoTitleMeta = document.createElement("div");
    quartoTitleMeta.classList.add("quarto-title-meta");

    // Create the first inner div element
    const firstInnerDiv = document.createElement("div");
    firstInnerDiv.setAttribute("id", "qwebr-status-message-area");

    // Create the second inner div element for "WebR Status" heading and contents
    const secondInnerDiv = document.createElement("div");
    secondInnerDiv.setAttribute("id", "qwebr-status-message-title");
    secondInnerDiv.classList.add("quarto-title-meta-heading");
    secondInnerDiv.innerText = "WebR-Status";

    // Create another inner div for contents
    const secondInnerDivContents = document.createElement("div");
    secondInnerDivContents.setAttribute("id", "qwebr-status-message-body");
    secondInnerDivContents.classList.add("quarto-title-meta-contents");

    // Describe the WebR state
    var startupMessageWebR = document.createElement("p");
    startupMessageWebR.innerText = "Starte..."
    startupMessageWebR.setAttribute("id", "qwebr-status-message-text");
    // Add `aria-live` to auto-announce the startup status to screen readers
    startupMessageWebR.setAttribute("aria-live", "assertive");

    // Append the startup message to the contents
    secondInnerDivContents.appendChild(startupMessageWebR);

    // Add a status indicator for COOP and COEP Headers if needed
    if (showHeaderMessage) {
      const crossOriginMessage = document.createElement("p");
      crossOriginMessage.innerText = `${crossOriginIsolated ? 'üü¢' : 'üü°'} COOP & COEP Headers`;
      crossOriginMessage.setAttribute("id", "qwebr-coop-coep-header");
      secondInnerDivContents.appendChild(crossOriginMessage);
    }

    // Combine the inner divs and contents
    firstInnerDiv.appendChild(secondInnerDiv);
    firstInnerDiv.appendChild(secondInnerDivContents);
    quartoTitleMeta.appendChild(firstInnerDiv);

    // Determine where to insert the quartoTitleMeta element
    if (headerHTML) {
      // Append to the existing "title-block-header" element
      headerHTML.appendChild(quartoTitleMeta);
    } else if (headerRevealJS) {
      // If using RevealJS, add to the "title-slide" div
      headerRevealJS.appendChild(firstInnerDiv);
    } else {
      // If neither headerHTML nor headerRevealJS is found, insert after "webr-monaco-editor-init" script
      const monacoScript = document.getElementById("qwebr-monaco-editor-init");
      const header = document.createElement("header");
      header.setAttribute("id", "title-block-header");
      header.appendChild(quartoTitleMeta);
      monacoScript.after(header);
    }
  }

  // Retrieve the webr.mjs
  import { WebR, ChannelType } from "https://webr.r-wasm.org/v0.2.2/webr.mjs";

  // Populate WebR options with defaults or new values based on 
  // webr meta
  globalThis.webR = new WebR({
    "baseURL": "https://webr.r-wasm.org/v0.2.2/",
    "serviceWorkerUrl": "",
    "homedir": "/home/web_user", 
    "channelType": ChannelType.Automatic
  });

  // Initialization WebR
  await globalThis.webR.init();

  // Setup a shelter
  globalThis.webRCodeShelter = await new globalThis.webR.Shelter();

  // Setup a pager to allow processing help documentation 
  await globalThis.webR.evalRVoid('webr::pager_install()'); 

  // Function to set the button text
  function qwebrSetInteractiveButtonState(buttonText, enableCodeButton = true) {
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.innerHTML = buttonText;
      btn.disabled = !enableCodeButton;
    });
  }

  // Function to update the status message
  function qwebrUpdateStatusHeader(message) {
    startupMessageWebR.innerHTML = `
      <i class="fas fa-cog fa-spin qwebr-icon-status-spinner"></i>
      <span>${message}</span>`;
  }

  // Function to install a single package
  async function qwebrInstallRPackage(packageName) {
    await globalThis.webR.installPackages([packageName]);
  }

  // Function to load a single package
  async function qwebrLoadRPackage(packageName) {
    await globalThis.webR.evalRVoid(`library(${packageName});`);
  }

  // Generic function to process R packages
  async function qwebrProcessRPackagesWithStatus(packages, processType, displayStatusMessageUpdate = true) {
    // Switch between contexts
    const messagePrefix = processType === 'install' ? 'Installiere' : 'Lade';

    // Modify button state
    qwebrSetInteractiveButtonState(`<i class="fas fa-cog fa-spin qwebr-icon-status-spinner"></i> ${messagePrefix} Pakete ...`, false);

    // Iterate over packages
    for (let i = 0; i < packages.length; i++) {
      const activePackage = packages[i];
      const formattedMessage = `${messagePrefix} Paket ${i + 1} von ${packages.length}: <code style="background-color:white; color:darkgreen;">${activePackage}</code>`;
      
      // Display the update
      if (displayStatusMessageUpdate) {
        qwebrUpdateStatusHeader(formattedMessage);
      }

      // Run package installation
      if (processType === 'install') {
        await qwebrInstallRPackage(activePackage);
      } else {
        await qwebrLoadRPackage(activePackage);
      }
    }

    // Clean slate
    if (processType === 'load') {
      await globalThis.webR.flush();
    }
  }


  // Check to see if any packages need to be installed
  if (setupRPackages) {
    // Obtain only a unique list of packages
    const uniqueRPackageList = Array.from(new Set(installRPackagesList));

    // Install R packages one at a time (either silently or with a status update)
    await qwebrProcessRPackagesWithStatus(uniqueRPackageList, 'install', showStartupMessage);

    if(autoloadRPackages) {
      // Load R packages one at a time (either silently or with a status update)
      await qwebrProcessRPackagesWithStatus(uniqueRPackageList, 'load', showStartupMessage);
    }
  }

  // Stop timer
  const initializeWebRTimerEnd = performance.now();

  // Release document status as ready
  if (showStartupMessage) {
    startupMessageWebR.innerText = "‚úÖ Bereit!"
  }
  
  qwebrSetInteractiveButtonState(
    `<span>R-Code ausf√ºhren <i class="fa fa-sign-in"></i></span>`, 
    true
  );

</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="nav-sidebar floating slimcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Seitenleiste umschalten" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
      <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./Matching.html"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Matching</span></a></li></ol></nav>
      <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Seitenleiste umschalten" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
      </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./"></a><a href="./index.html">Kausalanalyse mit R</a> 
        <div class="sidebar-tools-main">
  <a href="" class="quarto-reader-toggle quarto-navigation-tool px-1" onclick="window.quartoToggleReader(); return false;" title="Lesemodus umschalten">
  <div class="quarto-reader-toggle-btn">
  <i class="bi"></i>
  </div>
</a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Suchen"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Start</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./R_Einfuehrung.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Statistische Programmierung mit R</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Matching.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Matching</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./RDD.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Regression Discontiniuty Designs</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./RegReg.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Regularisierte Regression</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Literatur.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Literatur</span></a>
  </div>
</li>
    </ul>
    </div>
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title"><a href="./index.html">√úbersicht</a></h2>
   
  <ul>
  <li><a href="#einfluss-von-darkmode-auf-blog-lesezeit" id="toc-einfluss-von-darkmode-auf-blog-lesezeit" class="nav-link active" data-scroll-target="#einfluss-von-darkmode-auf-blog-lesezeit"><span class="header-section-number">3.1</span> Einfluss von Darkmode auf Blog-Lesezeit</a></li>
  <li><a href="#inferenz-f√ºr-attate-propensity-score-matching-mit-bootstrap" id="toc-inferenz-f√ºr-attate-propensity-score-matching-mit-bootstrap" class="nav-link" data-scroll-target="#inferenz-f√ºr-attate-propensity-score-matching-mit-bootstrap"><span class="header-section-number">3.2</span> Inferenz f√ºr ATT/ATE: Propensity-Score-Matching mit Bootstrap</a></li>
  <li><a href="#doubly-robust-sch√§tzer-f√ºr-attate" id="toc-doubly-robust-sch√§tzer-f√ºr-attate" class="nav-link" data-scroll-target="#doubly-robust-sch√§tzer-f√ºr-attate"><span class="header-section-number">3.3</span> Doubly-Robust-Sch√§tzer f√ºr ATT/ATE</a></li>
  <li><a href="#literatur" id="toc-literatur" class="nav-link" data-scroll-target="#literatur"><span class="header-section-number">4</span> Literatur</a></li>
  </ul>
</nav>
</nav>
<div id="quarto-sidebar-glass" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
    </div>
<!-- main -->
<main class="content page-columns page-full" id="quarto-document-content">
<script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.43.0/min/vs/loader.js"></script>
<script type="module" id="qwebr-monaco-editor-init">

  // Configure the Monaco Editor's loader
  require.config({
    paths: {
      'vs': 'https://cdn.jsdelivr.net/npm/monaco-editor@0.43.0/min/vs'
    }
  });
</script>

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Matching</span></h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> Code</button></div></div>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<script type="module">
// Initialization WebR
await globalThis.webR.init();

// Run R code without focusing on storing data.
await globalThis.webR.evalRVoid(`
# create dataset directory
dir.create("datasets")
# Download the dataset
download.file(
    "https://raw.githubusercontent.com/mca91/kasa_data/main/darkmode.csv",
    'datasets/darkmode.csv'
)
`)
</script>	
<section id="einfluss-von-darkmode-auf-blog-lesezeit" class="level2 page-columns page-full" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="einfluss-von-darkmode-auf-blog-lesezeit"><span class="header-section-number">3.1</span> Einfluss von Darkmode auf Blog-Lesezeit</h2>
<div class="cell page-columns page-full" data-fig-width="4" data-fig-height="3" data-layout-align="center">
<div class="cell-output-display page-columns page-full">
<div id="fig-CDdarkmode" class="quarto-figure quarto-figure-center anchored page-columns page-full">
<figure class="figure page-columns page-full">
<div>
<svg width="384" height="288" viewbox="0.00 0.00 371.48 188.00" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" style="; max-width: none; max-height: none">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 184)"> <polygon fill="white" stroke="transparent" points="-4,4 -4,-184 367.48,-184 367.48,4 -4,4"></polygon> <!-- read_time --> <g id="node1" class="node">
<title>
read_time
</title>
<text text-anchor="middle" x="327.49" y="-157.8" font-family="Helvetica,Arial,mono" font-size="14.00">read_time</text> </g> <!-- dark_mode --> <g id="node2" class="node">
<title>
dark_mode
</title>
<text text-anchor="middle" x="39.49" y="-157.8" font-family="Helvetica,Arial,sans-serif" font-size="14.00">dark_mode</text> </g> <!-- dark_mode&#45;&gt;read_time --> <g id="edge1" class="edge">
<title>
dark_mode-&gt;read_time
</title>
<path fill="none" stroke="black" d="M79.23,-162C132,-162 225.02,-162 280.99,-162"></path> <polygon fill="black" stroke="black" points="281.33,-165.5 291.33,-162 281.33,-158.5 281.33,-165.5"></polygon> </g> <!-- male --> <g id="node3" class="node">
<title>
male
</title>
<text text-anchor="middle" x="183.49" y="-13.8" font-family="Helvetica,Arial,sans-serif" font-size="14.00">male</text> </g> <!-- male&#45;&gt;read_time --> <g id="edge3" class="edge">
<title>
male-&gt;read_time
</title>
<path fill="none" stroke="black" d="M201.73,-36.24C227.15,-61.66 273.36,-107.87 302.13,-136.64"></path> <polygon fill="black" stroke="black" points="299.85,-139.31 309.4,-143.91 304.8,-134.36 299.85,-139.31"></polygon> </g> <!-- male&#45;&gt;dark_mode --> <g id="edge2" class="edge">
<title>
male-&gt;dark_mode
</title>
<path fill="none" stroke="black" d="M165.25,-36.24C139.83,-61.66 93.62,-107.87 64.85,-136.64"></path> <polygon fill="black" stroke="black" points="62.18,-134.36 57.58,-143.91 67.13,-139.31 62.18,-134.36"></polygon> </g> </g>
</svg>
</div>
<figcaption class="figure-caption margin-caption">Abbildung&nbsp;3.1: Geschlecht ist Backdoor-Pfad</figcaption>
</figure>
</div>
</div>
</div>
<p>Wir lesen zun√§chst den Datensatz <em>darkmode.csv</em> ein und verschaffen uns einen √úberblick √ºber die verf√ºgbaren Variablen.</p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>


<div id="qwebr-interactive-area-2" class="qwebr-interactive-area">
  <div id="qwebr-console-area-2" class="qwebr-console-area">
    <div id="qwebr-editor-2" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-2">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-2" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-2" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-2");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-2");
  const editorDiv = document.getElementById("qwebr-editor-2");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-2");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `library(tidyverse)

# Datensatz 'darkmode' einlesen
darkmode <- read_csv(
  file = "datasets/darkmode.csv", 
  show_col_types = F
)

# √úberblick verschaffen
glimpse(darkmode)`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-2-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-2-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script>
<p><code>dark_mode</code> hat den Typ <code>logical</code>. Mit <code>dplyr::mutate_all()</code> k√∂nnen wir komfortabel alle Spalten in den Typ <code>numeric</code> transformieren.</p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>


<div id="qwebr-interactive-area-3" class="qwebr-interactive-area">
  <div id="qwebr-console-area-3" class="qwebr-console-area">
    <div id="qwebr-editor-3" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-3">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-3" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-3" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-3");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-3");
  const editorDiv = document.getElementById("qwebr-editor-3");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-3");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `# Alle Variablen zu typ 'numeric' formatieren...
darkmode <- darkmode %>% 
  mutate_all(.funs = as.numeric)

# ... und √ºberpr√ºfen
glimpse(darkmode)`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-3-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-3-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script>
<div class="cell page-columns page-full" data-fig-width="4" data-fig-height="3" data-layout-align="center">
<div class="cell-output-display page-columns page-full">
<div id="fig-CDdarkmode2" class="quarto-figure quarto-figure-center anchored page-columns page-full">
<figure class="figure page-columns page-full">
<div>
<svg width="384" height="288" viewbox="0.00 0.00 371.48 260.00" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" style="; max-width: none; max-height: none">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 256)"> <polygon fill="white" stroke="transparent" points="-4,4 -4,-256 367.48,-256 367.48,4 -4,4"></polygon> <!-- age --> <g id="node1" class="node">
<title>
age
</title>
<text text-anchor="middle" x="39.49" y="-229.8" font-family="Helvetica,Arial,sans-serif" font-size="14.00">age</text> </g> <!-- dark_mode --> <g id="node3" class="node">
<title>
dark_mode
</title>
<text text-anchor="middle" x="39.49" y="-157.8" font-family="Helvetica,Arial,sans-serif" font-size="14.00">dark_mode</text> </g> <!-- age&#45;&gt;dark_mode --> <g id="edge1" class="edge">
<title>
age-&gt;dark_mode
</title>
<path fill="none" stroke="black" d="M39.49,-215.83C39.49,-208.13 39.49,-198.97 39.49,-190.42"></path> <polygon fill="black" stroke="black" points="42.99,-190.41 39.49,-180.41 35.99,-190.41 42.99,-190.41"></polygon> </g> <!-- read_time --> <g id="node2" class="node">
<title>
read_time
</title>
<text text-anchor="middle" x="327.49" y="-157.8" font-family="Helvetica,Arial,mono" font-size="14.00">read_time</text> </g> <!-- dark_mode&#45;&gt;read_time --> <g id="edge2" class="edge">
<title>
dark_mode-&gt;read_time
</title>
<path fill="none" stroke="black" d="M79.23,-162C132,-162 225.02,-162 280.99,-162"></path> <polygon fill="black" stroke="black" points="281.33,-165.5 291.33,-162 281.33,-158.5 281.33,-165.5"></polygon> </g> <!-- hours --> <g id="node4" class="node">
<title>
hours
</title>
<text text-anchor="middle" x="327.49" y="-229.8" font-family="Helvetica,Arial,sans-serif" font-size="14.00">hours</text> </g> <!-- hours&#45;&gt;read_time --> <g id="edge3" class="edge">
<title>
hours-&gt;read_time
</title>
<path fill="none" stroke="black" d="M327.49,-215.83C327.49,-208.13 327.49,-198.97 327.49,-190.42"></path> <polygon fill="black" stroke="black" points="330.99,-190.41 327.49,-180.41 323.99,-190.41 330.99,-190.41"></polygon> </g> <!-- male --> <g id="node5" class="node">
<title>
male
</title>
<text text-anchor="middle" x="183.49" y="-13.8" font-family="Helvetica,Arial,sans-serif" font-size="14.00">male</text> </g> <!-- male&#45;&gt;read_time --> <g id="edge5" class="edge">
<title>
male-&gt;read_time
</title>
<path fill="none" stroke="black" d="M201.73,-36.24C227.15,-61.66 273.36,-107.87 302.13,-136.64"></path> <polygon fill="black" stroke="black" points="299.85,-139.31 309.4,-143.91 304.8,-134.36 299.85,-139.31"></polygon> </g> <!-- male&#45;&gt;dark_mode --> <g id="edge4" class="edge">
<title>
male-&gt;dark_mode
</title>
<path fill="none" stroke="black" d="M165.25,-36.24C139.83,-61.66 93.62,-107.87 64.85,-136.64"></path> <polygon fill="black" stroke="black" points="62.18,-134.36 57.58,-143.91 67.13,-139.31 62.18,-134.36"></polygon> </g> </g>
</svg>
</div>
<figcaption class="figure-caption margin-caption">Abbildung&nbsp;3.2: M√∂glicher DGP als Kausales Diagramm</figcaption>
</figure>
</div>
</div>
</div>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>


<div id="qwebr-interactive-area-4" class="qwebr-interactive-area">
  <div id="qwebr-console-area-4" class="qwebr-console-area">
    <div id="qwebr-editor-4" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-4">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-4" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-4" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-4");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-4");
  const editorDiv = document.getElementById("qwebr-editor-4");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-4");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `# Logit-Modell mit 'glm()' sch√§tzen
(
  darkmode_ps_logit <- glm(
    formula = dark_mode ~ age + male + hours,
    data = darkmode,
    family = binomial
  )
)`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-4-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-4-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>


<div id="qwebr-interactive-area-5" class="qwebr-interactive-area">
  <div id="qwebr-console-area-5" class="qwebr-console-area">
    <div id="qwebr-editor-5" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-5">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-5" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-5" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-5");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-5");
  const editorDiv = document.getElementById("qwebr-editor-5");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-5");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `# Datensatz um propensity scores erweitern
(
  darkmode_probabilities <- 
    darkmode %>%
    mutate(
      propensity = fitted(darkmode_ps_logit)
    )
)`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-5-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-5-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script>
<p>Inverse probability weights (IPWs) anhand der PS k√∂nnen schnell anhand der Vorschrift <span class="math display">\[\texttt{ipw} = \texttt{dark\_mode} / \texttt{propensity} + (1 - \texttt{dark\_mode}) / (1 - \texttt{propensity}), \quad \texttt{dark\_mode} \in\{0,1\}\]</span> berechnet werden.</p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>


<div id="qwebr-interactive-area-6" class="qwebr-interactive-area">
  <div id="qwebr-console-area-6" class="qwebr-console-area">
    <div id="qwebr-editor-6" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-6">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-6" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-6" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-6");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-6");
  const editorDiv = document.getElementById("qwebr-editor-6");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-6");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `# Datensatz um IPWs erweitern
darkmode_ipw <- darkmode_probabilities %>%
  mutate(
    ipw = dark_mode / propensity + (1 - dark_mode) / (1 - propensity)
  )

darkmode_ipw %>% 
  select(ipw)`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-6-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-6-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script>
<p>Verteilung der Propensity Scores nach Behandlungs-Indikator:</p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>


<div id="qwebr-interactive-area-7" class="qwebr-interactive-area">
  <div id="qwebr-console-area-7" class="qwebr-console-area">
    <div id="qwebr-editor-7" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-7">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-7" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-7" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-7");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-7");
  const editorDiv = document.getElementById("qwebr-editor-7");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-7");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `# Dichtesch√§tzung der PS nach Treatment-Indikator
darkmode_ipw %>%
ggplot(
  mapping = aes(
    x = propensity, 
    fill = factor(dark_mode))
  ) + 
  lims(x = c(0, 1)) +
  geom_density(alpha = .5, )`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-7-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-7-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script>
<p>Beobachtungen aus der Kontroll-Gruppe entfernen, die au√üerhalb des Supports der Treatment-Gruppe liegen.</p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>


<div id="qwebr-interactive-area-8" class="qwebr-interactive-area">
  <div id="qwebr-console-area-8" class="qwebr-console-area">
    <div id="qwebr-editor-8" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-8">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-8" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-8" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-8");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-8");
  const editorDiv = document.getElementById("qwebr-editor-8");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-8");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `# Propensity scores auslesen
darkmode_ipws <- darkmode_ipw %>% 
  filter(dark_mode == 1) %>% 
  pull(propensity)

# Support sicherstellen 
# (entfernt 13 Beobachtungen aus der Kontrollgruppe)
darkmode_ipw <- darkmode_ipw %>% 
  filter(
    between(
      propensity,
      darkmode_ipws %>% 
        min(),
      darkmode_ipws %>% 
        max()
    )
  )`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-8-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-8-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script>
<p>Die Abdeckung k√∂nnen wir erneut mit einer Grafik gesch√§tzter Dichtefunktionen vergleichen.</p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>


<div id="qwebr-interactive-area-9" class="qwebr-interactive-area">
  <div id="qwebr-console-area-9" class="qwebr-console-area">
    <div id="qwebr-editor-9" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-9">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-9" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-9" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-9");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-9");
  const editorDiv = document.getElementById("qwebr-editor-9");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-9");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `# Dichtesch√§tzung der PS per Treatment-Indikator nach Anpassung
darkmode_ipw %>%
  ggplot(
    mapping = aes(
      x = propensity, 
      fill = factor(dark_mode)
    )
  ) + 
  lims(x = c(0, 1)) +
  geom_density(alpha = .5)`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-9-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-9-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script>
<p>Wir finden etwas weniger Wahrscheinlichkeits-Masse nahe 0 f√ºr die Kontroll-Gruppe nach filtern von (Kontroll-)Beobachtungen mit PS in der Spannweite der PS in der Behandlungs-Gruppe. Als n√§chstes sch√§tzen wir den ATE mit linearer Regression.</p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>


<div id="qwebr-interactive-area-10" class="qwebr-interactive-area">
  <div id="qwebr-console-area-10" class="qwebr-console-area">
    <div id="qwebr-editor-10" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-10">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-10" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-10" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-10");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-10");
  const editorDiv = document.getElementById("qwebr-editor-10");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-10");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `# Mit IPWs gewichteter KQ-Schaetzer berechnet einen ATE
model_ipw <- lm(
  formula = read_time ~ dark_mode, 
  data = darkmode_ipw,
  weights = ipw
)

summary(model_ipw)`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-10-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-10-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script>
<p>Unsere Sch√§tzung des ATE ist der gesch√§tzte Koeffizient von <code>dark_mode</code>. Die ausgegebenen Standardfehler und Inferenzstatistiken sind <em>ung√ºltig</em> aufgrund der Gewichtung mit IPWs, inversen <em>gesch√§tzten</em> Wahrscheinlichkeiten f√ºr eine Behandlung. Der Grund hierf√ºr ist, dass die Standardformel in <code>summary()</code> die zus√§tzliche Unsicherheit durch die IPW-Sch√§tzung nicht ber√ºcksichtigt!</p>
<p>Die Vergleichbarkeit der Nutzer in Kontroll- und Behandlungsgruppe-Gruppe f√ºr die Variablen <code>age</code>, <code>hours</code> und <code>male</code> k√∂nnen wir graphisch und anhand einer <em>balance table</em> vergleichen.</p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>


<div id="qwebr-interactive-area-11" class="qwebr-interactive-area">
  <div id="qwebr-console-area-11" class="qwebr-console-area">
    <div id="qwebr-editor-11" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-11">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-11" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-11" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-11");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-11");
  const editorDiv = document.getElementById("qwebr-editor-11");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-11");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `# Dichtesch√§tzungen
darkmode %>% 
  group_by(dark_mode) %>%
  select(age, hours) %>%
  mutate_all(scale) %>% # Standardisierung mit 'scale()'
  pivot_longer(cols = c(-dark_mode)) %>% # langes Format
  
  ggplot(aes(x = value, fill = as.factor(dark_mode))) +
  geom_density( alpha = .5) + 
  facet_wrap(~ name, scales = "free", nrow = 3) # Facetting nach 'name'

# Relative Hfkt. f√ºr 'male' als barplot
darkmode %>% 
  group_by(dark_mode) %>%
  mutate(
    male = as.factor(male), 
    dark_mode = as.factor(dark_mode)
  ) %>%
  
  ggplot(aes(x = dark_mode, fill = male)) +
  geom_bar(position = "fill") +
  ylab("Anteil")

# Balance table mit 'cobalt::bal.tab()'
bal.tab(
  x = darkmode %>% 
    select(age, hours, male), 
  treat = darkmode$dark_mode, 
  disp = "m", # zeige zus√§tzlich Mittelwerte f√ºr C und T
)`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-11-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-11-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script>
<p>Wir zeigen als n√§chstes, wie <code>MatchIt::matchit()</code> f√ºr Nearest-neighbor-Matching anhand der Regressoren <code>age</code>, <code>hours</code>, und <code>male</code> in unterschiedlichen Varianten durchgef√ºhrt werden kann.</p>
<p><code>MatchIt::matchit()</code> f√ºhrt standardm√§√üig 1:1-Matching (ohne Zur√ºcklegen) von Beobachtungen der Treatment-Gruppe mit Beobachtungen der Kontrollgruppe druch. Das Objekt wird f√ºr eine Sch√§tzung des ATT mit einer geeigneten Funktionen vorbereitet, s. <code>?matchit</code>, und hier insb. die Argumente <code>replace = F</code>, <code>ratio = 1</code> und <code>estimand = "ATT"</code> f√ºr Details.</p>
<p>Mit <code>cobalt::balt.tab()</code> erhalten wir eine <em>balance table</em> f√ºr den gematchten Datensatz.</p>
<p><strong>Exaktes Matching</strong></p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>


<div id="qwebr-interactive-area-12" class="qwebr-interactive-area">
  <div id="qwebr-console-area-12" class="qwebr-console-area">
    <div id="qwebr-editor-12" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-12">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-12" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-12" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-12");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-12");
  const editorDiv = document.getElementById("qwebr-editor-12");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-12");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `res <- matchit(
  formula = dark_mode ~ age + male + hours, 
  data = darkmode, 
  method = "exact"
)
bal.tab(res)`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-12-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-12-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script>
<p><strong>Eins-zu-Eins-Matching: Mahalanobis-Distanz</strong></p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>


<div id="qwebr-interactive-area-13" class="qwebr-interactive-area">
  <div id="qwebr-console-area-13" class="qwebr-console-area">
    <div id="qwebr-editor-13" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-13">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-13" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-13" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-13");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-13");
  const editorDiv = document.getElementById("qwebr-editor-13");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-13");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `res <- matchit(
  formula = dark_mode ~ age + male + hours, 
  data = darkmode, 
  distance = "mahalanobis", 
  method = "nearest"
)
bal.tab(res)`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-13-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-13-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script>
<p><strong>Eins-zu-Eins-Matching: Mahalanobis-Distanz mit Caliper 0.25 f√ºr propensity scores basierend auf logistischer Regression</strong></p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>


<div id="qwebr-interactive-area-14" class="qwebr-interactive-area">
  <div id="qwebr-console-area-14" class="qwebr-console-area">
    <div id="qwebr-editor-14" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-14">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-14" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-14" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-14");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-14");
  const editorDiv = document.getElementById("qwebr-editor-14");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-14");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `res <- matchit(
  formula = dark_mode ~ age + male + hours, 
  data = darkmode, 
  distance = "glm", 
  caliper = .25,
  mahvars = ~ age + male + hours
)
# (Nur K-Beobachtungen mit PS bei Caliper .25 kommen f√ºr MHD-Matching in betracht.)
bal.tab(res)`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-14-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-14-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script>
<p><strong>4. Eins-zu-Eins-Matching: Propensity scores basierend auf logistischer Regression mit Caliper 0.25</strong></p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>


<div id="qwebr-interactive-area-15" class="qwebr-interactive-area">
  <div id="qwebr-console-area-15" class="qwebr-console-area">
    <div id="qwebr-editor-15" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-15">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-15" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-15" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-15");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-15");
  const editorDiv = document.getElementById("qwebr-editor-15");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-15");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `res <- matchit(
  formula = dark_mode ~ age + male + hours, 
  data = darkmode, 
  method = "nearest", 
  distance = "glm", 
  caliper = .25
)
bal.tab(res)`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-15-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-15-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script>
<p>Die Vergleichbarkeit der Nutzer in Kontroll- und Treatment-Gruppe hinsichtlich der Variablen <code>age</code>, <code>hours</code> und <code>male</code> k√∂nnen wir graphisch und anhand einer <em>balance table</em> vergleichen. Wir berechnen die balance table mit <code>cobalt::bal.tab()</code> f√ºr den anhand von Variante 4 gematchten Datensatz.</p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>


<div id="qwebr-interactive-area-16" class="qwebr-interactive-area">
  <div id="qwebr-console-area-16" class="qwebr-console-area">
    <div id="qwebr-editor-16" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-16">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-16" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-16" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-16");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-16");
  const editorDiv = document.getElementById("qwebr-editor-16");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-16");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `bal.tab(res, un = T, disp = "m")

# Der gematchte Datensatz enth√§lt Gewichte f√ºr die jeweilige 
# Subklasse zu denen die Beobachtungen geh√∂ren.
#
# Hier 1:1 matching _ohne_ Zur√ºcklegen, d.h. s√§mtliche
# Gewichte sind 1 und wird m√ºssten diese nicht f√ºr nachfolgende 
# Aufrufe von avg comparisons ber√ºcksichtigen.
darkmode_matched <- match.data(res)

darkmode_matched %>%
  group_by(dark_mode) %>%
  select(age, hours) %>%
  mutate_all(scale) %>%
  pivot_longer(cols = c(-dark_mode)) %>%
  
  ggplot(aes(x = value, fill = as.factor(dark_mode))) +
  geom_density( alpha = .5) + 
  facet_wrap(~ name, scales = "free", nrow = 3)

darkmode_matched %>% 
  group_by(dark_mode) %>%
  mutate(
    male = as.factor(male), 
    dark_mode = as.factor(dark_mode)
  ) %>%
  
  ggplot(aes(x = dark_mode, fill = male)) +
  geom_bar(position = "fill") +
  ylab("Anteil")`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-16-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-16-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script>
<p>Wir beobachten eine bessere Balance bei <code>age</code> und <code>hours</code>. Am wichtigsten: <code>gender</code> (<code>male</code>) ist nahezu ausgeglichen f√ºr Kontroll- und Treatment-Gruppe!</p>
<p>Wir sch√§tzen nun den ATT von <code>dark_mode</code> auf <code>read_time</code> mit linearer Regression f√ºr den gematchten Datensatz aus sowie f√ºr den urspr√ºnglichen Datensatz und berechnen jeweils ein robustes 95%-Konfidenzintervall f√ºr den ATT.</p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>


<div id="qwebr-interactive-area-17" class="qwebr-interactive-area">
  <div id="qwebr-console-area-17" class="qwebr-console-area">
    <div id="qwebr-editor-17" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-17">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-17" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-17" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-17");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-17");
  const editorDiv = document.getElementById("qwebr-editor-17");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-17");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `# ATT mit linearem Modell f√ºr ungematchten Datensatz sch√§tzen
ATT_mod_org <- lm(
  formula = read_time ~ age + male + hours + dark_mode,
  data = darkmode
)
summary(ATT_mod_org)

# ATT mit linearem Modell f√ºr gematchten Datensatz sch√§tzen
ATT_mod <- lm(
  formula = read_time ~ age + male + hours + dark_mode,
  data = darkmode_matched, 
  weights = weights 
)
# (weights = 1 f√ºr alle Beobachtungen weil wg. 1:1-Matching
# nur 2er-Paare von Beobachtungen. Hier also vernachl√§ssigbar.
# Andere Gewichtung bei k:1-Matching!)
summary(ATT_mod)`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-17-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-17-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script>
<p><strong>Achtung</strong>: F√ºr Matching-Verfahren (<code>ATT_mod</code>) sind die von <code>summary()</code> berechneten Standardfehler (und damit KI, t-Statistiken und p-Werte) f√ºr den ATT <em>grunds√§tzlich ung√ºltig</em> Wir haben 3 Quellen von Sch√§tzunsicherheit, die bei der Berechnung von Standardfehlern ber√ºcksichtigt werden m√ºssen: Die Sch√§tzung der PS, der Matching-Prozess und die ‚Äú√ºbliche‚Äù Stichproben-Variabilit√§t. Wir nutzen daher nachfolgende Funktionen gem. Empfehlungen aus der aktuellen Forschung f√ºr Standardfehlerberechnung. S. auch Aufgabe 5 (a).</p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>


<div id="qwebr-interactive-area-18" class="qwebr-interactive-area">
  <div id="qwebr-console-area-18" class="qwebr-console-area">
    <div id="qwebr-editor-18" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-18">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-18" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-18" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-18");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-18");
  const editorDiv = document.getElementById("qwebr-editor-18");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-18");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `library(marginaleffects)

# Inferenz Multiple Regression bei ungematchten Beobachtungen
# identisch zu 'coeftest(ATT_mod_org, vcovHC, type = "HC3")'
avg_comparisons(
  model = ATT_mod_org,
  variables = "dark_mode",
  vcov = "HC3", # Heteroskedastie-robuster SE
  newdata = subset(darkmode, dark_mode == 1) # Identifiziert Kontrollgruppe
) 

# Inferenz Multiple Regression bei _gematchten_ Beobachtungen
avg_comparisons(
  model = ATT_mod,
  variables = "dark_mode",
  vcov = ~subclass, # cluster robust SE > als oben => mehr Unsicherheit
  newdata = subset(darkmode_matched, dark_mode == 1),
  wts = "weights"  # = 1
)
# ( Weights = 1 wg. 1:1-Matching.
# Anzahl subclasses = Anzahl gematchter treatment/control units )`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-18-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-18-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script>
</section>
<section id="inferenz-f√ºr-attate-propensity-score-matching-mit-bootstrap" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="inferenz-f√ºr-attate-propensity-score-matching-mit-bootstrap"><span class="header-section-number">3.2</span> Inferenz f√ºr ATT/ATE: Propensity-Score-Matching mit Bootstrap</h2>
<p>Bei Matching mit Zur√ºcklegen besteht zus√§tzliche Unsicherheit durch Zur√ºcklegen, d.h. Beobachtungen aus der Kontroll-Gruppe k√∂nnen mehrfach als Match f√ºr Beobachtungen aus der Treatment-Gruppe genutzt werden. Mit <code>summary()</code> berechnete Standardfehler ber√ºcksichtigen dies nicht!</p>
<p>Ein Bootstrap-Verfahren generiert mit Resampling (wiederholtes Ziehen mit Zur√ºcklegen) aus dem Original-Datensatz (viele) k√ºnstliche Datens√§tze, f√ºr die der Sch√§tzer (d.h. das gesamte Verfahren inkl. Matching!) jeweils berechnet wird. Die Verteilung der so gewonnenen Bootstrap-Sch√§tzwerte approximiert die wahre, unbekannte Stichprobenverteilung des Sch√§tzers des Behandlungseffekts. Mit dieser simulierten Verteilung k√∂nnen wir Inferenz betreiben: Wir k√∂nnen einen Bootstrap-Punktsch√§tzer des Behandlungseffekts (Stichprobenmittel der Bootstrap-Sch√§tzungen) sowie Standardfehler (Standardabweichung der der Bootstrap-Sch√§tzungen) und p-Werte berechnen.</p>
<p>Wir Implementieren nun einen Bootstrap-Sch√§tzer des ATT als <code>R</code>-Funktion <code>boot_fun()</code>.</p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>


<div id="qwebr-interactive-area-19" class="qwebr-interactive-area">
  <div id="qwebr-console-area-19" class="qwebr-console-area">
    <div id="qwebr-editor-19" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-19">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-19" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-19" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-19");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-19");
  const editorDiv = document.getElementById("qwebr-editor-19");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-19");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `boot_fun <- function(data, i) {
  
  boot_data <- data[i, ]
  
  # 1:1 PS Matching _mit_ Zur√ºcklegen
  match_res <- matchit(dark_mode ~ age + hours + male,
                       data = boot_data,
                       caliper = .25,
                       replace = TRUE) # Zur√ºcklegen
  
  # Gematchten Datensatz zuweisen
  darkmode_matched <- match.data(match_res, data = boot_data)
  
  # Outcome-Modell sch√§tzen
  ATT_mod <- lm(
    formula = read_time ~ age + male + hours + dark_mode,
    data = darkmode_matched, 
    weights = weights # hier teilweise > 1 wg. Matching mit Zur√ºcklegen!
  )
  
  #  ATT-Sch√§tzer auslesen
  return(
    ATT_mod$coefficients["dark_mode"]  
  )
}`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-19-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-19-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script>
<p>Abadie &amp; Imbens (2008) zeigen analytisch, dass ein Standard-Bootstrap bei Matching grunds√§tzlich ung√ºltig ist: Die unbekannte Varianz der Stichprobenverteilung des Matching-Sch√§tzers (und damit der Standardfehler des Sch√§tzers) kann durch den Bootstrap nicht repliziert werden. Problematisch hierbei sind grunds√§tzlich zu liberale (d.h. zu gro√üe) mit dem Bootstrap berechnete Standardfehler. Es gibt jedoch Simulationsnachweise die zeigen, dass Bootstrap-Standardfehler bei Matching mit Zur√ºcklegen konservativ sind (Bodory et al., 2020), also tendentiell zu kleine Standardfehler produzieren und damit das gew√ºnschte nominale Signifikanzniveau eines Bootstrap-Hypothesentests nicht √ºberschritten wird.</p>
<p>Wir berechnen nun eine Bootstrap-Sch√§tzung des ATT von <code>dark_mode</code> auf <code>readingtime</code> sowie den zugeh√∂rigen Standardfehler und ein 95%-KI mit der zuvor definierten Funktion <code>boot_fun</code>.</p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>


<div id="qwebr-interactive-area-20" class="qwebr-interactive-area">
  <div id="qwebr-console-area-20" class="qwebr-console-area">
    <div id="qwebr-editor-20" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-20">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-20" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-20" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-20");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-20");
  const editorDiv = document.getElementById("qwebr-editor-20");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-20");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `library("boot")
set.seed(4321)
boot_out <- boot(darkmode, boot_fun, R = 999)

boot_out`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-20-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-20-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>


<div id="qwebr-interactive-area-21" class="qwebr-interactive-area">
  <div id="qwebr-console-area-21" class="qwebr-console-area">
    <div id="qwebr-editor-21" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-21">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-21" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-21" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-21");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-21");
  const editorDiv = document.getElementById("qwebr-editor-21");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-21");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `# Bootstrap-Sch√§tzer f√ºr den Treatment-Effekt
mean(boot_out$t) 
# = mean(t0) + bias = mean(Bootstrap_samples)
# vgl. 't0 = boot_fun(darkmode, i = 1:1e3)'

# Bootstrap-Standardfehler
sd(boot_out$t)

# 95% Bootstrap-KI f√ºr den Treatment-Effekt
boot.ci(boot_out, type = "perc")`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-21-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-21-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script>
</section>
<section id="doubly-robust-sch√§tzer-f√ºr-attate" class="level2" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="doubly-robust-sch√§tzer-f√ºr-attate"><span class="header-section-number">3.3</span> Doubly-Robust-Sch√§tzer f√ºr ATT/ATE</h2>
<p>Implementieren und berechnen Sie einen Doubly-Robust-Sch√§tzer des ATT (vgl. Wooldridge, 2010) f√ºr den kausalen Effekt in Aufgabe 5. Vergleichen Sie mit den Ergebnissen der Aufgaben 1 (d), 4 (f) und 5 (d).</p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>


<div id="qwebr-interactive-area-22" class="qwebr-interactive-area">
  <div id="qwebr-console-area-22" class="qwebr-console-area">
    <div id="qwebr-editor-22" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-22">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-22" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-22" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-22");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-22");
  const editorDiv = document.getElementById("qwebr-editor-22");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-22");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `# IPW estimation with regression adjustment
ipwra <- function(br, index = 1:nrow(br)) {
    # slice bootstrapped observations
    br <- br %>% slice(index)
    
    # estimate and predict propensity score
    m <- glm(formula = dark_mode ~ age + hours + male,
             data = br, 
             family = binomial(link = 'logit'))
    
    br <- br %>%
        mutate(ps = predict(m, type = 'response'))
    
    # trim control observations outside of treated PS range
    minps <- br %>%
        filter(dark_mode == 1) %>%
        pull(ps) %>%
        min(na.rm = TRUE)
    
    maxps <- br %>%
        filter(dark_mode == 1) %>%
        pull(ps) %>%
        max(na.rm = TRUE)
    
    # do the trimming
    br <- br %>%
        filter(ps >= minps & ps <= maxps)
    
    # compute IPWs
    br <- br %>%
      mutate(
        ipw = case_when(
          dark_mode == 1 ~ 1 / ps,
          dark_mode == 0 ~ 1 / (1 - ps))
      )
    
    # Simple _ATT_ estimate:
    # w_means <- br %>%
    #     group_by(dark_mode) %>%
    #     summarize(m = weighted.mean(read_time, w = ipw)) %>% 
    #     arrange(dark_mode)
    # 
    # # simple diff-in-means _ATT_ estimate
    #  return(w_means$m[2] - w_means$m[1]) 
    
    # Do regression adjustment for _ATE_ estimate
    # TE prediction for whole sample based on TG model
    mtreat <- br %>%
      filter(dark_mode == 1) %>%
      lm(read_time ~ 1 + age + hours + male, data = ., weights = .$ipw) %>%
      predict(newdata = br) %>%
      mean()
    
    # TE prediction for whole sample based on CG model
    mcont <- br %>%
      filter(dark_mode == 0) %>%
      lm(read_time ~ 1 + age + hours + male, data = ., weights = .$ipw) %>%
      predict(newdata = br) %>%
      mean()

    return(mtreat - mcont) # Regression adjusted _ATE_ estimate
}`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-22-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-22-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>


<div id="qwebr-interactive-area-23" class="qwebr-interactive-area">
  <div id="qwebr-console-area-23" class="qwebr-console-area">
    <div id="qwebr-editor-23" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-23">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-23" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-23" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-23");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-23");
  const editorDiv = document.getElementById("qwebr-editor-23");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-23");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `b <- boot(data = darkmode, ipwra, R = 999)
# Bootstrap estimate and standard error
mean(b$t)
sd(b$t)`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-23-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-23-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script>
</section>
<section id="literatur" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Literatur</h1>
<p>Abadie, Alberto, and Guido W. Imbens. (2008). <em>On the Failure of the Bootstrap for Matching Estimators.</em>Econometrica 76 (<strong>6</strong>): 1537‚Äì57.</p>
<p>Bodory, H., Camponovo, L., Huber, M., &amp; Lechner, M. (2020). <em>The Finite Sample Performance of Inference Methods for Propensity Score Matching and Weighting Estimators</em>. Journal of Business &amp; Economic Statistics, 38(<strong>1</strong>), 183‚Äì200.</p>
<p>Wooldridge, J. M. (2010). <em>Econometric analysis of cross section and panel data</em>. MIT press.</p>


<!-- -->

</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "Óßã";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Kopiert");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Kopiert");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./R_Einfuehrung.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Statistische Programmierung mit R</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./RDD.html" class="pagination-link">
        <span class="nav-page-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Regression Discontiniuty Designs</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Quellcode</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb1" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="an">webr:</span><span class="co"> </span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">  show-startup-message: true</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co">  packages: [</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co">            'boot', </span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co">            'cobalt', </span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co">            'marginaleffects', </span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="co">            'MatchIt', </span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="co">            'sandwich',</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="co">            'tidyverse'</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="co">            ]</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="fu"># Matching</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="in">#| context: setup</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="in"># create dataset directory</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="in">dir.create("datasets")</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="in"># Download the dataset</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a><span class="in">download.file(</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a><span class="in">    "https://raw.githubusercontent.com/mca91/kasa_data/main/darkmode.csv",</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a><span class="in">    'datasets/darkmode.csv'</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a><span class="in">)</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a><span class="fu">## Einfluss von Darkmode auf Blog-Lesezeit</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a><span class="in">```{dot}</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>//| fig<span class="ot">-w</span>idth: <span class="dv">4</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>//| fig-height: <span class="dv">3</span></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>//| fig-align: <span class="ot">'</span><span class="ss">center</span><span class="ot">'</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>//| fig<span class="ot">-c</span>ap: <span class="ot">"</span><span class="st">Geschlecht ist Backdoor-Pfad</span><span class="ot">"</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>//| label: <span class="ot">"</span><span class="st">fig-CDdarkmode</span><span class="ot">"</span> </span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>digraph {</span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>  layout=neato</span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>  fontname=<span class="ot">"</span><span class="st">Helvetica,Arial,sans-serif</span><span class="ot">"</span></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>  node [fontname=<span class="ot">"</span><span class="st">Helvetica,Arial,sans-serif</span><span class="ot">"</span>]</span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>  edge [fontname=<span class="ot">"</span><span class="st">Helvetica,Arial,sans-serif</span><span class="ot">"</span>]</span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>  node [shape=none];</span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>  <span class="ot">"</span><span class="st">read_time</span><span class="ot">"</span> [<span class="fu">pos</span>=<span class="ot">"</span><span class="st">4,1!</span><span class="ot">"</span>, fontname=<span class="ot">"</span><span class="st">Helvetica,Arial,mono</span><span class="ot">"</span>]</span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>  <span class="ot">"</span><span class="st">dark_mode</span><span class="ot">"</span> [<span class="fu">pos</span>=<span class="ot">"</span><span class="st">0,1!</span><span class="ot">"</span>]</span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>  <span class="ot">"</span><span class="st">male</span><span class="ot">"</span> [<span class="fu">pos</span>=<span class="ot">"</span><span class="st">2,-1!</span><span class="ot">"</span>]</span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>  <span class="ot">"</span><span class="st">dark_mode</span><span class="ot">"</span> -&gt; <span class="ot">"</span><span class="st">read_time</span><span class="ot">"</span></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>  <span class="ot">"</span><span class="st">male</span><span class="ot">"</span> -&gt; <span class="ot">"</span><span class="st">dark_mode</span><span class="ot">"</span></span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a>  <span class="ot">"</span><span class="st">male</span><span class="ot">"</span> -&gt; <span class="ot">"</span><span class="st">read_time</span><span class="ot">"</span></span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>Wir lesen zun√§chst den Datensatz *darkmode.csv* ein und verschaffen uns einen √úberblick √ºber die verf√ºgbaren Variablen. </span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a><span class="in">library(tidyverse)</span></span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a><span class="in"># Datensatz 'darkmode' einlesen</span></span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a><span class="in">darkmode &lt;- read_csv(</span></span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a><span class="in">  file = "datasets/darkmode.csv", </span></span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a><span class="in">  show_col_types = F</span></span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a><span class="in">)</span></span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a><span class="in"># √úberblick verschaffen</span></span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a><span class="in">glimpse(darkmode)</span></span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true" tabindex="-1"></a><span class="in">`dark_mode`</span> hat den Typ <span class="in">`logical`</span>. Mit <span class="in">`dplyr::mutate_all()`</span> k√∂nnen wir komfortabel alle Spalten in den Typ <span class="in">`numeric`</span> transformieren.</span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-69"><a href="#cb1-69" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb1-70"><a href="#cb1-70" aria-hidden="true" tabindex="-1"></a><span class="in"># Alle Variablen zu typ 'numeric' formatieren...</span></span>
<span id="cb1-71"><a href="#cb1-71" aria-hidden="true" tabindex="-1"></a><span class="in">darkmode &lt;- darkmode %&gt;% </span></span>
<span id="cb1-72"><a href="#cb1-72" aria-hidden="true" tabindex="-1"></a><span class="in">  mutate_all(.funs = as.numeric)</span></span>
<span id="cb1-73"><a href="#cb1-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-74"><a href="#cb1-74" aria-hidden="true" tabindex="-1"></a><span class="in"># ... und √ºberpr√ºfen</span></span>
<span id="cb1-75"><a href="#cb1-75" aria-hidden="true" tabindex="-1"></a><span class="in">glimpse(darkmode)</span></span>
<span id="cb1-76"><a href="#cb1-76" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb1-77"><a href="#cb1-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-80"><a href="#cb1-80" aria-hidden="true" tabindex="-1"></a><span class="in">```{dot}</span></span>
<span id="cb1-81"><a href="#cb1-81" aria-hidden="true" tabindex="-1"></a>//| fig<span class="ot">-w</span>idth: <span class="dv">4</span></span>
<span id="cb1-82"><a href="#cb1-82" aria-hidden="true" tabindex="-1"></a>//| fig-height: <span class="dv">3</span></span>
<span id="cb1-83"><a href="#cb1-83" aria-hidden="true" tabindex="-1"></a>//| fig-align: <span class="ot">'</span><span class="ss">center</span><span class="ot">'</span></span>
<span id="cb1-84"><a href="#cb1-84" aria-hidden="true" tabindex="-1"></a>//| fig<span class="ot">-c</span>ap: <span class="ot">"</span><span class="st">M√∂glicher DGP als Kausales Diagramm</span><span class="ot">"</span></span>
<span id="cb1-85"><a href="#cb1-85" aria-hidden="true" tabindex="-1"></a>//| label: <span class="ot">"</span><span class="st">fig-CDdarkmode2</span><span class="ot">"</span> </span>
<span id="cb1-86"><a href="#cb1-86" aria-hidden="true" tabindex="-1"></a>digraph {</span>
<span id="cb1-87"><a href="#cb1-87" aria-hidden="true" tabindex="-1"></a>  layout=neato</span>
<span id="cb1-88"><a href="#cb1-88" aria-hidden="true" tabindex="-1"></a>  fontname=<span class="ot">"</span><span class="st">Helvetica,Arial,sans-serif</span><span class="ot">"</span></span>
<span id="cb1-89"><a href="#cb1-89" aria-hidden="true" tabindex="-1"></a>  node [fontname=<span class="ot">"</span><span class="st">Helvetica,Arial,sans-serif</span><span class="ot">"</span>]</span>
<span id="cb1-90"><a href="#cb1-90" aria-hidden="true" tabindex="-1"></a>  edge [fontname=<span class="ot">"</span><span class="st">Helvetica,Arial,sans-serif</span><span class="ot">"</span>]</span>
<span id="cb1-91"><a href="#cb1-91" aria-hidden="true" tabindex="-1"></a>  node [shape=none];</span>
<span id="cb1-92"><a href="#cb1-92" aria-hidden="true" tabindex="-1"></a>  <span class="ot">"</span><span class="st">age</span><span class="ot">"</span> [<span class="fu">pos</span>=<span class="ot">"</span><span class="st">0,2!</span><span class="ot">"</span>]</span>
<span id="cb1-93"><a href="#cb1-93" aria-hidden="true" tabindex="-1"></a>  <span class="ot">"</span><span class="st">read_time</span><span class="ot">"</span> [<span class="fu">pos</span>=<span class="ot">"</span><span class="st">4,1!</span><span class="ot">"</span>, fontname=<span class="ot">"</span><span class="st">Helvetica,Arial,mono</span><span class="ot">"</span>]</span>
<span id="cb1-94"><a href="#cb1-94" aria-hidden="true" tabindex="-1"></a>  <span class="ot">"</span><span class="st">dark_mode</span><span class="ot">"</span> [<span class="fu">pos</span>=<span class="ot">"</span><span class="st">0,1!</span><span class="ot">"</span>]</span>
<span id="cb1-95"><a href="#cb1-95" aria-hidden="true" tabindex="-1"></a>  <span class="ot">"</span><span class="st">hours</span><span class="ot">"</span> [<span class="fu">pos</span>=<span class="ot">"</span><span class="st">4,2!</span><span class="ot">"</span>]</span>
<span id="cb1-96"><a href="#cb1-96" aria-hidden="true" tabindex="-1"></a>  <span class="ot">"</span><span class="st">male</span><span class="ot">"</span> [<span class="fu">pos</span>=<span class="ot">"</span><span class="st">2,-1!</span><span class="ot">"</span>]</span>
<span id="cb1-97"><a href="#cb1-97" aria-hidden="true" tabindex="-1"></a>  <span class="ot">"</span><span class="st">age</span><span class="ot">"</span> -&gt; <span class="ot">"</span><span class="st">dark_mode</span><span class="ot">"</span></span>
<span id="cb1-98"><a href="#cb1-98" aria-hidden="true" tabindex="-1"></a>  <span class="ot">"</span><span class="st">dark_mode</span><span class="ot">"</span> -&gt; <span class="ot">"</span><span class="st">read_time</span><span class="ot">"</span></span>
<span id="cb1-99"><a href="#cb1-99" aria-hidden="true" tabindex="-1"></a>  <span class="ot">"</span><span class="st">hours</span><span class="ot">"</span> -&gt; <span class="ot">"</span><span class="st">read_time</span><span class="ot">"</span></span>
<span id="cb1-100"><a href="#cb1-100" aria-hidden="true" tabindex="-1"></a>  <span class="ot">"</span><span class="st">male</span><span class="ot">"</span> -&gt; <span class="ot">"</span><span class="st">dark_mode</span><span class="ot">"</span></span>
<span id="cb1-101"><a href="#cb1-101" aria-hidden="true" tabindex="-1"></a>  <span class="ot">"</span><span class="st">male</span><span class="ot">"</span> -&gt; <span class="ot">"</span><span class="st">read_time</span><span class="ot">"</span></span>
<span id="cb1-102"><a href="#cb1-102" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb1-103"><a href="#cb1-103" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb1-104"><a href="#cb1-104" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-105"><a href="#cb1-105" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb1-106"><a href="#cb1-106" aria-hidden="true" tabindex="-1"></a><span class="in"># Logit-Modell mit 'glm()' sch√§tzen</span></span>
<span id="cb1-107"><a href="#cb1-107" aria-hidden="true" tabindex="-1"></a><span class="in">(</span></span>
<span id="cb1-108"><a href="#cb1-108" aria-hidden="true" tabindex="-1"></a><span class="in">  darkmode_ps_logit &lt;- glm(</span></span>
<span id="cb1-109"><a href="#cb1-109" aria-hidden="true" tabindex="-1"></a><span class="in">    formula = dark_mode ~ age + male + hours,</span></span>
<span id="cb1-110"><a href="#cb1-110" aria-hidden="true" tabindex="-1"></a><span class="in">    data = darkmode,</span></span>
<span id="cb1-111"><a href="#cb1-111" aria-hidden="true" tabindex="-1"></a><span class="in">    family = binomial</span></span>
<span id="cb1-112"><a href="#cb1-112" aria-hidden="true" tabindex="-1"></a><span class="in">  )</span></span>
<span id="cb1-113"><a href="#cb1-113" aria-hidden="true" tabindex="-1"></a><span class="in">)</span></span>
<span id="cb1-114"><a href="#cb1-114" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb1-115"><a href="#cb1-115" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-116"><a href="#cb1-116" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb1-117"><a href="#cb1-117" aria-hidden="true" tabindex="-1"></a><span class="in"># Datensatz um propensity scores erweitern</span></span>
<span id="cb1-118"><a href="#cb1-118" aria-hidden="true" tabindex="-1"></a><span class="in">(</span></span>
<span id="cb1-119"><a href="#cb1-119" aria-hidden="true" tabindex="-1"></a><span class="in">  darkmode_probabilities &lt;- </span></span>
<span id="cb1-120"><a href="#cb1-120" aria-hidden="true" tabindex="-1"></a><span class="in">    darkmode %&gt;%</span></span>
<span id="cb1-121"><a href="#cb1-121" aria-hidden="true" tabindex="-1"></a><span class="in">    mutate(</span></span>
<span id="cb1-122"><a href="#cb1-122" aria-hidden="true" tabindex="-1"></a><span class="in">      propensity = fitted(darkmode_ps_logit)</span></span>
<span id="cb1-123"><a href="#cb1-123" aria-hidden="true" tabindex="-1"></a><span class="in">    )</span></span>
<span id="cb1-124"><a href="#cb1-124" aria-hidden="true" tabindex="-1"></a><span class="in">)</span></span>
<span id="cb1-125"><a href="#cb1-125" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb1-126"><a href="#cb1-126" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-127"><a href="#cb1-127" aria-hidden="true" tabindex="-1"></a>Inverse probability weights (IPWs) anhand der PS k√∂nnen schnell anhand der Vorschrift $$\texttt{ipw} = \texttt{dark<span class="sc">\_</span>mode} / \texttt{propensity} + (1 - \texttt{dark<span class="sc">\_</span>mode}) / (1 - \texttt{propensity}), \quad \texttt{dark<span class="sc">\_</span>mode} \in<span class="sc">\{</span>0,1<span class="sc">\}</span>$$</span>
<span id="cb1-128"><a href="#cb1-128" aria-hidden="true" tabindex="-1"></a>berechnet werden.</span>
<span id="cb1-129"><a href="#cb1-129" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-130"><a href="#cb1-130" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb1-131"><a href="#cb1-131" aria-hidden="true" tabindex="-1"></a><span class="in"># Datensatz um IPWs erweitern</span></span>
<span id="cb1-132"><a href="#cb1-132" aria-hidden="true" tabindex="-1"></a><span class="in">darkmode_ipw &lt;- darkmode_probabilities %&gt;%</span></span>
<span id="cb1-133"><a href="#cb1-133" aria-hidden="true" tabindex="-1"></a><span class="in">  mutate(</span></span>
<span id="cb1-134"><a href="#cb1-134" aria-hidden="true" tabindex="-1"></a><span class="in">    ipw = dark_mode / propensity + (1 - dark_mode) / (1 - propensity)</span></span>
<span id="cb1-135"><a href="#cb1-135" aria-hidden="true" tabindex="-1"></a><span class="in">  )</span></span>
<span id="cb1-136"><a href="#cb1-136" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-137"><a href="#cb1-137" aria-hidden="true" tabindex="-1"></a><span class="in">darkmode_ipw %&gt;% </span></span>
<span id="cb1-138"><a href="#cb1-138" aria-hidden="true" tabindex="-1"></a><span class="in">  select(ipw)</span></span>
<span id="cb1-139"><a href="#cb1-139" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb1-140"><a href="#cb1-140" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-141"><a href="#cb1-141" aria-hidden="true" tabindex="-1"></a>Verteilung der Propensity Scores nach Behandlungs-Indikator:</span>
<span id="cb1-142"><a href="#cb1-142" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-143"><a href="#cb1-143" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb1-144"><a href="#cb1-144" aria-hidden="true" tabindex="-1"></a><span class="in"># Dichtesch√§tzung der PS nach Treatment-Indikator</span></span>
<span id="cb1-145"><a href="#cb1-145" aria-hidden="true" tabindex="-1"></a><span class="in">darkmode_ipw %&gt;%</span></span>
<span id="cb1-146"><a href="#cb1-146" aria-hidden="true" tabindex="-1"></a><span class="in">ggplot(</span></span>
<span id="cb1-147"><a href="#cb1-147" aria-hidden="true" tabindex="-1"></a><span class="in">  mapping = aes(</span></span>
<span id="cb1-148"><a href="#cb1-148" aria-hidden="true" tabindex="-1"></a><span class="in">    x = propensity, </span></span>
<span id="cb1-149"><a href="#cb1-149" aria-hidden="true" tabindex="-1"></a><span class="in">    fill = factor(dark_mode))</span></span>
<span id="cb1-150"><a href="#cb1-150" aria-hidden="true" tabindex="-1"></a><span class="in">  ) + </span></span>
<span id="cb1-151"><a href="#cb1-151" aria-hidden="true" tabindex="-1"></a><span class="in">  lims(x = c(0, 1)) +</span></span>
<span id="cb1-152"><a href="#cb1-152" aria-hidden="true" tabindex="-1"></a><span class="in">  geom_density(alpha = .5, )</span></span>
<span id="cb1-153"><a href="#cb1-153" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb1-154"><a href="#cb1-154" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-155"><a href="#cb1-155" aria-hidden="true" tabindex="-1"></a>Beobachtungen aus der Kontroll-Gruppe entfernen, die au√üerhalb des Supports der Treatment-Gruppe liegen.</span>
<span id="cb1-156"><a href="#cb1-156" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-157"><a href="#cb1-157" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb1-158"><a href="#cb1-158" aria-hidden="true" tabindex="-1"></a><span class="in"># Propensity scores auslesen</span></span>
<span id="cb1-159"><a href="#cb1-159" aria-hidden="true" tabindex="-1"></a><span class="in">darkmode_ipws &lt;- darkmode_ipw %&gt;% </span></span>
<span id="cb1-160"><a href="#cb1-160" aria-hidden="true" tabindex="-1"></a><span class="in">  filter(dark_mode == 1) %&gt;% </span></span>
<span id="cb1-161"><a href="#cb1-161" aria-hidden="true" tabindex="-1"></a><span class="in">  pull(propensity)</span></span>
<span id="cb1-162"><a href="#cb1-162" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-163"><a href="#cb1-163" aria-hidden="true" tabindex="-1"></a><span class="in"># Support sicherstellen </span></span>
<span id="cb1-164"><a href="#cb1-164" aria-hidden="true" tabindex="-1"></a><span class="in"># (entfernt 13 Beobachtungen aus der Kontrollgruppe)</span></span>
<span id="cb1-165"><a href="#cb1-165" aria-hidden="true" tabindex="-1"></a><span class="in">darkmode_ipw &lt;- darkmode_ipw %&gt;% </span></span>
<span id="cb1-166"><a href="#cb1-166" aria-hidden="true" tabindex="-1"></a><span class="in">  filter(</span></span>
<span id="cb1-167"><a href="#cb1-167" aria-hidden="true" tabindex="-1"></a><span class="in">    between(</span></span>
<span id="cb1-168"><a href="#cb1-168" aria-hidden="true" tabindex="-1"></a><span class="in">      propensity,</span></span>
<span id="cb1-169"><a href="#cb1-169" aria-hidden="true" tabindex="-1"></a><span class="in">      darkmode_ipws %&gt;% </span></span>
<span id="cb1-170"><a href="#cb1-170" aria-hidden="true" tabindex="-1"></a><span class="in">        min(),</span></span>
<span id="cb1-171"><a href="#cb1-171" aria-hidden="true" tabindex="-1"></a><span class="in">      darkmode_ipws %&gt;% </span></span>
<span id="cb1-172"><a href="#cb1-172" aria-hidden="true" tabindex="-1"></a><span class="in">        max()</span></span>
<span id="cb1-173"><a href="#cb1-173" aria-hidden="true" tabindex="-1"></a><span class="in">    )</span></span>
<span id="cb1-174"><a href="#cb1-174" aria-hidden="true" tabindex="-1"></a><span class="in">  )</span></span>
<span id="cb1-175"><a href="#cb1-175" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb1-176"><a href="#cb1-176" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-177"><a href="#cb1-177" aria-hidden="true" tabindex="-1"></a>Die Abdeckung k√∂nnen wir erneut mit einer Grafik gesch√§tzter Dichtefunktionen vergleichen.</span>
<span id="cb1-178"><a href="#cb1-178" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-179"><a href="#cb1-179" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb1-180"><a href="#cb1-180" aria-hidden="true" tabindex="-1"></a><span class="in"># Dichtesch√§tzung der PS per Treatment-Indikator nach Anpassung</span></span>
<span id="cb1-181"><a href="#cb1-181" aria-hidden="true" tabindex="-1"></a><span class="in">darkmode_ipw %&gt;%</span></span>
<span id="cb1-182"><a href="#cb1-182" aria-hidden="true" tabindex="-1"></a><span class="in">  ggplot(</span></span>
<span id="cb1-183"><a href="#cb1-183" aria-hidden="true" tabindex="-1"></a><span class="in">    mapping = aes(</span></span>
<span id="cb1-184"><a href="#cb1-184" aria-hidden="true" tabindex="-1"></a><span class="in">      x = propensity, </span></span>
<span id="cb1-185"><a href="#cb1-185" aria-hidden="true" tabindex="-1"></a><span class="in">      fill = factor(dark_mode)</span></span>
<span id="cb1-186"><a href="#cb1-186" aria-hidden="true" tabindex="-1"></a><span class="in">    )</span></span>
<span id="cb1-187"><a href="#cb1-187" aria-hidden="true" tabindex="-1"></a><span class="in">  ) + </span></span>
<span id="cb1-188"><a href="#cb1-188" aria-hidden="true" tabindex="-1"></a><span class="in">  lims(x = c(0, 1)) +</span></span>
<span id="cb1-189"><a href="#cb1-189" aria-hidden="true" tabindex="-1"></a><span class="in">  geom_density(alpha = .5)</span></span>
<span id="cb1-190"><a href="#cb1-190" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb1-191"><a href="#cb1-191" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-192"><a href="#cb1-192" aria-hidden="true" tabindex="-1"></a>Wir finden etwas weniger Wahrscheinlichkeits-Masse nahe 0 f√ºr die Kontroll-Gruppe nach filtern von (Kontroll-)Beobachtungen mit PS in der Spannweite der PS in der Behandlungs-Gruppe. Als n√§chstes sch√§tzen wir den ATE mit linearer Regression.</span>
<span id="cb1-193"><a href="#cb1-193" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-194"><a href="#cb1-194" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb1-195"><a href="#cb1-195" aria-hidden="true" tabindex="-1"></a><span class="in"># Mit IPWs gewichteter KQ-Schaetzer berechnet einen ATE</span></span>
<span id="cb1-196"><a href="#cb1-196" aria-hidden="true" tabindex="-1"></a><span class="in">model_ipw &lt;- lm(</span></span>
<span id="cb1-197"><a href="#cb1-197" aria-hidden="true" tabindex="-1"></a><span class="in">  formula = read_time ~ dark_mode, </span></span>
<span id="cb1-198"><a href="#cb1-198" aria-hidden="true" tabindex="-1"></a><span class="in">  data = darkmode_ipw,</span></span>
<span id="cb1-199"><a href="#cb1-199" aria-hidden="true" tabindex="-1"></a><span class="in">  weights = ipw</span></span>
<span id="cb1-200"><a href="#cb1-200" aria-hidden="true" tabindex="-1"></a><span class="in">)</span></span>
<span id="cb1-201"><a href="#cb1-201" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-202"><a href="#cb1-202" aria-hidden="true" tabindex="-1"></a><span class="in">summary(model_ipw)</span></span>
<span id="cb1-203"><a href="#cb1-203" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb1-204"><a href="#cb1-204" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-205"><a href="#cb1-205" aria-hidden="true" tabindex="-1"></a>Unsere Sch√§tzung des ATE ist der gesch√§tzte Koeffizient von <span class="in">`dark_mode`</span>. Die ausgegebenen Standardfehler und Inferenzstatistiken sind *ung√ºltig* aufgrund der Gewichtung mit IPWs, inversen *gesch√§tzten*  Wahrscheinlichkeiten f√ºr eine Behandlung. Der Grund hierf√ºr ist, dass die Standardformel in <span class="in">`summary()`</span>  die zus√§tzliche Unsicherheit durch die IPW-Sch√§tzung nicht ber√ºcksichtigt!</span>
<span id="cb1-206"><a href="#cb1-206" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-207"><a href="#cb1-207" aria-hidden="true" tabindex="-1"></a>Die Vergleichbarkeit der Nutzer in Kontroll- und Behandlungsgruppe-Gruppe f√ºr die Variablen <span class="in">`age`</span>, <span class="in">`hours`</span> und <span class="in">`male`</span> k√∂nnen wir graphisch und anhand einer *balance table* vergleichen.</span>
<span id="cb1-208"><a href="#cb1-208" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-209"><a href="#cb1-209" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb1-210"><a href="#cb1-210" aria-hidden="true" tabindex="-1"></a><span class="in"># Dichtesch√§tzungen</span></span>
<span id="cb1-211"><a href="#cb1-211" aria-hidden="true" tabindex="-1"></a><span class="in">darkmode %&gt;% </span></span>
<span id="cb1-212"><a href="#cb1-212" aria-hidden="true" tabindex="-1"></a><span class="in">  group_by(dark_mode) %&gt;%</span></span>
<span id="cb1-213"><a href="#cb1-213" aria-hidden="true" tabindex="-1"></a><span class="in">  select(age, hours) %&gt;%</span></span>
<span id="cb1-214"><a href="#cb1-214" aria-hidden="true" tabindex="-1"></a><span class="in">  mutate_all(scale) %&gt;% # Standardisierung mit 'scale()'</span></span>
<span id="cb1-215"><a href="#cb1-215" aria-hidden="true" tabindex="-1"></a><span class="in">  pivot_longer(cols = c(-dark_mode)) %&gt;% # langes Format</span></span>
<span id="cb1-216"><a href="#cb1-216" aria-hidden="true" tabindex="-1"></a><span class="in">  </span></span>
<span id="cb1-217"><a href="#cb1-217" aria-hidden="true" tabindex="-1"></a><span class="in">  ggplot(aes(x = value, fill = as.factor(dark_mode))) +</span></span>
<span id="cb1-218"><a href="#cb1-218" aria-hidden="true" tabindex="-1"></a><span class="in">  geom_density( alpha = .5) + </span></span>
<span id="cb1-219"><a href="#cb1-219" aria-hidden="true" tabindex="-1"></a><span class="in">  facet_wrap(~ name, scales = "free", nrow = 3) # Facetting nach 'name'</span></span>
<span id="cb1-220"><a href="#cb1-220" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-221"><a href="#cb1-221" aria-hidden="true" tabindex="-1"></a><span class="in"># Relative Hfkt. f√ºr 'male' als barplot</span></span>
<span id="cb1-222"><a href="#cb1-222" aria-hidden="true" tabindex="-1"></a><span class="in">darkmode %&gt;% </span></span>
<span id="cb1-223"><a href="#cb1-223" aria-hidden="true" tabindex="-1"></a><span class="in">  group_by(dark_mode) %&gt;%</span></span>
<span id="cb1-224"><a href="#cb1-224" aria-hidden="true" tabindex="-1"></a><span class="in">  mutate(</span></span>
<span id="cb1-225"><a href="#cb1-225" aria-hidden="true" tabindex="-1"></a><span class="in">    male = as.factor(male), </span></span>
<span id="cb1-226"><a href="#cb1-226" aria-hidden="true" tabindex="-1"></a><span class="in">    dark_mode = as.factor(dark_mode)</span></span>
<span id="cb1-227"><a href="#cb1-227" aria-hidden="true" tabindex="-1"></a><span class="in">  ) %&gt;%</span></span>
<span id="cb1-228"><a href="#cb1-228" aria-hidden="true" tabindex="-1"></a><span class="in">  </span></span>
<span id="cb1-229"><a href="#cb1-229" aria-hidden="true" tabindex="-1"></a><span class="in">  ggplot(aes(x = dark_mode, fill = male)) +</span></span>
<span id="cb1-230"><a href="#cb1-230" aria-hidden="true" tabindex="-1"></a><span class="in">  geom_bar(position = "fill") +</span></span>
<span id="cb1-231"><a href="#cb1-231" aria-hidden="true" tabindex="-1"></a><span class="in">  ylab("Anteil")</span></span>
<span id="cb1-232"><a href="#cb1-232" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-233"><a href="#cb1-233" aria-hidden="true" tabindex="-1"></a><span class="in"># Balance table mit 'cobalt::bal.tab()'</span></span>
<span id="cb1-234"><a href="#cb1-234" aria-hidden="true" tabindex="-1"></a><span class="in">bal.tab(</span></span>
<span id="cb1-235"><a href="#cb1-235" aria-hidden="true" tabindex="-1"></a><span class="in">  x = darkmode %&gt;% </span></span>
<span id="cb1-236"><a href="#cb1-236" aria-hidden="true" tabindex="-1"></a><span class="in">    select(age, hours, male), </span></span>
<span id="cb1-237"><a href="#cb1-237" aria-hidden="true" tabindex="-1"></a><span class="in">  treat = darkmode$dark_mode, </span></span>
<span id="cb1-238"><a href="#cb1-238" aria-hidden="true" tabindex="-1"></a><span class="in">  disp = "m", # zeige zus√§tzlich Mittelwerte f√ºr C und T</span></span>
<span id="cb1-239"><a href="#cb1-239" aria-hidden="true" tabindex="-1"></a><span class="in">)</span></span>
<span id="cb1-240"><a href="#cb1-240" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb1-241"><a href="#cb1-241" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-242"><a href="#cb1-242" aria-hidden="true" tabindex="-1"></a>Wir zeigen als n√§chstes, wie <span class="in">`MatchIt::matchit()`</span> f√ºr Nearest-neighbor-Matching anhand der Regressoren <span class="in">`age`</span>, <span class="in">`hours`</span>, und <span class="in">`male`</span> in unterschiedlichen Varianten durchgef√ºhrt werden kann. </span>
<span id="cb1-243"><a href="#cb1-243" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-244"><a href="#cb1-244" aria-hidden="true" tabindex="-1"></a><span class="in">`MatchIt::matchit()`</span> f√ºhrt standardm√§√üig 1:1-Matching (ohne Zur√ºcklegen) von Beobachtungen der Treatment-Gruppe mit Beobachtungen der Kontrollgruppe druch. Das Objekt wird f√ºr eine Sch√§tzung des ATT mit einer geeigneten Funktionen vorbereitet, s. <span class="in">`?matchit`</span>, und hier insb. die Argumente <span class="in">`replace = F`</span>, <span class="in">`ratio = 1`</span> und <span class="in">`estimand = "ATT"`</span> f√ºr Details. </span>
<span id="cb1-245"><a href="#cb1-245" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-246"><a href="#cb1-246" aria-hidden="true" tabindex="-1"></a>Mit <span class="in">`cobalt::balt.tab()`</span> erhalten wir eine *balance table* f√ºr den gematchten Datensatz.</span>
<span id="cb1-247"><a href="#cb1-247" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-248"><a href="#cb1-248" aria-hidden="true" tabindex="-1"></a>**Exaktes Matching**</span>
<span id="cb1-249"><a href="#cb1-249" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-250"><a href="#cb1-250" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb1-251"><a href="#cb1-251" aria-hidden="true" tabindex="-1"></a><span class="in">res &lt;- matchit(</span></span>
<span id="cb1-252"><a href="#cb1-252" aria-hidden="true" tabindex="-1"></a><span class="in">  formula = dark_mode ~ age + male + hours, </span></span>
<span id="cb1-253"><a href="#cb1-253" aria-hidden="true" tabindex="-1"></a><span class="in">  data = darkmode, </span></span>
<span id="cb1-254"><a href="#cb1-254" aria-hidden="true" tabindex="-1"></a><span class="in">  method = "exact"</span></span>
<span id="cb1-255"><a href="#cb1-255" aria-hidden="true" tabindex="-1"></a><span class="in">)</span></span>
<span id="cb1-256"><a href="#cb1-256" aria-hidden="true" tabindex="-1"></a><span class="in">bal.tab(res)</span></span>
<span id="cb1-257"><a href="#cb1-257" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb1-258"><a href="#cb1-258" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-259"><a href="#cb1-259" aria-hidden="true" tabindex="-1"></a>**Eins-zu-Eins-Matching: Mahalanobis-Distanz**</span>
<span id="cb1-260"><a href="#cb1-260" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-261"><a href="#cb1-261" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb1-262"><a href="#cb1-262" aria-hidden="true" tabindex="-1"></a><span class="in">res &lt;- matchit(</span></span>
<span id="cb1-263"><a href="#cb1-263" aria-hidden="true" tabindex="-1"></a><span class="in">  formula = dark_mode ~ age + male + hours, </span></span>
<span id="cb1-264"><a href="#cb1-264" aria-hidden="true" tabindex="-1"></a><span class="in">  data = darkmode, </span></span>
<span id="cb1-265"><a href="#cb1-265" aria-hidden="true" tabindex="-1"></a><span class="in">  distance = "mahalanobis", </span></span>
<span id="cb1-266"><a href="#cb1-266" aria-hidden="true" tabindex="-1"></a><span class="in">  method = "nearest"</span></span>
<span id="cb1-267"><a href="#cb1-267" aria-hidden="true" tabindex="-1"></a><span class="in">)</span></span>
<span id="cb1-268"><a href="#cb1-268" aria-hidden="true" tabindex="-1"></a><span class="in">bal.tab(res)</span></span>
<span id="cb1-269"><a href="#cb1-269" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb1-270"><a href="#cb1-270" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-271"><a href="#cb1-271" aria-hidden="true" tabindex="-1"></a>**Eins-zu-Eins-Matching: Mahalanobis-Distanz mit Caliper 0.25 f√ºr propensity scores basierend auf logistischer Regression**</span>
<span id="cb1-272"><a href="#cb1-272" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-273"><a href="#cb1-273" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb1-274"><a href="#cb1-274" aria-hidden="true" tabindex="-1"></a><span class="in">res &lt;- matchit(</span></span>
<span id="cb1-275"><a href="#cb1-275" aria-hidden="true" tabindex="-1"></a><span class="in">  formula = dark_mode ~ age + male + hours, </span></span>
<span id="cb1-276"><a href="#cb1-276" aria-hidden="true" tabindex="-1"></a><span class="in">  data = darkmode, </span></span>
<span id="cb1-277"><a href="#cb1-277" aria-hidden="true" tabindex="-1"></a><span class="in">  distance = "glm", </span></span>
<span id="cb1-278"><a href="#cb1-278" aria-hidden="true" tabindex="-1"></a><span class="in">  caliper = .25,</span></span>
<span id="cb1-279"><a href="#cb1-279" aria-hidden="true" tabindex="-1"></a><span class="in">  mahvars = ~ age + male + hours</span></span>
<span id="cb1-280"><a href="#cb1-280" aria-hidden="true" tabindex="-1"></a><span class="in">)</span></span>
<span id="cb1-281"><a href="#cb1-281" aria-hidden="true" tabindex="-1"></a><span class="in"># (Nur K-Beobachtungen mit PS bei Caliper .25 kommen f√ºr MHD-Matching in betracht.)</span></span>
<span id="cb1-282"><a href="#cb1-282" aria-hidden="true" tabindex="-1"></a><span class="in">bal.tab(res)</span></span>
<span id="cb1-283"><a href="#cb1-283" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb1-284"><a href="#cb1-284" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-285"><a href="#cb1-285" aria-hidden="true" tabindex="-1"></a>**4. Eins-zu-Eins-Matching: Propensity scores basierend auf logistischer Regression mit Caliper 0.25**</span>
<span id="cb1-286"><a href="#cb1-286" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb1-287"><a href="#cb1-287" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb1-288"><a href="#cb1-288" aria-hidden="true" tabindex="-1"></a><span class="in">res &lt;- matchit(</span></span>
<span id="cb1-289"><a href="#cb1-289" aria-hidden="true" tabindex="-1"></a><span class="in">  formula = dark_mode ~ age + male + hours, </span></span>
<span id="cb1-290"><a href="#cb1-290" aria-hidden="true" tabindex="-1"></a><span class="in">  data = darkmode, </span></span>
<span id="cb1-291"><a href="#cb1-291" aria-hidden="true" tabindex="-1"></a><span class="in">  method = "nearest", </span></span>
<span id="cb1-292"><a href="#cb1-292" aria-hidden="true" tabindex="-1"></a><span class="in">  distance = "glm", </span></span>
<span id="cb1-293"><a href="#cb1-293" aria-hidden="true" tabindex="-1"></a><span class="in">  caliper = .25</span></span>
<span id="cb1-294"><a href="#cb1-294" aria-hidden="true" tabindex="-1"></a><span class="in">)</span></span>
<span id="cb1-295"><a href="#cb1-295" aria-hidden="true" tabindex="-1"></a><span class="in">bal.tab(res)</span></span>
<span id="cb1-296"><a href="#cb1-296" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb1-297"><a href="#cb1-297" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-298"><a href="#cb1-298" aria-hidden="true" tabindex="-1"></a>Die Vergleichbarkeit der Nutzer in Kontroll- und Treatment-Gruppe hinsichtlich der Variablen <span class="in">`age`</span>, <span class="in">`hours`</span> und <span class="in">`male`</span> k√∂nnen wir graphisch und anhand einer *balance table* vergleichen. Wir berechnen die balance table mit <span class="in">`cobalt::bal.tab()`</span> f√ºr den anhand von Variante 4 gematchten Datensatz.</span>
<span id="cb1-299"><a href="#cb1-299" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-300"><a href="#cb1-300" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb1-301"><a href="#cb1-301" aria-hidden="true" tabindex="-1"></a><span class="in">bal.tab(res, un = T, disp = "m")</span></span>
<span id="cb1-302"><a href="#cb1-302" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-303"><a href="#cb1-303" aria-hidden="true" tabindex="-1"></a><span class="in"># Der gematchte Datensatz enth√§lt Gewichte f√ºr die jeweilige </span></span>
<span id="cb1-304"><a href="#cb1-304" aria-hidden="true" tabindex="-1"></a><span class="in"># Subklasse zu denen die Beobachtungen geh√∂ren.</span></span>
<span id="cb1-305"><a href="#cb1-305" aria-hidden="true" tabindex="-1"></a><span class="in">#</span></span>
<span id="cb1-306"><a href="#cb1-306" aria-hidden="true" tabindex="-1"></a><span class="in"># Hier 1:1 matching _ohne_ Zur√ºcklegen, d.h. s√§mtliche</span></span>
<span id="cb1-307"><a href="#cb1-307" aria-hidden="true" tabindex="-1"></a><span class="in"># Gewichte sind 1 und wird m√ºssten diese nicht f√ºr nachfolgende </span></span>
<span id="cb1-308"><a href="#cb1-308" aria-hidden="true" tabindex="-1"></a><span class="in"># Aufrufe von avg comparisons ber√ºcksichtigen.</span></span>
<span id="cb1-309"><a href="#cb1-309" aria-hidden="true" tabindex="-1"></a><span class="in">darkmode_matched &lt;- match.data(res)</span></span>
<span id="cb1-310"><a href="#cb1-310" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-311"><a href="#cb1-311" aria-hidden="true" tabindex="-1"></a><span class="in">darkmode_matched %&gt;%</span></span>
<span id="cb1-312"><a href="#cb1-312" aria-hidden="true" tabindex="-1"></a><span class="in">  group_by(dark_mode) %&gt;%</span></span>
<span id="cb1-313"><a href="#cb1-313" aria-hidden="true" tabindex="-1"></a><span class="in">  select(age, hours) %&gt;%</span></span>
<span id="cb1-314"><a href="#cb1-314" aria-hidden="true" tabindex="-1"></a><span class="in">  mutate_all(scale) %&gt;%</span></span>
<span id="cb1-315"><a href="#cb1-315" aria-hidden="true" tabindex="-1"></a><span class="in">  pivot_longer(cols = c(-dark_mode)) %&gt;%</span></span>
<span id="cb1-316"><a href="#cb1-316" aria-hidden="true" tabindex="-1"></a><span class="in">  </span></span>
<span id="cb1-317"><a href="#cb1-317" aria-hidden="true" tabindex="-1"></a><span class="in">  ggplot(aes(x = value, fill = as.factor(dark_mode))) +</span></span>
<span id="cb1-318"><a href="#cb1-318" aria-hidden="true" tabindex="-1"></a><span class="in">  geom_density( alpha = .5) + </span></span>
<span id="cb1-319"><a href="#cb1-319" aria-hidden="true" tabindex="-1"></a><span class="in">  facet_wrap(~ name, scales = "free", nrow = 3)</span></span>
<span id="cb1-320"><a href="#cb1-320" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-321"><a href="#cb1-321" aria-hidden="true" tabindex="-1"></a><span class="in">darkmode_matched %&gt;% </span></span>
<span id="cb1-322"><a href="#cb1-322" aria-hidden="true" tabindex="-1"></a><span class="in">  group_by(dark_mode) %&gt;%</span></span>
<span id="cb1-323"><a href="#cb1-323" aria-hidden="true" tabindex="-1"></a><span class="in">  mutate(</span></span>
<span id="cb1-324"><a href="#cb1-324" aria-hidden="true" tabindex="-1"></a><span class="in">    male = as.factor(male), </span></span>
<span id="cb1-325"><a href="#cb1-325" aria-hidden="true" tabindex="-1"></a><span class="in">    dark_mode = as.factor(dark_mode)</span></span>
<span id="cb1-326"><a href="#cb1-326" aria-hidden="true" tabindex="-1"></a><span class="in">  ) %&gt;%</span></span>
<span id="cb1-327"><a href="#cb1-327" aria-hidden="true" tabindex="-1"></a><span class="in">  </span></span>
<span id="cb1-328"><a href="#cb1-328" aria-hidden="true" tabindex="-1"></a><span class="in">  ggplot(aes(x = dark_mode, fill = male)) +</span></span>
<span id="cb1-329"><a href="#cb1-329" aria-hidden="true" tabindex="-1"></a><span class="in">  geom_bar(position = "fill") +</span></span>
<span id="cb1-330"><a href="#cb1-330" aria-hidden="true" tabindex="-1"></a><span class="in">  ylab("Anteil")</span></span>
<span id="cb1-331"><a href="#cb1-331" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb1-332"><a href="#cb1-332" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-333"><a href="#cb1-333" aria-hidden="true" tabindex="-1"></a>Wir beobachten eine bessere Balance bei <span class="in">`age`</span> und <span class="in">`hours`</span>. Am wichtigsten: <span class="in">`gender`</span> (<span class="in">`male`</span>) ist nahezu ausgeglichen f√ºr Kontroll- und Treatment-Gruppe!</span>
<span id="cb1-334"><a href="#cb1-334" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-335"><a href="#cb1-335" aria-hidden="true" tabindex="-1"></a>Wir sch√§tzen nun den ATT von <span class="in">`dark_mode`</span> auf <span class="in">`read_time`</span> mit linearer Regression f√ºr den gematchten Datensatz aus sowie f√ºr den urspr√ºnglichen Datensatz und berechnen jeweils ein robustes 95%-Konfidenzintervall f√ºr den ATT.</span>
<span id="cb1-336"><a href="#cb1-336" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-337"><a href="#cb1-337" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb1-338"><a href="#cb1-338" aria-hidden="true" tabindex="-1"></a><span class="in"># ATT mit linearem Modell f√ºr ungematchten Datensatz sch√§tzen</span></span>
<span id="cb1-339"><a href="#cb1-339" aria-hidden="true" tabindex="-1"></a><span class="in">ATT_mod_org &lt;- lm(</span></span>
<span id="cb1-340"><a href="#cb1-340" aria-hidden="true" tabindex="-1"></a><span class="in">  formula = read_time ~ age + male + hours + dark_mode,</span></span>
<span id="cb1-341"><a href="#cb1-341" aria-hidden="true" tabindex="-1"></a><span class="in">  data = darkmode</span></span>
<span id="cb1-342"><a href="#cb1-342" aria-hidden="true" tabindex="-1"></a><span class="in">)</span></span>
<span id="cb1-343"><a href="#cb1-343" aria-hidden="true" tabindex="-1"></a><span class="in">summary(ATT_mod_org)</span></span>
<span id="cb1-344"><a href="#cb1-344" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-345"><a href="#cb1-345" aria-hidden="true" tabindex="-1"></a><span class="in"># ATT mit linearem Modell f√ºr gematchten Datensatz sch√§tzen</span></span>
<span id="cb1-346"><a href="#cb1-346" aria-hidden="true" tabindex="-1"></a><span class="in">ATT_mod &lt;- lm(</span></span>
<span id="cb1-347"><a href="#cb1-347" aria-hidden="true" tabindex="-1"></a><span class="in">  formula = read_time ~ age + male + hours + dark_mode,</span></span>
<span id="cb1-348"><a href="#cb1-348" aria-hidden="true" tabindex="-1"></a><span class="in">  data = darkmode_matched, </span></span>
<span id="cb1-349"><a href="#cb1-349" aria-hidden="true" tabindex="-1"></a><span class="in">  weights = weights </span></span>
<span id="cb1-350"><a href="#cb1-350" aria-hidden="true" tabindex="-1"></a><span class="in">)</span></span>
<span id="cb1-351"><a href="#cb1-351" aria-hidden="true" tabindex="-1"></a><span class="in"># (weights = 1 f√ºr alle Beobachtungen weil wg. 1:1-Matching</span></span>
<span id="cb1-352"><a href="#cb1-352" aria-hidden="true" tabindex="-1"></a><span class="in"># nur 2er-Paare von Beobachtungen. Hier also vernachl√§ssigbar.</span></span>
<span id="cb1-353"><a href="#cb1-353" aria-hidden="true" tabindex="-1"></a><span class="in"># Andere Gewichtung bei k:1-Matching!)</span></span>
<span id="cb1-354"><a href="#cb1-354" aria-hidden="true" tabindex="-1"></a><span class="in">summary(ATT_mod)</span></span>
<span id="cb1-355"><a href="#cb1-355" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb1-356"><a href="#cb1-356" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-357"><a href="#cb1-357" aria-hidden="true" tabindex="-1"></a>**Achtung**: F√ºr Matching-Verfahren (<span class="in">`ATT_mod`</span>) sind die von <span class="in">`summary()`</span> berechneten Standardfehler (und damit KI, t-Statistiken und p-Werte) f√ºr den ATT *grunds√§tzlich ung√ºltig* Wir haben 3 Quellen von Sch√§tzunsicherheit, die bei der Berechnung von Standardfehlern ber√ºcksichtigt werden m√ºssen: Die Sch√§tzung der PS, der Matching-Prozess und die "√ºbliche" Stichproben-Variabilit√§t. Wir nutzen daher nachfolgende Funktionen gem. Empfehlungen aus der aktuellen Forschung f√ºr Standardfehlerberechnung. S. auch Aufgabe 5 (a).</span>
<span id="cb1-358"><a href="#cb1-358" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-359"><a href="#cb1-359" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb1-360"><a href="#cb1-360" aria-hidden="true" tabindex="-1"></a><span class="in">library(marginaleffects)</span></span>
<span id="cb1-361"><a href="#cb1-361" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-362"><a href="#cb1-362" aria-hidden="true" tabindex="-1"></a><span class="in"># Inferenz Multiple Regression bei ungematchten Beobachtungen</span></span>
<span id="cb1-363"><a href="#cb1-363" aria-hidden="true" tabindex="-1"></a><span class="in"># identisch zu 'coeftest(ATT_mod_org, vcovHC, type = "HC3")'</span></span>
<span id="cb1-364"><a href="#cb1-364" aria-hidden="true" tabindex="-1"></a><span class="in">avg_comparisons(</span></span>
<span id="cb1-365"><a href="#cb1-365" aria-hidden="true" tabindex="-1"></a><span class="in">  model = ATT_mod_org,</span></span>
<span id="cb1-366"><a href="#cb1-366" aria-hidden="true" tabindex="-1"></a><span class="in">  variables = "dark_mode",</span></span>
<span id="cb1-367"><a href="#cb1-367" aria-hidden="true" tabindex="-1"></a><span class="in">  vcov = "HC3", # Heteroskedastie-robuster SE</span></span>
<span id="cb1-368"><a href="#cb1-368" aria-hidden="true" tabindex="-1"></a><span class="in">  newdata = subset(darkmode, dark_mode == 1) # Identifiziert Kontrollgruppe</span></span>
<span id="cb1-369"><a href="#cb1-369" aria-hidden="true" tabindex="-1"></a><span class="in">) </span></span>
<span id="cb1-370"><a href="#cb1-370" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-371"><a href="#cb1-371" aria-hidden="true" tabindex="-1"></a><span class="in"># Inferenz Multiple Regression bei _gematchten_ Beobachtungen</span></span>
<span id="cb1-372"><a href="#cb1-372" aria-hidden="true" tabindex="-1"></a><span class="in">avg_comparisons(</span></span>
<span id="cb1-373"><a href="#cb1-373" aria-hidden="true" tabindex="-1"></a><span class="in">  model = ATT_mod,</span></span>
<span id="cb1-374"><a href="#cb1-374" aria-hidden="true" tabindex="-1"></a><span class="in">  variables = "dark_mode",</span></span>
<span id="cb1-375"><a href="#cb1-375" aria-hidden="true" tabindex="-1"></a><span class="in">  vcov = ~subclass, # cluster robust SE &gt; als oben =&gt; mehr Unsicherheit</span></span>
<span id="cb1-376"><a href="#cb1-376" aria-hidden="true" tabindex="-1"></a><span class="in">  newdata = subset(darkmode_matched, dark_mode == 1),</span></span>
<span id="cb1-377"><a href="#cb1-377" aria-hidden="true" tabindex="-1"></a><span class="in">  wts = "weights"  # = 1</span></span>
<span id="cb1-378"><a href="#cb1-378" aria-hidden="true" tabindex="-1"></a><span class="in">)</span></span>
<span id="cb1-379"><a href="#cb1-379" aria-hidden="true" tabindex="-1"></a><span class="in"># ( Weights = 1 wg. 1:1-Matching.</span></span>
<span id="cb1-380"><a href="#cb1-380" aria-hidden="true" tabindex="-1"></a><span class="in"># Anzahl subclasses = Anzahl gematchter treatment/control units )</span></span>
<span id="cb1-381"><a href="#cb1-381" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb1-382"><a href="#cb1-382" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-383"><a href="#cb1-383" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-384"><a href="#cb1-384" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-385"><a href="#cb1-385" aria-hidden="true" tabindex="-1"></a><span class="fu">## Inferenz f√ºr ATT/ATE: Propensity-Score-Matching mit Bootstrap</span></span>
<span id="cb1-386"><a href="#cb1-386" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-387"><a href="#cb1-387" aria-hidden="true" tabindex="-1"></a>Bei Matching mit Zur√ºcklegen besteht zus√§tzliche Unsicherheit durch Zur√ºcklegen, d.h. Beobachtungen aus der Kontroll-Gruppe k√∂nnen mehrfach als Match f√ºr Beobachtungen aus der Treatment-Gruppe genutzt werden. Mit <span class="in">`summary()`</span> berechnete Standardfehler ber√ºcksichtigen dies nicht!</span>
<span id="cb1-388"><a href="#cb1-388" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-389"><a href="#cb1-389" aria-hidden="true" tabindex="-1"></a>Ein Bootstrap-Verfahren generiert mit Resampling (wiederholtes Ziehen mit Zur√ºcklegen) aus dem Original-Datensatz (viele) k√ºnstliche Datens√§tze, f√ºr die der Sch√§tzer (d.h. das gesamte Verfahren inkl. Matching!) jeweils berechnet wird. Die Verteilung der so gewonnenen Bootstrap-Sch√§tzwerte approximiert die wahre, unbekannte Stichprobenverteilung des Sch√§tzers des Behandlungseffekts. Mit dieser simulierten Verteilung k√∂nnen wir Inferenz betreiben: Wir k√∂nnen einen Bootstrap-Punktsch√§tzer des Behandlungseffekts (Stichprobenmittel der Bootstrap-Sch√§tzungen) sowie Standardfehler (Standardabweichung der der Bootstrap-Sch√§tzungen) und p-Werte berechnen.</span>
<span id="cb1-390"><a href="#cb1-390" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-391"><a href="#cb1-391" aria-hidden="true" tabindex="-1"></a>Wir Implementieren nun einen Bootstrap-Sch√§tzer des ATT als <span class="in">`R`</span>-Funktion <span class="in">`boot_fun()`</span>.</span>
<span id="cb1-392"><a href="#cb1-392" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-393"><a href="#cb1-393" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb1-394"><a href="#cb1-394" aria-hidden="true" tabindex="-1"></a><span class="in">boot_fun &lt;- function(data, i) {</span></span>
<span id="cb1-395"><a href="#cb1-395" aria-hidden="true" tabindex="-1"></a><span class="in">  </span></span>
<span id="cb1-396"><a href="#cb1-396" aria-hidden="true" tabindex="-1"></a><span class="in">  boot_data &lt;- data[i, ]</span></span>
<span id="cb1-397"><a href="#cb1-397" aria-hidden="true" tabindex="-1"></a><span class="in">  </span></span>
<span id="cb1-398"><a href="#cb1-398" aria-hidden="true" tabindex="-1"></a><span class="in">  # 1:1 PS Matching _mit_ Zur√ºcklegen</span></span>
<span id="cb1-399"><a href="#cb1-399" aria-hidden="true" tabindex="-1"></a><span class="in">  match_res &lt;- matchit(dark_mode ~ age + hours + male,</span></span>
<span id="cb1-400"><a href="#cb1-400" aria-hidden="true" tabindex="-1"></a><span class="in">                       data = boot_data,</span></span>
<span id="cb1-401"><a href="#cb1-401" aria-hidden="true" tabindex="-1"></a><span class="in">                       caliper = .25,</span></span>
<span id="cb1-402"><a href="#cb1-402" aria-hidden="true" tabindex="-1"></a><span class="in">                       replace = TRUE) # Zur√ºcklegen</span></span>
<span id="cb1-403"><a href="#cb1-403" aria-hidden="true" tabindex="-1"></a><span class="in">  </span></span>
<span id="cb1-404"><a href="#cb1-404" aria-hidden="true" tabindex="-1"></a><span class="in">  # Gematchten Datensatz zuweisen</span></span>
<span id="cb1-405"><a href="#cb1-405" aria-hidden="true" tabindex="-1"></a><span class="in">  darkmode_matched &lt;- match.data(match_res, data = boot_data)</span></span>
<span id="cb1-406"><a href="#cb1-406" aria-hidden="true" tabindex="-1"></a><span class="in">  </span></span>
<span id="cb1-407"><a href="#cb1-407" aria-hidden="true" tabindex="-1"></a><span class="in">  # Outcome-Modell sch√§tzen</span></span>
<span id="cb1-408"><a href="#cb1-408" aria-hidden="true" tabindex="-1"></a><span class="in">  ATT_mod &lt;- lm(</span></span>
<span id="cb1-409"><a href="#cb1-409" aria-hidden="true" tabindex="-1"></a><span class="in">    formula = read_time ~ age + male + hours + dark_mode,</span></span>
<span id="cb1-410"><a href="#cb1-410" aria-hidden="true" tabindex="-1"></a><span class="in">    data = darkmode_matched, </span></span>
<span id="cb1-411"><a href="#cb1-411" aria-hidden="true" tabindex="-1"></a><span class="in">    weights = weights # hier teilweise &gt; 1 wg. Matching mit Zur√ºcklegen!</span></span>
<span id="cb1-412"><a href="#cb1-412" aria-hidden="true" tabindex="-1"></a><span class="in">  )</span></span>
<span id="cb1-413"><a href="#cb1-413" aria-hidden="true" tabindex="-1"></a><span class="in">  </span></span>
<span id="cb1-414"><a href="#cb1-414" aria-hidden="true" tabindex="-1"></a><span class="in">  #  ATT-Sch√§tzer auslesen</span></span>
<span id="cb1-415"><a href="#cb1-415" aria-hidden="true" tabindex="-1"></a><span class="in">  return(</span></span>
<span id="cb1-416"><a href="#cb1-416" aria-hidden="true" tabindex="-1"></a><span class="in">    ATT_mod$coefficients["dark_mode"]  </span></span>
<span id="cb1-417"><a href="#cb1-417" aria-hidden="true" tabindex="-1"></a><span class="in">  )</span></span>
<span id="cb1-418"><a href="#cb1-418" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb1-419"><a href="#cb1-419" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb1-420"><a href="#cb1-420" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-421"><a href="#cb1-421" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-422"><a href="#cb1-422" aria-hidden="true" tabindex="-1"></a>Abadie &amp; Imbens (2008) zeigen analytisch, dass ein Standard-Bootstrap bei Matching grunds√§tzlich ung√ºltig ist: Die unbekannte Varianz der Stichprobenverteilung des Matching-Sch√§tzers (und damit der Standardfehler des Sch√§tzers) kann durch den Bootstrap nicht repliziert werden. Problematisch hierbei sind grunds√§tzlich zu liberale (d.h. zu gro√üe) mit dem Bootstrap berechnete Standardfehler. Es gibt jedoch Simulationsnachweise die zeigen, dass Bootstrap-Standardfehler bei Matching mit Zur√ºcklegen konservativ sind (Bodory et al., 2020), also tendentiell zu kleine Standardfehler produzieren und damit das gew√ºnschte nominale Signifikanzniveau eines Bootstrap-Hypothesentests nicht √ºberschritten wird.</span>
<span id="cb1-423"><a href="#cb1-423" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-424"><a href="#cb1-424" aria-hidden="true" tabindex="-1"></a>Wir berechnen nun eine Bootstrap-Sch√§tzung des ATT von <span class="in">`dark_mode`</span> auf <span class="in">`readingtime`</span> sowie den zugeh√∂rigen Standardfehler und ein 95%-KI mit der zuvor definierten Funktion <span class="in">`boot_fun`</span>.</span>
<span id="cb1-425"><a href="#cb1-425" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-426"><a href="#cb1-426" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb1-427"><a href="#cb1-427" aria-hidden="true" tabindex="-1"></a><span class="in">library("boot")</span></span>
<span id="cb1-428"><a href="#cb1-428" aria-hidden="true" tabindex="-1"></a><span class="in">set.seed(4321)</span></span>
<span id="cb1-429"><a href="#cb1-429" aria-hidden="true" tabindex="-1"></a><span class="in">boot_out &lt;- boot(darkmode, boot_fun, R = 999)</span></span>
<span id="cb1-430"><a href="#cb1-430" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-431"><a href="#cb1-431" aria-hidden="true" tabindex="-1"></a><span class="in">boot_out</span></span>
<span id="cb1-432"><a href="#cb1-432" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb1-433"><a href="#cb1-433" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-434"><a href="#cb1-434" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb1-435"><a href="#cb1-435" aria-hidden="true" tabindex="-1"></a><span class="in"># Bootstrap-Sch√§tzer f√ºr den Treatment-Effekt</span></span>
<span id="cb1-436"><a href="#cb1-436" aria-hidden="true" tabindex="-1"></a><span class="in">mean(boot_out$t) </span></span>
<span id="cb1-437"><a href="#cb1-437" aria-hidden="true" tabindex="-1"></a><span class="in"># = mean(t0) + bias = mean(Bootstrap_samples)</span></span>
<span id="cb1-438"><a href="#cb1-438" aria-hidden="true" tabindex="-1"></a><span class="in"># vgl. 't0 = boot_fun(darkmode, i = 1:1e3)'</span></span>
<span id="cb1-439"><a href="#cb1-439" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-440"><a href="#cb1-440" aria-hidden="true" tabindex="-1"></a><span class="in"># Bootstrap-Standardfehler</span></span>
<span id="cb1-441"><a href="#cb1-441" aria-hidden="true" tabindex="-1"></a><span class="in">sd(boot_out$t)</span></span>
<span id="cb1-442"><a href="#cb1-442" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-443"><a href="#cb1-443" aria-hidden="true" tabindex="-1"></a><span class="in"># 95% Bootstrap-KI f√ºr den Treatment-Effekt</span></span>
<span id="cb1-444"><a href="#cb1-444" aria-hidden="true" tabindex="-1"></a><span class="in">boot.ci(boot_out, type = "perc")</span></span>
<span id="cb1-445"><a href="#cb1-445" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb1-446"><a href="#cb1-446" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-447"><a href="#cb1-447" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-448"><a href="#cb1-448" aria-hidden="true" tabindex="-1"></a><span class="fu">## Doubly-Robust-Sch√§tzer f√ºr ATT/ATE</span></span>
<span id="cb1-449"><a href="#cb1-449" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-450"><a href="#cb1-450" aria-hidden="true" tabindex="-1"></a>Implementieren und berechnen Sie einen Doubly-Robust-Sch√§tzer des ATT (vgl. Wooldridge, 2010) f√ºr den kausalen Effekt in Aufgabe 5. Vergleichen Sie mit den Ergebnissen der Aufgaben 1 (d), 4 (f) und 5 (d).</span>
<span id="cb1-451"><a href="#cb1-451" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-452"><a href="#cb1-452" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb1-453"><a href="#cb1-453" aria-hidden="true" tabindex="-1"></a><span class="in"># IPW estimation with regression adjustment</span></span>
<span id="cb1-454"><a href="#cb1-454" aria-hidden="true" tabindex="-1"></a><span class="in">ipwra &lt;- function(br, index = 1:nrow(br)) {</span></span>
<span id="cb1-455"><a href="#cb1-455" aria-hidden="true" tabindex="-1"></a><span class="in">    # slice bootstrapped observations</span></span>
<span id="cb1-456"><a href="#cb1-456" aria-hidden="true" tabindex="-1"></a><span class="in">    br &lt;- br %&gt;% slice(index)</span></span>
<span id="cb1-457"><a href="#cb1-457" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb1-458"><a href="#cb1-458" aria-hidden="true" tabindex="-1"></a><span class="in">    # estimate and predict propensity score</span></span>
<span id="cb1-459"><a href="#cb1-459" aria-hidden="true" tabindex="-1"></a><span class="in">    m &lt;- glm(formula = dark_mode ~ age + hours + male,</span></span>
<span id="cb1-460"><a href="#cb1-460" aria-hidden="true" tabindex="-1"></a><span class="in">             data = br, </span></span>
<span id="cb1-461"><a href="#cb1-461" aria-hidden="true" tabindex="-1"></a><span class="in">             family = binomial(link = 'logit'))</span></span>
<span id="cb1-462"><a href="#cb1-462" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb1-463"><a href="#cb1-463" aria-hidden="true" tabindex="-1"></a><span class="in">    br &lt;- br %&gt;%</span></span>
<span id="cb1-464"><a href="#cb1-464" aria-hidden="true" tabindex="-1"></a><span class="in">        mutate(ps = predict(m, type = 'response'))</span></span>
<span id="cb1-465"><a href="#cb1-465" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb1-466"><a href="#cb1-466" aria-hidden="true" tabindex="-1"></a><span class="in">    # trim control observations outside of treated PS range</span></span>
<span id="cb1-467"><a href="#cb1-467" aria-hidden="true" tabindex="-1"></a><span class="in">    minps &lt;- br %&gt;%</span></span>
<span id="cb1-468"><a href="#cb1-468" aria-hidden="true" tabindex="-1"></a><span class="in">        filter(dark_mode == 1) %&gt;%</span></span>
<span id="cb1-469"><a href="#cb1-469" aria-hidden="true" tabindex="-1"></a><span class="in">        pull(ps) %&gt;%</span></span>
<span id="cb1-470"><a href="#cb1-470" aria-hidden="true" tabindex="-1"></a><span class="in">        min(na.rm = TRUE)</span></span>
<span id="cb1-471"><a href="#cb1-471" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb1-472"><a href="#cb1-472" aria-hidden="true" tabindex="-1"></a><span class="in">    maxps &lt;- br %&gt;%</span></span>
<span id="cb1-473"><a href="#cb1-473" aria-hidden="true" tabindex="-1"></a><span class="in">        filter(dark_mode == 1) %&gt;%</span></span>
<span id="cb1-474"><a href="#cb1-474" aria-hidden="true" tabindex="-1"></a><span class="in">        pull(ps) %&gt;%</span></span>
<span id="cb1-475"><a href="#cb1-475" aria-hidden="true" tabindex="-1"></a><span class="in">        max(na.rm = TRUE)</span></span>
<span id="cb1-476"><a href="#cb1-476" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb1-477"><a href="#cb1-477" aria-hidden="true" tabindex="-1"></a><span class="in">    # do the trimming</span></span>
<span id="cb1-478"><a href="#cb1-478" aria-hidden="true" tabindex="-1"></a><span class="in">    br &lt;- br %&gt;%</span></span>
<span id="cb1-479"><a href="#cb1-479" aria-hidden="true" tabindex="-1"></a><span class="in">        filter(ps &gt;= minps &amp; ps &lt;= maxps)</span></span>
<span id="cb1-480"><a href="#cb1-480" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb1-481"><a href="#cb1-481" aria-hidden="true" tabindex="-1"></a><span class="in">    # compute IPWs</span></span>
<span id="cb1-482"><a href="#cb1-482" aria-hidden="true" tabindex="-1"></a><span class="in">    br &lt;- br %&gt;%</span></span>
<span id="cb1-483"><a href="#cb1-483" aria-hidden="true" tabindex="-1"></a><span class="in">      mutate(</span></span>
<span id="cb1-484"><a href="#cb1-484" aria-hidden="true" tabindex="-1"></a><span class="in">        ipw = case_when(</span></span>
<span id="cb1-485"><a href="#cb1-485" aria-hidden="true" tabindex="-1"></a><span class="in">          dark_mode == 1 ~ 1 / ps,</span></span>
<span id="cb1-486"><a href="#cb1-486" aria-hidden="true" tabindex="-1"></a><span class="in">          dark_mode == 0 ~ 1 / (1 - ps))</span></span>
<span id="cb1-487"><a href="#cb1-487" aria-hidden="true" tabindex="-1"></a><span class="in">      )</span></span>
<span id="cb1-488"><a href="#cb1-488" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb1-489"><a href="#cb1-489" aria-hidden="true" tabindex="-1"></a><span class="in">    # Simple _ATT_ estimate:</span></span>
<span id="cb1-490"><a href="#cb1-490" aria-hidden="true" tabindex="-1"></a><span class="in">    # w_means &lt;- br %&gt;%</span></span>
<span id="cb1-491"><a href="#cb1-491" aria-hidden="true" tabindex="-1"></a><span class="in">    #     group_by(dark_mode) %&gt;%</span></span>
<span id="cb1-492"><a href="#cb1-492" aria-hidden="true" tabindex="-1"></a><span class="in">    #     summarize(m = weighted.mean(read_time, w = ipw)) %&gt;% </span></span>
<span id="cb1-493"><a href="#cb1-493" aria-hidden="true" tabindex="-1"></a><span class="in">    #     arrange(dark_mode)</span></span>
<span id="cb1-494"><a href="#cb1-494" aria-hidden="true" tabindex="-1"></a><span class="in">    # </span></span>
<span id="cb1-495"><a href="#cb1-495" aria-hidden="true" tabindex="-1"></a><span class="in">    # # simple diff-in-means _ATT_ estimate</span></span>
<span id="cb1-496"><a href="#cb1-496" aria-hidden="true" tabindex="-1"></a><span class="in">    #  return(w_means$m[2] - w_means$m[1]) </span></span>
<span id="cb1-497"><a href="#cb1-497" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb1-498"><a href="#cb1-498" aria-hidden="true" tabindex="-1"></a><span class="in">    # Do regression adjustment for _ATE_ estimate</span></span>
<span id="cb1-499"><a href="#cb1-499" aria-hidden="true" tabindex="-1"></a><span class="in">    # TE prediction for whole sample based on TG model</span></span>
<span id="cb1-500"><a href="#cb1-500" aria-hidden="true" tabindex="-1"></a><span class="in">    mtreat &lt;- br %&gt;%</span></span>
<span id="cb1-501"><a href="#cb1-501" aria-hidden="true" tabindex="-1"></a><span class="in">      filter(dark_mode == 1) %&gt;%</span></span>
<span id="cb1-502"><a href="#cb1-502" aria-hidden="true" tabindex="-1"></a><span class="in">      lm(read_time ~ 1 + age + hours + male, data = ., weights = .$ipw) %&gt;%</span></span>
<span id="cb1-503"><a href="#cb1-503" aria-hidden="true" tabindex="-1"></a><span class="in">      predict(newdata = br) %&gt;%</span></span>
<span id="cb1-504"><a href="#cb1-504" aria-hidden="true" tabindex="-1"></a><span class="in">      mean()</span></span>
<span id="cb1-505"><a href="#cb1-505" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb1-506"><a href="#cb1-506" aria-hidden="true" tabindex="-1"></a><span class="in">    # TE prediction for whole sample based on CG model</span></span>
<span id="cb1-507"><a href="#cb1-507" aria-hidden="true" tabindex="-1"></a><span class="in">    mcont &lt;- br %&gt;%</span></span>
<span id="cb1-508"><a href="#cb1-508" aria-hidden="true" tabindex="-1"></a><span class="in">      filter(dark_mode == 0) %&gt;%</span></span>
<span id="cb1-509"><a href="#cb1-509" aria-hidden="true" tabindex="-1"></a><span class="in">      lm(read_time ~ 1 + age + hours + male, data = ., weights = .$ipw) %&gt;%</span></span>
<span id="cb1-510"><a href="#cb1-510" aria-hidden="true" tabindex="-1"></a><span class="in">      predict(newdata = br) %&gt;%</span></span>
<span id="cb1-511"><a href="#cb1-511" aria-hidden="true" tabindex="-1"></a><span class="in">      mean()</span></span>
<span id="cb1-512"><a href="#cb1-512" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-513"><a href="#cb1-513" aria-hidden="true" tabindex="-1"></a><span class="in">    return(mtreat - mcont) # Regression adjusted _ATE_ estimate</span></span>
<span id="cb1-514"><a href="#cb1-514" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb1-515"><a href="#cb1-515" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb1-516"><a href="#cb1-516" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-517"><a href="#cb1-517" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb1-518"><a href="#cb1-518" aria-hidden="true" tabindex="-1"></a><span class="in">b &lt;- boot(data = darkmode, ipwra, R = 999)</span></span>
<span id="cb1-519"><a href="#cb1-519" aria-hidden="true" tabindex="-1"></a><span class="in"># Bootstrap estimate and standard error</span></span>
<span id="cb1-520"><a href="#cb1-520" aria-hidden="true" tabindex="-1"></a><span class="in">mean(b$t)</span></span>
<span id="cb1-521"><a href="#cb1-521" aria-hidden="true" tabindex="-1"></a><span class="in">sd(b$t)</span></span>
<span id="cb1-522"><a href="#cb1-522" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb1-523"><a href="#cb1-523" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-524"><a href="#cb1-524" aria-hidden="true" tabindex="-1"></a>\vfill</span>
<span id="cb1-525"><a href="#cb1-525" aria-hidden="true" tabindex="-1"></a><span class="fu"># Literatur</span></span>
<span id="cb1-526"><a href="#cb1-526" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-527"><a href="#cb1-527" aria-hidden="true" tabindex="-1"></a>Abadie, Alberto, and Guido W. Imbens. (2008). *On the Failure of the Bootstrap for Matching Estimators.*Econometrica 76 (**6**): 1537‚Äì57.</span>
<span id="cb1-528"><a href="#cb1-528" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-529"><a href="#cb1-529" aria-hidden="true" tabindex="-1"></a>Bodory, H., Camponovo, L., Huber, M., &amp; Lechner, M. (2020). *The Finite Sample Performance of Inference Methods for Propensity Score Matching and Weighting Estimators*. Journal of Business &amp; Economic Statistics, 38(**1**), 183‚Äì200.</span>
<span id="cb1-530"><a href="#cb1-530" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-531"><a href="#cb1-531" aria-hidden="true" tabindex="-1"></a>Wooldridge, J. M. (2010). *Econometric analysis of cross section and panel data*. MIT press.</span>
<span id="cb1-532"><a href="#cb1-532" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-533"><a href="#cb1-533" aria-hidden="true" tabindex="-1"></a></span>
</code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->



</body></html>