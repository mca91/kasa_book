<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="de" xml:lang="de"><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<title>Kausalanalyse und Machinelles Lernen mit R - 3&nbsp; Matching</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>

<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./RDD.html" rel="next">
<link href="./R_Einfuehrung.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light"><script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "Keine Treffer",
    "search-matching-documents-text": "Treffer",
    "search-copy-link-title": "Link in die Suche kopieren",
    "search-hide-matches-text": "Zus√§tzliche Treffer verbergen",
    "search-more-match-text": "weitere Treffer in diesem Dokument",
    "search-more-matches-text": "weitere Treffer in diesem Dokument",
    "search-clear-button-title": "Zur√ºcksetzen",
    "search-detached-cancel-button-title": "Abbrechen",
    "search-submit-button-title": "Abschicken",
    "search-label": "Suchen"
  }
}</script><meta name="robots" content="noindex">
<script>
  MathJax = {
    tex: {
      tags: 'ams'  // should be 'ams', 'none', or 'all'
    }
  };
</script><script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.js" integrity="sha512-aoZChv+8imY/U1O7KIHXvO87EOzCuKO0GhFtpD6G2Cyjo/xPeTgdf3/bchB10iB+AojMTDkMHDPLKNxPJVqDcw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/all.min.css">
<style>
.qwebr-code-output-stdout {background-color: powderblue;}

.qwebr-button-run {
 width = 100%; 
}

</style>
<script src="https://cdn.jsdelivr.net/npm/quizdown@latest/public/build/quizdown.js"></script><script>quizdown.init();</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/monaco-editor@0.43.0/min/vs/editor/editor.main.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha512-z3gLpd7yknf1YoNbCzqRKc4qyor8gaKU1qmn+CShxbuBusANI9QpRohGBreCFkKxLhei6S9CQXFEbbKuqLg0DA==" crossorigin="anonymous" referrerpolicy="no-referrer">
<style>
  .monaco-editor pre {
    background-color: unset !important;
  }

  .qwebr-icon-status-spinner {
    color: darkgreen;
  }

  .qwebr-icon-run-code {
    color: #0d9c29
  }

  .qwebr-output-code-stdout {
    color: #111;
  }

  .qwebr-output-code-stderr {
    color: #db4133;
  }
  
  .qwebr-editor {
    border: 1px solid #EEEEEE;
  }
  
  .qwebr-button-run {
    background-color: #EEEEEE;
    border-bottom-left-radius: 0;
    border-bottom-right-radius: 0; /* Extra styling for consistency */
    display: inline-block;
    font-weight: 600;
    line-height: 1;
    color: #000;
    text-align: center;
    text-decoration: none;
    -webkit-text-decoration: none;
    -moz-text-decoration: none;
    -ms-text-decoration: none;
    -o-text-decoration: none;
    /* vertical-align: middle; */ /* Prevents a space from appearing between the code cell and button */
    -webkit-user-select: none;
    border-color: #dee2e6;
    border: 1px solid rgba(0,0,0,0);
    padding: 0.375rem 0.75rem 0.75rem;
    font-size: .8rem;
    border-top-right-radius: 0.25rem;
    border-top-left-radius: 0.25rem;
    transition: color .15s ease-in-out,
    background-color .15s ease-in-out,
    border-color .15s ease-in-out,
    box-shadow .15s ease-in-out;
  }

  .qwebr-button-run:hover {
    color: #000;
    background-color: #e3e6ea;
    border-color: #e1e5e9;
  }

  .qwebr-button-run:disabled,
  .qwebr-button-run.disabled,
  fieldset:disabled 
  .qwebr-button-run {
    pointer-events: none;
    cursor: not-allowed;
    opacity: .5
  }
  
  .qwebr-output-code-area > pre {
    background-color: #F2F2F2;
    border-radius: 15px;
    margin-top: .8rem;
    padding: .1rem;
  }
  
  .qwebr-output-code-area > pre > div {
    margin: .4rem;
    margin-left: .6rem;
  }
  
  .monaco-editor {
    z-index: 0;
    -webkit-box-shadow: 5px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 5px 5px 15px 5px rgba(0, 0, 0, 0.3);    
  }

  
  /* Custom styling for RevealJS Presentations*/

  /* Reset the style of the interactive area */
  .reveal div.qwebr-interactive-area {
    display: block;
    box-shadow: none;
    max-width: 100%;
    max-height: 100%;
    margin: 0;
    padding: 0;
  } 

  /* Provide space to entries */
  .reveal div.qwebr-output-code-area pre div {
    margin: 1px 2px 1px 10px;
  }

  /* Collapse the inside code tags to avoid extra space between line outputs */
  .reveal pre div code.qwebr-output-code-stdout, .reveal pre div code.qwebr-output-code-stderr {
    padding: 0;
    display: contents;
  }

  .reveal pre div code.qwebr-output-code-stdout {
    color: #111;
  }

  .reveal pre div code.qwebr-output-code-stderr {
    color: #db4133;
  }


  /* Create a border around console and output (does not effect graphs) */
  .reveal div.qwebr-console-area {
    border: 1px solid #EEEEEE;
    box-shadow: 2px 2px 10px #EEEEEE;
  }

  /* Cap output height and allow text to scroll */
  /* TODO: Is there a better way to fit contents/max it parallel to the monaco editor size? */
  .reveal div.qwebr-output-code-area pre {
    max-height: 400px;
    overflow: scroll;
  }
</style>
<script type="module">

  // Start a timer
  const initializeWebRTimerStart = performance.now();

  // Determine if we need to install R packages
  var installRPackagesList = ['boot', 'cobalt', 'marginaleffects', 'MatchIt', 'sandwich', 'ggplot2'];
  // Check to see if we have an empty array, if we do set to skip the installation.
  var setupRPackages = !(installRPackagesList.indexOf("") !== -1);
  var autoloadRPackages = true;

  // Display a startup message?
  var showStartupMessage = true;
  var showHeaderMessage = false;
  if (showStartupMessage) {

    // Get references to header elements
    const headerHTML = document.getElementById("title-block-header");
    const headerRevealJS = document.getElementById("title-slide");

    // Create the outermost div element for metadata
    const quartoTitleMeta = document.createElement("div");
    quartoTitleMeta.classList.add("quarto-title-meta");

    // Create the first inner div element
    const firstInnerDiv = document.createElement("div");
    firstInnerDiv.setAttribute("id", "qwebr-status-message-area");

    // Create the second inner div element for "WebR Status" heading and contents
    const secondInnerDiv = document.createElement("div");
    secondInnerDiv.setAttribute("id", "qwebr-status-message-title");
    secondInnerDiv.classList.add("quarto-title-meta-heading");
    secondInnerDiv.innerText = "WebR-Status";

    // Create another inner div for contents
    const secondInnerDivContents = document.createElement("div");
    secondInnerDivContents.setAttribute("id", "qwebr-status-message-body");
    secondInnerDivContents.classList.add("quarto-title-meta-contents");

    // Describe the WebR state
    var startupMessageWebR = document.createElement("p");
    startupMessageWebR.innerText = "Starte..."
    startupMessageWebR.setAttribute("id", "qwebr-status-message-text");
    // Add `aria-live` to auto-announce the startup status to screen readers
    startupMessageWebR.setAttribute("aria-live", "assertive");

    // Append the startup message to the contents
    secondInnerDivContents.appendChild(startupMessageWebR);

    // Add a status indicator for COOP and COEP Headers if needed
    if (showHeaderMessage) {
      const crossOriginMessage = document.createElement("p");
      crossOriginMessage.innerText = `${crossOriginIsolated ? 'üü¢' : 'üü°'} COOP & COEP Headers`;
      crossOriginMessage.setAttribute("id", "qwebr-coop-coep-header");
      secondInnerDivContents.appendChild(crossOriginMessage);
    }

    // Combine the inner divs and contents
    firstInnerDiv.appendChild(secondInnerDiv);
    firstInnerDiv.appendChild(secondInnerDivContents);
    quartoTitleMeta.appendChild(firstInnerDiv);

    // Determine where to insert the quartoTitleMeta element
    if (headerHTML) {
      // Append to the existing "title-block-header" element
      headerHTML.appendChild(quartoTitleMeta);
    } else if (headerRevealJS) {
      // If using RevealJS, add to the "title-slide" div
      headerRevealJS.appendChild(firstInnerDiv);
    } else {
      // If neither headerHTML nor headerRevealJS is found, insert after "webr-monaco-editor-init" script
      const monacoScript = document.getElementById("qwebr-monaco-editor-init");
      const header = document.createElement("header");
      header.setAttribute("id", "title-block-header");
      header.appendChild(quartoTitleMeta);
      monacoScript.after(header);
    }
  }

  // Retrieve the webr.mjs
  import { WebR, ChannelType } from "https://webr.r-wasm.org/v0.2.2/webr.mjs";

  // Populate WebR options with defaults or new values based on 
  // webr meta
  globalThis.webR = new WebR({
    "baseURL": "https://webr.r-wasm.org/v0.2.2/",
    "serviceWorkerUrl": "",
    "homedir": "/home/web_user", 
    "channelType": ChannelType.Automatic
  });

  // Initialization WebR
  await globalThis.webR.init();

  // Setup a shelter
  globalThis.webRCodeShelter = await new globalThis.webR.Shelter();

  // Setup a pager to allow processing help documentation 
  await globalThis.webR.evalRVoid('webr::pager_install()'); 

  // Function to set the button text
  function qwebrSetInteractiveButtonState(buttonText, enableCodeButton = true) {
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.innerHTML = buttonText;
      btn.disabled = !enableCodeButton;
    });
  }

  // Function to update the status message
  function qwebrUpdateStatusHeader(message) {
    startupMessageWebR.innerHTML = `
      <i class="fas fa-cog fa-spin qwebr-icon-status-spinner"></i>
      <span>${message}</span>`;
  }

  // Function to install a single package
  async function qwebrInstallRPackage(packageName) {
    await globalThis.webR.installPackages([packageName]);
  }

  // Function to load a single package
  async function qwebrLoadRPackage(packageName) {
    await globalThis.webR.evalRVoid(`library(${packageName});`);
  }

  // Generic function to process R packages
  async function qwebrProcessRPackagesWithStatus(packages, processType, displayStatusMessageUpdate = true) {
    // Switch between contexts
    const messagePrefix = processType === 'install' ? 'Installiere' : 'Lade';

    // Modify button state
    qwebrSetInteractiveButtonState(`<i class="fas fa-cog fa-spin qwebr-icon-status-spinner"></i> ${messagePrefix} Pakete ...`, false);

    // Iterate over packages
    for (let i = 0; i < packages.length; i++) {
      const activePackage = packages[i];
      const formattedMessage = `${messagePrefix} Paket ${i + 1} von ${packages.length}: <code style="background-color:white; color:darkgreen;">${activePackage}</code>`;
      
      // Display the update
      if (displayStatusMessageUpdate) {
        qwebrUpdateStatusHeader(formattedMessage);
      }

      // Run package installation
      if (processType === 'install') {
        await qwebrInstallRPackage(activePackage);
      } else {
        await qwebrLoadRPackage(activePackage);
      }
    }

    // Clean slate
    if (processType === 'load') {
      await globalThis.webR.flush();
    }
  }


  // Check to see if any packages need to be installed
  if (setupRPackages) {
    // Obtain only a unique list of packages
    const uniqueRPackageList = Array.from(new Set(installRPackagesList));

    // Install R packages one at a time (either silently or with a status update)
    await qwebrProcessRPackagesWithStatus(uniqueRPackageList, 'install', showStartupMessage);

    if(autoloadRPackages) {
      // Load R packages one at a time (either silently or with a status update)
      await qwebrProcessRPackagesWithStatus(uniqueRPackageList, 'load', showStartupMessage);
    }
  }

  // Stop timer
  const initializeWebRTimerEnd = performance.now();

  // Release document status as ready
  if (showStartupMessage) {
    startupMessageWebR.innerText = "‚úÖ Bereit!"
  }
  
  qwebrSetInteractiveButtonState(
    `<span>R-Code ausf√ºhren <i class="fa fa-sign-in"></i></span>`, 
    true
  );

</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
</head>
<body class="nav-sidebar floating slimcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top"><nav class="quarto-secondary-nav"><div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Seitenleiste umschalten" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
      <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./Matching.html"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Matching</span></a></li></ol></nav>
      <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Seitenleiste umschalten" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
      </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav></header><!-- content --><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal sidebar-navigation floating overflow-auto"><div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./"></a><a href="./index.html">Kausalanalyse mit R</a> 
        <div class="sidebar-tools-main">
  <a href="" class="quarto-reader-toggle quarto-navigation-tool px-1" onclick="window.quartoToggleReader(); return false;" title="Lesemodus umschalten">
  <div class="quarto-reader-toggle-btn">
  <i class="bi"></i>
  </div>
</a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Suchen"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
<li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Start</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./R_Einfuehrung.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Statistische Programmierung mit R</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Matching.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Matching</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./RDD.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Regression Discontiniuty Designs</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./RegReg.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Regularisierte Regression</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Literatur.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Literatur</span></a>
  </div>
</li>
    </ul>
</div>
    <nav id="TOC" role="doc-toc" class="toc-active"><h2 id="toc-title"><a href="./index.html">√úbersicht</a></h2>
   
  <ul>
<li>
<a href="#gewichtete-mittelwerte-und-matching" id="toc-gewichtete-mittelwerte-und-matching" class="nav-link active" data-scroll-target="#gewichtete-mittelwerte-und-matching"><span class="header-section-number">3.1</span> Gewichtete Mittelwerte und Matching</a>
  <ul class="collapse">
<li><a href="#balance-vergleichbarkeit-von-behandlungs--und-kontrollgruppe" id="toc-balance-vergleichbarkeit-von-behandlungs--und-kontrollgruppe" class="nav-link" data-scroll-target="#balance-vergleichbarkeit-von-behandlungs--und-kontrollgruppe"><span class="header-section-number">3.1.1</span> <em>Balance</em>: Vergleichbarkeit von Behandlungs- und Kontrollgruppe</a></li>
  <li><a href="#section" id="toc-section" class="nav-link" data-scroll-target="#section"><span class="header-section-number">3.1.2</span> </a></li>
  <li><a href="#inverse-probability-weighting" id="toc-inverse-probability-weighting" class="nav-link" data-scroll-target="#inverse-probability-weighting"><span class="header-section-number">3.1.3</span> Inverse Probability Weighting</a></li>
  <li><a href="#propensity-score" id="toc-propensity-score" class="nav-link" data-scroll-target="#propensity-score"><span class="header-section-number">3.1.4</span> Propensity score</a></li>
  </ul>
</li>
  <li><a href="#inferenz-f%C3%BCr-attate-propensity-score-matching-mit-bootstrap" id="toc-inferenz-f√ºr-attate-propensity-score-matching-mit-bootstrap" class="nav-link" data-scroll-target="#inferenz-f%C3%BCr-attate-propensity-score-matching-mit-bootstrap"><span class="header-section-number">3.2</span> Inferenz f√ºr ATT/ATE: Propensity-Score-Matching mit Bootstrap</a></li>
  <li><a href="#doubly-robust-sch%C3%A4tzer-f%C3%BCr-attate" id="toc-doubly-robust-sch√§tzer-f√ºr-attate" class="nav-link" data-scroll-target="#doubly-robust-sch%C3%A4tzer-f%C3%BCr-attate"><span class="header-section-number">3.3</span> Doubly-Robust-Sch√§tzer f√ºr ATT/ATE</a></li>
  <li><a href="#literatur" id="toc-literatur" class="nav-link" data-scroll-target="#literatur"><span class="header-section-number">4</span> Literatur</a></li>
  </ul></nav>
</nav><div id="quarto-sidebar-glass" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
    </div>
<!-- main -->
<main class="content page-columns page-full" id="quarto-document-content"><script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.43.0/min/vs/loader.js"></script><script type="module" id="qwebr-monaco-editor-init">

  // Configure the Monaco Editor's loader
  require.config({
    paths: {
      'vs': 'https://cdn.jsdelivr.net/npm/monaco-editor@0.43.0/min/vs'
    }
  });
</script><header id="title-block-header" class="quarto-title-block default"><div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title">
<span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Matching</span>
</h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> Code</button></div></div>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header><div class="cell">

</div>
<script type="module">
// Initialization WebR
await globalThis.webR.init();

// Run R code without focusing on storing data.
await globalThis.webR.evalRVoid(`
webr::install("dplyr")

# create dataset directory
dir.create("datasets")
# Download the dataset
download.file(
    "https://raw.githubusercontent.com/mca91/kausal_data/main/darkmode.csv",
    'datasets/darkmode.csv',
)
`)
</script><script type="module">
// Initialization WebR
await globalThis.webR.init();

// Run R code without focusing on storing data.
await globalThis.webR.evalRVoid(`
library(dplyr)
# make darkmode available using read.csv for now
# because there's some issue with readr::read_csv
# I can't fix right now
darkmode <- read.csv(
    file = "datasets/darkmode.csv", 
    colClasses = c("numeric", "logical", "numeric", "numeric", "numeric") 
)

options(pillar.bold = TRUE, pillar.subtle = FALSE)
`)
</script><p>In randomisierten kontrollierten Studien stellt eine randomisierte Behandlung sicher, dass die Individuen beider Gruppen im Mittel vergleichbar sind, dass hei√üt es gibt keine systematischen Unterschiede der Studiensubjekte hinsichtlich der Verteilung von Charakteristika zwischen den Gruppen. Dann ist es plausibel eine beobachtete mittlere Differenz in der Outcome-Variable alleine auf die Behandlung zur√ºckzuf√ºhren.</p>
<p>In der Praxis, insbesondere in √∂konomischen Studien, sind randomisierte kontrollierte Studien aus ethischen und/oder finanziellen Gr√ºnden nicht durchf√ºhrbar. Stattdessen werden nicht-experimentelle Daten genutzt, die jedoch nur sehr selten eine Vergleichbarkeit von Behandlungs- und Kontrollgruppe gew√§hrleisten.</p>
<p>In diesem Kapitel betrachten wir Methoden, die in solchen Forschungsdesigns ‚Äì bei hinreichenden Informationen √ºber die Studiensubjekte ‚Äì eine Sch√§tzung kausaler Effekte erm√∂glichen, indem eine Vergleichbarkeit von Behandlungs- und Kontrollgruppe hergestellt wird. Dies kann √ºber eine gezielte Gewichtung von Beobachtungen anhand invididueller Merkmale erfolgen. Eine etablierte Methode ist die Sch√§tzung des kausalen Effekts nach Selektion von vergleichbaren Teilmengen von Subjekten beider Gruppen aus der urspr√ºnglichen Stichprobe, sogenanntes <em>Matching</em>.</p>
<section id="gewichtete-mittelwerte-und-matching" class="level2 page-columns page-full" data-number="3.1"><h2 data-number="3.1" class="anchored" data-anchor-id="gewichtete-mittelwerte-und-matching">
<span class="header-section-number">3.1</span> Gewichtete Mittelwerte und Matching</h2>
<p>Der Lehrstuhl f√ºr √ñkonometrie an der Universit√§t Duisburg-Essen verwaltet betreibt einen √ñkonometrie-Blog und interessiert sich f√ºr den kausalen Effekt der Einf√ºhrung eines <a href="https://en.wikipedia.org/wiki/Wikipedia:Dark_mode">darkmode</a> auf die Verweildauer der User auf der Webseite. Die Webseite ist zwar nicht-kommerziell, hat sich allerdings insb. f√ºr die Aquise internationaler Studierender f√ºr den Studiengang MSc. Econometrics als wichtiges Marketing-Instrument erwiesen. Ein anprechendes Design wird daher als hoch-relevant erachtet.</p>
<p>Idealerweise sollte der Effekt des Design-Relaunches auf die Nutzungsintensit√§t in einem kontrollierten randomisierten Experiment untersucht werden. Hierbei w√ºrden wir Nutzern zuf√§llig das neue oder das alte Design zuweisen und den Effekt als Differnz des durchschnittlichen Verweildauer f√ºr die Gruppen bestimmen. Eine solche Studie ist jedoch aus technischen und finanziellen Gr√ºnden nicht realisierbar, sodass die Auswirkungen des darkmode mit vorliegenden nicht-experimenellen Nutzungsstatistiken f√ºr die Webseite gesch√§tzt werden sollen.</p>
<p>Die Nutzungsstatistiken sind im Datensatz <a href="https://raw.githubusercontent.com/mca91/kasa_data/main/darkmode.csv"><em>darkmode.csv</em></a> enthalten und sollen der Analyse des Effekts des darkmode (<code>dark_mode</code>) auf die Verweildauer der Leser auf der Webseite (<code>read_time</code>) dienen.</p>
<p><a href="#tbl-darkmode">Tabelle&nbsp;<span>3.1</span></a> zeigt die Definitionen der Variablen in <em>darkmode.csv</em>.</p>
<div class="cell page-columns page-full">
<div class="cell-output-display page-columns page-full">
<div id="tbl-darkmode" class="anchored page-columns page-full">

<div id="mguezhxrkh" style="padding-left:0px;padding-right:0px;padding-top:10px;padding-bottom:10px;overflow-x:auto;overflow-y:auto;width:auto;height:auto;" class="page-columns page-full">
<style>#mguezhxrkh table {
  font-family: system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

#mguezhxrkh thead, #mguezhxrkh tbody, #mguezhxrkh tfoot, #mguezhxrkh tr, #mguezhxrkh td, #mguezhxrkh th {
  border-style: none;
}

#mguezhxrkh p {
  margin: 0;
  padding: 0;
}

#mguezhxrkh .gt_table {
  display: table;
  border-collapse: collapse;
  line-height: normal;
  margin-left: auto;
  margin-right: auto;
  color: #000000;
  font-size: 16px;
  font-weight: normal;
  font-style: normal;
  background-color: #FFFFFF;
  width: auto;
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #A8A8A8;
  border-right-style: none;
  border-right-width: 2px;
  border-right-color: #D3D3D3;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #000000;
  border-left-style: none;
  border-left-width: 2px;
  border-left-color: #D3D3D3;
}

#mguezhxrkh .gt_caption {
  padding-top: 4px;
  padding-bottom: 4px;
}

#mguezhxrkh .gt_title {
  color: #000000;
  font-size: 125%;
  font-weight: initial;
  padding-top: 4px;
  padding-bottom: 4px;
  padding-left: 5px;
  padding-right: 5px;
  border-bottom-color: #FFFFFF;
  border-bottom-width: 0;
}

#mguezhxrkh .gt_subtitle {
  color: #000000;
  font-size: 85%;
  font-weight: initial;
  padding-top: 3px;
  padding-bottom: 5px;
  padding-left: 5px;
  padding-right: 5px;
  border-top-color: #FFFFFF;
  border-top-width: 0;
}

#mguezhxrkh .gt_heading {
  background-color: #FFFFFF;
  text-align: center;
  border-bottom-color: #FFFFFF;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
}

#mguezhxrkh .gt_bottom_border {
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
}

#mguezhxrkh .gt_col_headings {
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #000000;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #000000;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
}

#mguezhxrkh .gt_col_heading {
  color: #000000;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: bold;
  text-transform: inherit;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
  vertical-align: bottom;
  padding-top: 5px;
  padding-bottom: 6px;
  padding-left: 5px;
  padding-right: 5px;
  overflow-x: hidden;
}

#mguezhxrkh .gt_column_spanner_outer {
  color: #000000;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: bold;
  text-transform: inherit;
  padding-top: 0;
  padding-bottom: 0;
  padding-left: 4px;
  padding-right: 4px;
}

#mguezhxrkh .gt_column_spanner_outer:first-child {
  padding-left: 0;
}

#mguezhxrkh .gt_column_spanner_outer:last-child {
  padding-right: 0;
}

#mguezhxrkh .gt_column_spanner {
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #000000;
  vertical-align: bottom;
  padding-top: 5px;
  padding-bottom: 5px;
  overflow-x: hidden;
  display: inline-block;
  width: 100%;
}

#mguezhxrkh .gt_spanner_row {
  border-bottom-style: hidden;
}

#mguezhxrkh .gt_group_heading {
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
  color: #000000;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: initial;
  text-transform: inherit;
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #D3D3D3;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
  vertical-align: middle;
  text-align: left;
}

#mguezhxrkh .gt_empty_group_heading {
  padding: 0.5px;
  color: #000000;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: initial;
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #D3D3D3;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  vertical-align: middle;
}

#mguezhxrkh .gt_from_md > :first-child {
  margin-top: 0;
}

#mguezhxrkh .gt_from_md > :last-child {
  margin-bottom: 0;
}

#mguezhxrkh .gt_row {
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
  margin: 10px;
  border-top-style: solid;
  border-top-width: 1px;
  border-top-color: #FFFFFF;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
  vertical-align: middle;
  overflow-x: hidden;
}

#mguezhxrkh .gt_stub {
  color: #000000;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: initial;
  text-transform: inherit;
  border-right-style: solid;
  border-right-width: 2px;
  border-right-color: #D3D3D3;
  padding-left: 5px;
  padding-right: 5px;
}

#mguezhxrkh .gt_stub_row_group {
  color: #000000;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: initial;
  text-transform: inherit;
  border-right-style: solid;
  border-right-width: 2px;
  border-right-color: #D3D3D3;
  padding-left: 5px;
  padding-right: 5px;
  vertical-align: top;
}

#mguezhxrkh .gt_row_group_first td {
  border-top-width: 2px;
}

#mguezhxrkh .gt_row_group_first th {
  border-top-width: 2px;
}

#mguezhxrkh .gt_summary_row {
  color: #000000;
  background-color: #FFFFFF;
  text-transform: inherit;
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
}

#mguezhxrkh .gt_first_summary_row {
  border-top-style: solid;
  border-top-color: #D3D3D3;
}

#mguezhxrkh .gt_first_summary_row.thick {
  border-top-width: 2px;
}

#mguezhxrkh .gt_last_summary_row {
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
}

#mguezhxrkh .gt_grand_summary_row {
  color: #000000;
  background-color: #FFFFFF;
  text-transform: inherit;
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
}

#mguezhxrkh .gt_first_grand_summary_row {
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
  border-top-style: double;
  border-top-width: 6px;
  border-top-color: #D3D3D3;
}

#mguezhxrkh .gt_last_grand_summary_row_top {
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
  border-bottom-style: double;
  border-bottom-width: 6px;
  border-bottom-color: #D3D3D3;
}

#mguezhxrkh .gt_striped {
  background-color: rgba(128, 128, 128, 0.05);
}

#mguezhxrkh .gt_table_body {
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #D3D3D3;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #000000;
}

#mguezhxrkh .gt_footnotes {
  color: #000000;
  background-color: #FFFFFF;
  border-bottom-style: none;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  border-left-style: none;
  border-left-width: 2px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 2px;
  border-right-color: #D3D3D3;
}

#mguezhxrkh .gt_footnote {
  margin: 0px;
  font-size: 90%;
  padding-top: 4px;
  padding-bottom: 4px;
  padding-left: 5px;
  padding-right: 5px;
}

#mguezhxrkh .gt_sourcenotes {
  color: #000000;
  background-color: #FFFFFF;
  border-bottom-style: none;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  border-left-style: none;
  border-left-width: 2px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 2px;
  border-right-color: #D3D3D3;
}

#mguezhxrkh .gt_sourcenote {
  font-size: 90%;
  padding-top: 4px;
  padding-bottom: 4px;
  padding-left: 5px;
  padding-right: 5px;
}

#mguezhxrkh .gt_left {
  text-align: left;
}

#mguezhxrkh .gt_center {
  text-align: center;
}

#mguezhxrkh .gt_right {
  text-align: right;
  font-variant-numeric: tabular-nums;
}

#mguezhxrkh .gt_font_normal {
  font-weight: normal;
}

#mguezhxrkh .gt_font_bold {
  font-weight: bold;
}

#mguezhxrkh .gt_font_italic {
  font-style: italic;
}

#mguezhxrkh .gt_super {
  font-size: 65%;
}

#mguezhxrkh .gt_footnote_marks {
  font-size: 75%;
  vertical-align: 0.4em;
  position: initial;
}

#mguezhxrkh .gt_asterisk {
  font-size: 100%;
  vertical-align: 0;
}

#mguezhxrkh .gt_indent_1 {
  text-indent: 5px;
}

#mguezhxrkh .gt_indent_2 {
  text-indent: 10px;
}

#mguezhxrkh .gt_indent_3 {
  text-indent: 15px;
}

#mguezhxrkh .gt_indent_4 {
  text-indent: 20px;
}

#mguezhxrkh .gt_indent_5 {
  text-indent: 25px;
}
</style>
<table class="gt_table" data-quarto-disable-processing="false" data-quarto-bootstrap="false">

  <thead><tr class="gt_col_headings">
<th class="gt_col_heading gt_columns_bottom_border gt_left" rowspan="1" colspan="1" scope="col" id="Variable">Variable</th>
      <th class="gt_col_heading gt_columns_bottom_border gt_left" rowspan="1" colspan="1" scope="col" id="Beschreibung">Beschreibung</th>
    </tr></thead>
<tbody class="gt_table_body">
<tr>
<td headers="Variable" class="gt_row gt_left">read_time</td>
<td headers="Beschreibung" class="gt_row gt_left">Lesezeit (Minuten/Woche)</td>
</tr>
<tr>
<td headers="Variable" class="gt_row gt_left">dark_mode</td>
<td headers="Beschreibung" class="gt_row gt_left">Indikator: Beobachtung nach Einf√ºhrung darkmode</td>
</tr>
<tr>
<td headers="Variable" class="gt_row gt_left">male</td>
<td headers="Beschreibung" class="gt_row gt_left">Indikator: Individuum m√§nnlich</td>
</tr>
<tr>
<td headers="Variable" class="gt_row gt_left">age</td>
<td headers="Beschreibung" class="gt_row gt_left">Alter (in Jahren)</td>
</tr>
<tr>
<td headers="Variable" class="gt_row gt_left">hours</td>
<td headers="Beschreibung" class="gt_row gt_left">Bisherige Verweildauer auf der Seite</td>
</tr>
</tbody>
</table>
<div class="quarto-table-caption margin-caption">Tabelle&nbsp;3.1:  <p>Variablen im Datensatz <em>darkmode</em></p> </div></div>
</div>
</div>
</div>
<p>F√ºr die Analyse lesen wir zun√§chst den Datensatz <em>darkmode.csv</em> mit <code><a href="https://readr.tidyverse.org/reference/read_delim.html">readr::read_csv()</a></code> ein und verschaffen uns einen √úberblick √ºber die verf√ºgbaren Variablen.</p>
<div class="cell">
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># Paket `tidyverse` laden</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://tidyverse.tidyverse.org">tidyverse</a></span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Datensatz 'darkmode' einlesen</span></span>
<span><span class="va">darkmode</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://readr.tidyverse.org/reference/read_delim.html">read_csv</a></span><span class="op">(</span></span>
<span>  file <span class="op">=</span> <span class="st">"datasets/darkmode.csv"</span></span>
<span><span class="op">)</span></span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><code>dark_mode</code> hat den Typ <code>logical</code>. Mit <code><a href="https://dplyr.tidyverse.org/reference/mutate_all.html">dplyr::mutate_all()</a></code> k√∂nnen wir komfortabel alle Spalten in den Typ <code>numeric</code> transformieren.</p>
<div class="cell">
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># Alle Variablen zu typ 'numeric' formatieren...</span></span>
<span><span class="va">darkmode</span> <span class="op">&lt;-</span> <span class="va">darkmode</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span> </span>
<span>  <span class="fu"><a href="https://dplyr.tidyverse.org/reference/mutate_all.html">mutate_all</a></span><span class="op">(</span>.funs <span class="op">=</span> <span class="va">as.numeric</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># ... und √ºberpr√ºfen</span></span>
<span><span class="fu"><a href="https://pillar.r-lib.org/reference/glimpse.html">glimpse</a></span><span class="op">(</span><span class="va">darkmode</span><span class="op">)</span></span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Rows: 300
Columns: 5
$ read_time &lt;dbl&gt; 14.4, 15.4, 20.9, 20.0, 21.5, 19.5, 22.0, 17.4, 23.6, 15.7, ‚Ä¶
$ dark_mode &lt;dbl&gt; 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, ‚Ä¶
$ male      &lt;dbl&gt; 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, ‚Ä¶
$ age       &lt;dbl&gt; 43, 55, 23, 41, 29, 64, 18, 53, 59, 53, 43, 38, 42, 23, 39, ‚Ä¶
$ hours     &lt;dbl&gt; 65.6, 125.4, 642.6, 129.1, 190.2, 185.3, 333.5, 279.3, 1302.‚Ä¶</code></pre>
</div>
</div>
<p>Eine naive Sch√§tzung des durchschnittlichen Behandlungseffekts (ATE) <span class="math inline">\(\widehat{\tau}^{\text{naiv}}\)</span> erhalten wir als Mittelwertdifferenz von <code>read_time</code> f√ºr die Behandlungsgruppe (<code>dark_mode == 1</code>) und die Kontrollgruppe (<code>dark_mode == 0</code>) <span class="math display">\[\begin{align}
  \widehat{\tau}^{\text{naiv}} = \overline{\text{read\_time}}_{\text{Behandlung}} - \overline{\text{read\_time}}_{\text{Kontrolle}}.\label{eq:naivATEdarkmode}
\end{align}\]</span></p>
<p>Diese Berechnung ist schnell mit R durchgef√ºhrt.</p>
<div class="cell">
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># Naiver Sch√§tzer f√ºr ATE: </span></span>
<span><span class="co"># Differenz der Gruppen-Durchschnitte</span></span>
<span></span>
<span><span class="co"># Outcome in Behandlungsgruppe</span></span>
<span><span class="va">read_time_mTG</span> <span class="op">&lt;-</span> <span class="va">darkmode</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span> </span>
<span>  <span class="fu"><a href="https://dplyr.tidyverse.org/reference/filter.html">filter</a></span><span class="op">(</span><span class="va">dark_mode</span> <span class="op">==</span> <span class="fl">1</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span> </span>
<span>  <span class="fu"><a href="https://dplyr.tidyverse.org/reference/pull.html">pull</a></span><span class="op">(</span><span class="st">"read_time"</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Outcome in Kontrollgruppe</span></span>
<span><span class="va">read_time_mKG</span> <span class="op">&lt;-</span> <span class="va">darkmode</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span> </span>
<span>  <span class="fu"><a href="https://dplyr.tidyverse.org/reference/filter.html">filter</a></span><span class="op">(</span><span class="va">dark_mode</span> <span class="op">==</span> <span class="fl">0</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span> </span>
<span>  <span class="fu"><a href="https://dplyr.tidyverse.org/reference/pull.html">pull</a></span><span class="op">(</span><span class="st">"read_time"</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Mittelwert-Differenz</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/mean.html">mean</a></span><span class="op">(</span><span class="va">read_time_mTG</span><span class="op">)</span> <span class="op">-</span> <span class="fu"><a href="https://rdrr.io/r/base/mean.html">mean</a></span><span class="op">(</span><span class="va">read_time_mKG</span><span class="op">)</span></span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] -0.4446331</code></pre>
</div>
</div>
<p>Die Sch√§tzung ergibt einen negativen Behandlungseffekt, mit der Interpreation, dass das neue Design zu einer Reduktion der Lesezeit um etwa 0.44 Minuten pro Woche f√ºhrt. Dieses Ergebnis ist allerdings zweifelhaft, weil eine Isolierung des Behandlungseffekts aufgrund von Backdoor-Pfaden im DGP vermutlich nicht gew√§hleistet ist. Ein Indikator hierf√ºr sind systematische Unterschiede hinsichtlich von (m√∂glicherweise unbeobachtbaren) Charakteristika von Kontrollgruppe und Behandlungsgruppe.</p>
<p>Da die User sich beim Aufrufen der Seite aktiv f√ºr oder gegen den das neue Design entscheiden m√ºssen (und somit selektieren, ob Sie in der Behandlungs- oder Kontrollgruppe landen), liegt wahrscheinlich <em>Confounding</em> vor: Unsere Hypothese ist zun√§chst, dass m√§nnliche User eine durchschnittlich l√§ngere Lesezeit aufweisen <em>und</em> mit gr√∂√üerer Wahrscheinlichkeit auf das neue Design wechseln als nicht-m√§nnliche Leser. Dann ist <code>male</code> eine Backdoor-Variable. Diese Situation ist unter der Annahme, dass nur diese Faktoren den DGP bestimmen, in <a href="#fig-maleCDdarkmode">Abbildung&nbsp;<span>3.1</span></a> dargestellt.</p>
<div class="cell page-columns page-full" data-fig-width="4" data-fig-height="3" data-layout-align="center">
<div class="cell-output-display page-columns page-full">
<div id="fig-maleCDdarkmode" class="quarto-figure quarto-figure-center anchored page-columns page-full">
<figure class="figure page-columns page-full"><div>
<svg width="384" height="288" viewbox="0.00 0.00 371.48 152.00" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" style="; max-width: none; max-height: none"><g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 148)"><polygon fill="white" stroke="transparent" points="-4,4 -4,-148 367.48,-148 367.48,4 -4,4"></polygon><!-- read_time --><g id="node1" class="node"><title>
read_time
</title>
<text text-anchor="middle" x="327.49" y="-121.8" font-family="Helvetica,Arial,sans-serif" font-size="14.00">read_time</text></g><!-- dark_mode --><g id="node2" class="node"><title>
dark_mode
</title>
<text text-anchor="middle" x="39.49" y="-121.8" font-family="Helvetica,Arial,sans-serif" font-size="14.00">dark_mode</text></g><!-- dark_mode&#45;&gt;read_time --><g id="edge1" class="edge"><title>
dark_mode-&gt;read_time
</title>
<path fill="none" stroke="green" d="M79.23,-126C132,-126 225.02,-126 280.99,-126"></path><polygon fill="green" stroke="green" points="281.33,-129.5 291.33,-126 281.33,-122.5 281.33,-129.5"></polygon></g><!-- male --><g id="node3" class="node"><title>
male
</title>
<text text-anchor="middle" x="183.49" y="-13.8" font-family="Helvetica,Arial,sans-serif" font-size="14.00">male</text></g><!-- male&#45;&gt;read_time --><g id="edge3" class="edge"><title>
male-&gt;read_time
</title>
<path fill="none" stroke="red" d="M207.59,-36.08C231.58,-54.07 268.54,-81.79 295.09,-101.7"></path><polygon fill="red" stroke="red" points="293.21,-104.66 303.31,-107.86 297.41,-99.06 293.21,-104.66"></polygon></g><!-- male&#45;&gt;dark_mode --><g id="edge2" class="edge"><title>
male-&gt;dark_mode
</title>
<path fill="none" stroke="red" d="M159.39,-36.08C135.4,-54.07 98.44,-81.79 71.89,-101.7"></path><polygon fill="red" stroke="red" points="69.57,-99.06 63.67,-107.86 73.77,-104.66 69.57,-99.06"></polygon></g></g></svg>
</div>
<figcaption class="figure-caption margin-caption">Abbildung&nbsp;3.1: Backdoor durch ‚Äòmale‚Äô im Website-Design-Bespiel</figcaption></figure>
</div>
</div>
</div>
<p>Der DGP in <a href="#fig-maleCDdarkmode">Abbildung&nbsp;<span>3.1</span></a> f√ºhrt zu einer verzerrten Sch√§tzung des kausalen Effekts von <code>dark_mode</code> auf <code>read_time</code> mit <span class="math inline">\(\eqref{eq:naivATEdarkmode}\)</span>, wenn das Verh√§ltnis von m√§nnlichen und nicht-m√§nnlichen Usern in Bahandlungs- und Kontrollgruppe sich systematisch unterscheided. Wir √ºberpr√ºfen dies mit R.</p>
<div class="cell">
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># Anteile m√§nnlicher und nicht-m√§nnlicher User</span></span>
<span><span class="op">(</span></span>
<span>  <span class="va">anteile</span> <span class="op">&lt;-</span> <span class="va">darkmode</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span> </span>
<span>  <span class="fu"><a href="https://dplyr.tidyverse.org/reference/group_by.html">group_by</a></span><span class="op">(</span><span class="va">dark_mode</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span> </span>
<span>  <span class="fu"><a href="https://dplyr.tidyverse.org/reference/summarise.html">summarise</a></span><span class="op">(</span></span>
<span>    gesamt <span class="op">=</span> <span class="fu"><a href="https://dplyr.tidyverse.org/reference/context.html">n</a></span><span class="op">(</span><span class="op">)</span>,</span>
<span>    ant_m <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/mean.html">mean</a></span><span class="op">(</span><span class="va">male</span><span class="op">)</span>,</span>
<span>    ant_nm <span class="op">=</span> <span class="fl">1</span> <span class="op">-</span> <span class="va">ant_m</span>,</span>
<span>    anz_m <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="va">male</span><span class="op">)</span>,</span>
<span>    anz_nm <span class="op">=</span> <span class="va">gesamt</span> <span class="op">-</span> <span class="va">anz_m</span></span>
<span>    <span class="op">)</span></span>
<span><span class="op">)</span></span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 2 √ó 6
  dark_mode gesamt ant_m ant_nm anz_m anz_nm
      &lt;dbl&gt;  &lt;int&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;
1         0    151 0.338  0.662    51    100
2         1    149 0.658  0.342    98     51</code></pre>
</div>
</div>
<p>Die Zusammenfassung <code>anteile_m</code> zeigt, dass der Anteil m√§nnlicher User in der Behandlungsgruppe deutlich h√∂her ist als in der Kontrollgruppe.</p>
<p>Ein Sch√§tzer basierend auf einem Matching eliminiert die Variation von <code>male</code> zwischen den Gruppen. Eine M√∂glichkeit hierf√ºr ist die Gewichtung der Beobachtungen in der Kontrollgruppe entsprechend der Anteile von M√∂nnern und Nicht-M√§nnern in der Behandlungsgruppe, sodass die Vergleichbarkeit hinsichtlich des Geschlechts gew√§hrleistet ist. Hierzu berechnen wir zun√§chst die Gewichte als <span class="math display">\[\begin{align}
  w_i =
  \begin{cases}
    \text{ant\_m}_B/\text{anz\_m}_{K}, &amp; \text{falls } \text{male}_i = 1\\
        \text{ant\_nm}_B/\text{anz\_nm}_{K}, &amp; \text{sonst.}\\
  \end{cases}
\end{align}\]</span> Anhand der Formel <span class="math display">\[\begin{align}
  \overline{X}_w = \frac{\sum_i w_i \cdot X_i}{\sum_i w_i}
\end{align}\]</span> berechnen wir die gewichteten Mittelwerte f√ºr <code>male</code> und <code>read_time</code> in der Kontrollgruppe.</p>
<div class="cell">
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># Anteile und Anzahlen auslesen</span></span>
<span><span class="va">anz_m_K</span> <span class="op">&lt;-</span> <span class="va">anteile</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span> </span>
<span>  <span class="fu"><a href="https://dplyr.tidyverse.org/reference/filter.html">filter</a></span><span class="op">(</span><span class="va">dark_mode</span> <span class="op">==</span> <span class="fl">0</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span> <span class="fu"><a href="https://dplyr.tidyverse.org/reference/pull.html">pull</a></span><span class="op">(</span><span class="va">anz_m</span><span class="op">)</span></span>
<span><span class="va">anz_nm_K</span> <span class="op">&lt;-</span> <span class="va">anteile</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span> </span>
<span>  <span class="fu"><a href="https://dplyr.tidyverse.org/reference/filter.html">filter</a></span><span class="op">(</span><span class="va">dark_mode</span> <span class="op">==</span> <span class="fl">0</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span> <span class="fu"><a href="https://dplyr.tidyverse.org/reference/pull.html">pull</a></span><span class="op">(</span><span class="va">anz_nm</span><span class="op">)</span></span>
<span><span class="va">ant_m_B</span> <span class="op">&lt;-</span> <span class="va">anteile</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span> </span>
<span>  <span class="fu"><a href="https://dplyr.tidyverse.org/reference/filter.html">filter</a></span><span class="op">(</span><span class="va">dark_mode</span> <span class="op">==</span> <span class="fl">1</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span> <span class="fu"><a href="https://dplyr.tidyverse.org/reference/pull.html">pull</a></span><span class="op">(</span><span class="va">ant_m</span><span class="op">)</span></span>
<span><span class="va">ant_nm_B</span> <span class="op">&lt;-</span> <span class="va">anteile</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span> </span>
<span>  <span class="fu"><a href="https://dplyr.tidyverse.org/reference/filter.html">filter</a></span><span class="op">(</span><span class="va">dark_mode</span> <span class="op">==</span> <span class="fl">1</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span> <span class="fu"><a href="https://dplyr.tidyverse.org/reference/pull.html">pull</a></span><span class="op">(</span><span class="va">ant_nm</span><span class="op">)</span></span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># Gewichtete Mittelwerte f√ºr Kontrollgruppe</span></span>
<span><span class="op">(</span></span>
<span><span class="va">gew_K</span> <span class="op">&lt;-</span> <span class="va">darkmode</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span> </span>
<span>  <span class="fu"><a href="https://dplyr.tidyverse.org/reference/filter.html">filter</a></span><span class="op">(</span><span class="va">dark_mode</span> <span class="op">==</span> <span class="fl">0</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span> </span>
<span>  <span class="fu"><a href="https://dplyr.tidyverse.org/reference/select.html">select</a></span><span class="op">(</span><span class="va">read_time</span>, <span class="va">male</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span></span>
<span>  <span class="fu"><a href="https://dplyr.tidyverse.org/reference/mutate.html">mutate</a></span><span class="op">(</span>w <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/ifelse.html">ifelse</a></span><span class="op">(</span></span>
<span>    <span class="va">male</span> <span class="op">==</span> <span class="fl">1</span>, </span>
<span>    <span class="va">ant_m_B</span><span class="op">/</span><span class="va">anz_m_K</span>, </span>
<span>    <span class="va">ant_nm_B</span><span class="op">/</span><span class="va">anz_nm_K</span><span class="op">)</span></span>
<span>    <span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span></span>
<span>  <span class="fu"><a href="https://dplyr.tidyverse.org/reference/summarise.html">summarise</a></span><span class="op">(</span></span>
<span>    male_k <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="va">male</span> <span class="op">*</span> <span class="va">w</span><span class="op">)</span> <span class="op">/</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="va">w</span><span class="op">)</span>,</span>
<span>    mean_read_time_wK <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="va">read_time</span> <span class="op">*</span> <span class="va">w</span><span class="op">)</span> <span class="op">/</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="va">w</span><span class="op">)</span></span>
<span>  <span class="op">)</span></span>
<span><span class="op">)</span></span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 1 √ó 2
  male_k mean_read_time_wK
   &lt;dbl&gt;             &lt;dbl&gt;
1  0.658              18.1</code></pre>
</div>
</div>
<p>Ein Vergleich des gewichteten Mittelwertes von <code>male</code> in der Kontrollgruppe mit dem Mittelwert in der Behandlungsgruppe (<code>male_k</code>) zeigt, dass die Gewichte die Variation in <code>male</code> zwischen beiden Gruppen eliminieren. Mit <code>wmean_read_time_K</code> haben wir einen entsprechend gewichteten Mittelwert der Verweildauer f√ºr die Kontrollgruppe berechnet. Wir sch√§tzen den Behandlungseffekt nun als <span class="math display">\[\begin{align}
  \widehat{\tau}^{\text{w}} = \overline{\text{read\_time}}_{B} - \overline{\text{read\_time}}_{w,K}.
\end{align}\]</span></p>
<div class="cell">
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/mean.html">mean</a></span><span class="op">(</span><span class="va">read_time_mTG</span><span class="op">)</span>  <span class="op">-</span> <span class="va">gew_K</span><span class="op">$</span><span class="va">mean_read_time_wK</span></span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.6383579</code></pre>
</div>
</div>
<section id="balance-vergleichbarkeit-von-behandlungs--und-kontrollgruppe" class="level3 page-columns page-full" data-number="3.1.1"><h3 data-number="3.1.1" class="anchored" data-anchor-id="balance-vergleichbarkeit-von-behandlungs--und-kontrollgruppe">
<span class="header-section-number">3.1.1</span> <em>Balance</em>: Vergleichbarkeit von Behandlungs- und Kontrollgruppe</h3>
<p>Weiterhin scheint plausibel, dass das Alter der Nutzer sowohl die Akzeptanz des Design-Updates als auch die Lesezeit beeinflusst. Die bisherige Verweildauer ist ebenfalls eine plausible Determinante der Lesezeit.</p>
<p>Der angenommene DGP ist in Abbildung <a href="#fig-CDdarkmode">Abbildung&nbsp;<span>3.2</span></a> dargestellt, wobei Backdoor-Pfade mit roten Pfeilen gekennzeichnet sind.</p>
<div class="cell page-columns page-full" data-fig-width="4" data-fig-height="3" data-layout-align="center">
<div class="cell-output-display page-columns page-full">
<div id="fig-CDdarkmode" class="quarto-figure quarto-figure-center anchored page-columns page-full">
<figure class="figure page-columns page-full"><div>
<svg width="384" height="288" viewbox="0.00 0.00 371.48 260.00" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" style="; max-width: none; max-height: none"><g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 256)"><polygon fill="white" stroke="transparent" points="-4,4 -4,-256 367.48,-256 367.48,4 -4,4"></polygon><!-- read_time --><g id="node1" class="node"><title>
read_time
</title>
<text text-anchor="middle" x="327.49" y="-121.8" font-family="Helvetica,Arial,sans-serif" font-size="14.00">read_time</text></g><!-- dark_mode --><g id="node2" class="node"><title>
dark_mode
</title>
<text text-anchor="middle" x="39.49" y="-121.8" font-family="Helvetica,Arial,sans-serif" font-size="14.00">dark_mode</text></g><!-- dark_mode&#45;&gt;read_time --><g id="edge4" class="edge"><title>
dark_mode-&gt;read_time
</title>
<path fill="none" stroke="green" d="M79.23,-126C132,-126 225.02,-126 280.99,-126"></path><polygon fill="green" stroke="green" points="281.33,-129.5 291.33,-126 281.33,-122.5 281.33,-129.5"></polygon></g><!-- male --><g id="node3" class="node"><title>
male
</title>
<text text-anchor="middle" x="183.49" y="-13.8" font-family="Helvetica,Arial,sans-serif" font-size="14.00">male</text></g><!-- male&#45;&gt;read_time --><g id="edge6" class="edge"><title>
male-&gt;read_time
</title>
<path fill="none" stroke="red" d="M207.59,-36.08C231.58,-54.07 268.54,-81.79 295.09,-101.7"></path><polygon fill="red" stroke="red" points="293.21,-104.66 303.31,-107.86 297.41,-99.06 293.21,-104.66"></polygon></g><!-- male&#45;&gt;dark_mode --><g id="edge5" class="edge"><title>
male-&gt;dark_mode
</title>
<path fill="none" stroke="red" d="M159.39,-36.08C135.4,-54.07 98.44,-81.79 71.89,-101.7"></path><polygon fill="red" stroke="red" points="69.57,-99.06 63.67,-107.86 73.77,-104.66 69.57,-99.06"></polygon></g><!-- age --><g id="node4" class="node"><title>
age
</title>
<text text-anchor="middle" x="183.49" y="-229.8" font-family="Helvetica,Arial,sans-serif" font-size="14.00">age</text></g><!-- age&#45;&gt;read_time --><g id="edge3" class="edge"><title>
age-&gt;read_time
</title>
<path fill="none" stroke="red" d="M207.59,-215.92C231.58,-197.93 268.54,-170.21 295.09,-150.3"></path><polygon fill="red" stroke="red" points="297.41,-152.94 303.31,-144.14 293.21,-147.34 297.41,-152.94"></polygon></g><!-- age&#45;&gt;dark_mode --><g id="edge2" class="edge"><title>
age-&gt;dark_mode
</title>
<path fill="none" stroke="red" d="M159.39,-215.92C135.4,-197.93 98.44,-170.21 71.89,-150.3"></path><polygon fill="red" stroke="red" points="73.77,-147.34 63.67,-144.14 69.57,-152.94 73.77,-147.34"></polygon></g><!-- hours --><g id="node5" class="node"><title>
hours
</title>
<text text-anchor="middle" x="327.49" y="-229.8" font-family="Helvetica,Arial,sans-serif" font-size="14.00">hours</text></g><!-- hours&#45;&gt;read_time --><g id="edge1" class="edge"><title>
hours-&gt;read_time
</title>
<path fill="none" stroke="black" d="M327.49,-215.68C327.49,-198.82 327.49,-173.57 327.49,-154.15"></path><polygon fill="black" stroke="black" points="330.99,-154.05 327.49,-144.05 323.99,-154.05 330.99,-154.05"></polygon></g></g></svg>
</div>
<figcaption class="figure-caption margin-caption">Abbildung&nbsp;3.2: Vermuteter DGP im Website-Design-Bespiel</figcaption></figure>
</div>
</div>
</div>
<p>Zur Beurteilung der Vergleichbarkeit von Kontrollgruppe und Behandlungsgruppe empfiehlt sich eine Gegen√ºberstellung der empirischen Verteilungen der Kovariablen beider Gruppen. Wir visualisieren die empirischen Verteilungen zun√§chst mit <code>ggplot2</code>. Hierzu transformieren wir <code>male</code> und <code>dark_mode</code> in den Typ <code>factor</code> und standardisieren <code>age</code> und <code>hours</code> mit <code><a href="https://rdrr.io/r/base/scale.html">scale()</a></code>.</p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>
<div id="qwebr-interactive-area-3" class="qwebr-interactive-area">
  <div id="qwebr-console-area-3" class="qwebr-console-area">
    <div id="qwebr-editor-3" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-3">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-3" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-3" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-3");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-3");
  const editorDiv = document.getElementById("qwebr-editor-3");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-3");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `# Datensatz f√ºr graphische Darstellung formatieren
darkmode_p <- darkmode %>% 
  # Standardisierung mit 'scale()'
  mutate(
    male = as.factor(male), 
    dark_mode = as.factor(dark_mode),
    age = scale(age), 
    hours = scale(hours)
  )

head(darkmode_p)`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-3-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-3-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script><p>F√ºr <code>age</code> und <code>hours</code> eignen sich die gesch√§tzten Dichtefunktionen f√ºr einen Vergleich der Verteilungen in Behandlungs- und Kontrollgruppe.</p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>
<div id="qwebr-interactive-area-4" class="qwebr-interactive-area">
  <div id="qwebr-console-area-4" class="qwebr-console-area">
    <div id="qwebr-editor-4" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-4">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-4" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-4" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-4");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-4");
  const editorDiv = document.getElementById("qwebr-editor-4");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-4");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `# Vergleich mit Dichtesch√§tzungen
darkmode_p %>%
  select(dark_mode, hours, age) %>%
  # in langes Format √ºberf√ºhren
  pivot_longer(cols = c(-dark_mode)) %>%
  
  ggplot(
    aes(x = value, fill = dark_mode)
    ) +
  geom_density(alpha = .5) + 
  facet_wrap(
    facets = ~ name, 
    scales = "free", 
    nrow = 2
    )`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-4-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-4-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script><p>F√ºr <code>male</code> vergleichen wir die relativen H√§ufigkeiten mit Balkendiagrammen.</p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>
<div id="qwebr-interactive-area-5" class="qwebr-interactive-area">
  <div id="qwebr-console-area-5" class="qwebr-console-area">
    <div id="qwebr-editor-5" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-5">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-5" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-5" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-5");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-5");
  const editorDiv = document.getElementById("qwebr-editor-5");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-5");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `# Relative Hfkt. f√ºr 'male' als barplot
darkmode_p %>%
  ggplot(
    aes(x = dark_mode, fill = male)
    ) +
  geom_bar(position = "fill") +
  ylab("Anteil")`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-5-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-5-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script><p>Die graphische Analyse zeigt deutliche Unterschiede in den Verteilungen von <code>age</code> und <code>male</code> zwischen Kontroll- und Behandlungsgruppe. F√ºr einen Beurteilung mit deskriptiven Statistiken wird h√§ufig eine sogenannte <em>Balance Table</em> herangezogen. Wir berechnen diese f√ºr <code>age</code>, <code>hours</code> und <code>male</code> mit <code><a href="https://ngreifer.github.io/cobalt/reference/bal.tab.html">cobalt::bal.tab()</a></code></p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>
<div id="qwebr-interactive-area-6" class="qwebr-interactive-area">
  <div id="qwebr-console-area-6" class="qwebr-console-area">
    <div id="qwebr-editor-6" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-6">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-6" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-6" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-6");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-6");
  const editorDiv = document.getElementById("qwebr-editor-6");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-6");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `library(cobalt)

# Balance table mit 'cobalt::bal.tab()'
bal.tab(
  x = darkmode %>% 
    select(age, hours, male), 
  treat = darkmode$dark_mode, 
   # berechne SMD f√ºr KG und TG:
  disp = "m", 
  s.d.denom = "pooled"
)`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-6-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-6-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script><div class="page-columns page-full"><p>Die Eintr√§ge <code>M.0.Un</code> und <code>M.1.Un</code> zeigen die jeweiligen Stichprobenmittelwerte der Variablen f√ºr Kontroll- und Behandlungsgruppe. <code>Diff.U</code> gibt eine standardisierte Mittelwertdifferenz <span class="math inline">\(SMD\)</span> an, wobei <span class="math display">\[\begin{align*}
  SMD_j := \left(\overline{X}_{j,B} - \overline{X}_{j,K}\right) \bigg/ \sqrt{\frac{1}{2}\left(\widehat{\text{Var}}(X_{j,B}) + \widehat{\text{Var}}(X_{j,K})\right)},
\end{align*}\]</span> mit Stichprobenmitteln <span class="math inline">\(\overline{X}_{j,B}\)</span> und <span class="math inline">\(\overline{X}_{j,K}\)</span> und Stichprobenvarianzen <span class="math inline">\(\widehat{\text{Var}}(X_{j,B})\)</span> und <span class="math inline">\(\widehat{\text{Var}}(X_{j,K})\)</span> f√ºr eine kontinuierliche Kovariable <span class="math inline">\(j\)</span>.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> Obwohl es keinen einheitlichen Schwellenwert f√ºr die standardisierte Differenz gibt, der ein erhebliches Ungleichgewicht anzeigt, gilt f√ºr kontinuierliche Variablen eine standardisierte (absolute) Differenz von weniger als <span class="math inline">\(0.1\)</span> als Hinweis auf einen vernachl√§ssigbaren Unterschied zwischen den Gruppen.</p><div class="no-row-height column-margin column-container"><li id="fn1"><p><sup>1</sup>&nbsp;Siehe <span class="citation" data-cites="Austin2011">Austin (<a href="Literatur.html#ref-Austin2011" role="doc-biblioref">2011</a>)</span> f√ºr einen √úberblick zu Balance-Statistiken.</p></li></div></div>
<p>Die Balance Table weist also auf einen vernachl√§ssigbaren Unterschied f√ºr <code>hours</code> und best√§tigt die aus den Grafiken abgeleiteten Hinweise auf relevante Differenzen f√ºr <code>age</code> und <code>male</code>.</p>
</section><section id="section" class="level3" data-number="3.1.2"><h3 data-number="3.1.2" class="anchored" data-anchor-id="section">
<span class="header-section-number">3.1.2</span> </h3>
</section><section id="inverse-probability-weighting" class="level3" data-number="3.1.3"><h3 data-number="3.1.3" class="anchored" data-anchor-id="inverse-probability-weighting">
<span class="header-section-number">3.1.3</span> Inverse Probability Weighting</h3>
</section><section id="propensity-score" class="level3" data-number="3.1.4"><h3 data-number="3.1.4" class="anchored" data-anchor-id="propensity-score">
<span class="header-section-number">3.1.4</span> Propensity score</h3>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>
<div id="qwebr-interactive-area-7" class="qwebr-interactive-area">
  <div id="qwebr-console-area-7" class="qwebr-console-area">
    <div id="qwebr-editor-7" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-7">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-7" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-7" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-7");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-7");
  const editorDiv = document.getElementById("qwebr-editor-7");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-7");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `lm(
   formula = read_time ~ dark_mode + age + male + hours,
   data = darkmode
 ) %>%
   summary()`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-7-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-7-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script><style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>
<div id="qwebr-interactive-area-8" class="qwebr-interactive-area">
  <div id="qwebr-console-area-8" class="qwebr-console-area">
    <div id="qwebr-editor-8" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-8">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-8" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-8" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-8");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-8");
  const editorDiv = document.getElementById("qwebr-editor-8");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-8");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `# Logit-Modell mit 'glm()' sch√§tzen
(
  darkmode_ps_logit <- glm(
    formula = dark_mode ~ age + male + hours,
    data = darkmode,
    family = binomial
  )
)`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-8-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-8-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script><style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>
<div id="qwebr-interactive-area-9" class="qwebr-interactive-area">
  <div id="qwebr-console-area-9" class="qwebr-console-area">
    <div id="qwebr-editor-9" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-9">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-9" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-9" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-9");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-9");
  const editorDiv = document.getElementById("qwebr-editor-9");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-9");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `# Datensatz um propensity scores erweitern
(
  darkmode_probabilities <- 
    darkmode %>%
    mutate(
      propensity = fitted(darkmode_ps_logit)
    )
)`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-9-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-9-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script><p>Inverse probability weights (IPWs) anhand der PS k√∂nnen schnell anhand der Vorschrift <span class="math display">\[\texttt{ipw} = \texttt{dark\_mode} / \texttt{propensity} + (1 - \texttt{dark\_mode}) / (1 - \texttt{propensity}), \quad \texttt{dark\_mode} \in\{0,1\}\]</span> berechnet werden.</p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>
<div id="qwebr-interactive-area-10" class="qwebr-interactive-area">
  <div id="qwebr-console-area-10" class="qwebr-console-area">
    <div id="qwebr-editor-10" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-10">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-10" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-10" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-10");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-10");
  const editorDiv = document.getElementById("qwebr-editor-10");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-10");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `# Datensatz um IPWs erweitern
darkmode_ipw <- darkmode_probabilities %>%
  mutate(
    ipw = dark_mode / propensity + (1 - dark_mode) / (1 - propensity)
  )

darkmode_ipw %>% 
  select(ipw)`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-10-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-10-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script><p>Verteilung der Propensity Scores nach Behandlungs-Indikator:</p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>
<div id="qwebr-interactive-area-11" class="qwebr-interactive-area">
  <div id="qwebr-console-area-11" class="qwebr-console-area">
    <div id="qwebr-editor-11" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-11">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-11" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-11" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-11");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-11");
  const editorDiv = document.getElementById("qwebr-editor-11");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-11");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `# Dichtesch√§tzung der PS nach Treatment-Indikator
darkmode_ipw %>%
ggplot(
  mapping = aes(
    x = propensity, 
    fill = factor(dark_mode))
  ) + 
  lims(x = c(0, 1)) +
  geom_density(alpha = .5, )`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-11-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-11-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script><p>Beobachtungen aus der Kontroll-Gruppe entfernen, die au√üerhalb des Supports der Treatment-Gruppe liegen.</p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>
<div id="qwebr-interactive-area-12" class="qwebr-interactive-area">
  <div id="qwebr-console-area-12" class="qwebr-console-area">
    <div id="qwebr-editor-12" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-12">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-12" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-12" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-12");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-12");
  const editorDiv = document.getElementById("qwebr-editor-12");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-12");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `# Propensity scores auslesen
darkmode_ipws <- darkmode_ipw %>% 
  filter(dark_mode == 1) %>% 
  pull(propensity)

# Support sicherstellen 
# (entfernt 13 Beobachtungen aus der Kontrollgruppe)
darkmode_ipw <- darkmode_ipw %>% 
  filter(
    between(
      propensity,
      darkmode_ipws %>% 
        min(),
      darkmode_ipws %>% 
        max()
    )
  )`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-12-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-12-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script><p>Die Abdeckung k√∂nnen wir erneut mit einer Grafik gesch√§tzter Dichtefunktionen vergleichen.</p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>
<div id="qwebr-interactive-area-13" class="qwebr-interactive-area">
  <div id="qwebr-console-area-13" class="qwebr-console-area">
    <div id="qwebr-editor-13" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-13">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-13" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-13" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-13");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-13");
  const editorDiv = document.getElementById("qwebr-editor-13");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-13");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `# Dichtesch√§tzung der PS per Treatment-Indikator nach Anpassung
darkmode_ipw %>%
  ggplot(
    mapping = aes(
      x = propensity, 
      fill = factor(dark_mode)
    )
  ) + 
  lims(x = c(0, 1)) +
  geom_density(alpha = .5)`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-13-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-13-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script><p>Wir finden etwas weniger Wahrscheinlichkeits-Masse nahe 0 f√ºr die Kontroll-Gruppe nach filtern von (Kontroll-)Beobachtungen mit PS in der Spannweite der PS in der Behandlungs-Gruppe. Als n√§chstes sch√§tzen wir den ATE mit linearer Regression.</p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>
<div id="qwebr-interactive-area-14" class="qwebr-interactive-area">
  <div id="qwebr-console-area-14" class="qwebr-console-area">
    <div id="qwebr-editor-14" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-14">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-14" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-14" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-14");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-14");
  const editorDiv = document.getElementById("qwebr-editor-14");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-14");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `# Mit IPWs gewichteter KQ-Schaetzer berechnet einen ATE
model_ipw <- lm(
  formula = read_time ~ dark_mode, 
  data = darkmode_ipw,
  weights = ipw
)

summary(model_ipw)`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-14-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-14-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script><p>Unsere Sch√§tzung des ATE ist der gesch√§tzte Koeffizient von <code>dark_mode</code>. Die ausgegebenen Standardfehler und Inferenzstatistiken sind <em>ung√ºltig</em> aufgrund der Gewichtung mit IPWs, inversen <em>gesch√§tzten</em> Wahrscheinlichkeiten f√ºr eine Behandlung. Der Grund hierf√ºr ist, dass die Standardformel in <code><a href="https://rdrr.io/r/base/summary.html">summary()</a></code> die zus√§tzliche Unsicherheit durch die IPW-Sch√§tzung nicht ber√ºcksichtigt!</p>
<p>Die Vergleichbarkeit der Nutzer in Kontroll- und Behandlungsgruppe-Gruppe f√ºr die Variablen <code>age</code>, <code>hours</code> und <code>male</code> k√∂nnen wir graphisch und anhand einer <em>balance table</em> vergleichen.</p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>
<div id="qwebr-interactive-area-15" class="qwebr-interactive-area">
  <div id="qwebr-console-area-15" class="qwebr-console-area">
    <div id="qwebr-editor-15" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-15">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-15" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-15" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-15");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-15");
  const editorDiv = document.getElementById("qwebr-editor-15");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-15");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `# Dichtesch√§tzungen
darkmode %>% 
  group_by(dark_mode) %>%
  select(age, hours) %>%
  mutate_all(scale) %>% # Standardisierung mit 'scale()'
  pivot_longer(cols = c(-dark_mode)) %>% # langes Format
  
  ggplot(aes(x = value, fill = as.factor(dark_mode))) +
  geom_density( alpha = .5) + 
  facet_wrap(~ name, scales = "free", nrow = 3) # Facetting nach 'name'

# Relative Hfkt. f√ºr 'male' als barplot
darkmode %>% 
  group_by(dark_mode) %>%
  mutate(
    male = as.factor(male), 
    dark_mode = as.factor(dark_mode)
  ) %>%
  
  ggplot(aes(x = dark_mode, fill = male)) +
  geom_bar(position = "fill") +
  ylab("Anteil")

# Balance table mit 'cobalt::bal.tab()'
bal.tab(
  x = darkmode %>% 
    select(age, hours, male), 
  treat = darkmode$dark_mode, 
  disp = "m", # zeige zus√§tzlich Mittelwerte f√ºr C und T
)`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-15-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-15-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script><p>Wir zeigen als n√§chstes, wie <code><a href="https://kosukeimai.github.io/MatchIt/reference/matchit.html">MatchIt::matchit()</a></code> f√ºr Nearest-neighbor-Matching anhand der Regressoren <code>age</code>, <code>hours</code>, und <code>male</code> in unterschiedlichen Varianten durchgef√ºhrt werden kann.</p>
<p><code><a href="https://kosukeimai.github.io/MatchIt/reference/matchit.html">MatchIt::matchit()</a></code> f√ºhrt standardm√§√üig 1:1-Matching (ohne Zur√ºcklegen) von Beobachtungen der Treatment-Gruppe mit Beobachtungen der Kontrollgruppe druch. Das Objekt wird f√ºr eine Sch√§tzung des ATT mit einer geeigneten Funktionen vorbereitet, s. <code>?matchit</code>, und hier insb. die Argumente <code>replace = F</code>, <code>ratio = 1</code> und <code>estimand = "ATT"</code> f√ºr Details.</p>
<p>Mit <code>cobalt::balt.tab()</code> erhalten wir eine <em>balance table</em> f√ºr den gematchten Datensatz.</p>
<p><strong>Exaktes Matching</strong></p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>
<div id="qwebr-interactive-area-16" class="qwebr-interactive-area">
  <div id="qwebr-console-area-16" class="qwebr-console-area">
    <div id="qwebr-editor-16" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-16">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-16" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-16" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-16");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-16");
  const editorDiv = document.getElementById("qwebr-editor-16");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-16");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `res <- matchit(
  formula = dark_mode ~ age + male + hours, 
  data = darkmode, 
  method = "exact"
)
bal.tab(res)`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-16-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-16-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script><p><strong>Eins-zu-Eins-Matching: Mahalanobis-Distanz</strong></p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>
<div id="qwebr-interactive-area-17" class="qwebr-interactive-area">
  <div id="qwebr-console-area-17" class="qwebr-console-area">
    <div id="qwebr-editor-17" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-17">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-17" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-17" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-17");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-17");
  const editorDiv = document.getElementById("qwebr-editor-17");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-17");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `res <- matchit(
  formula = dark_mode ~ age + male + hours, 
  data = darkmode, 
  distance = "mahalanobis", 
  method = "nearest"
)
bal.tab(res)`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-17-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-17-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script><p><strong>Eins-zu-Eins-Matching: Mahalanobis-Distanz mit Caliper 0.25 f√ºr propensity scores basierend auf logistischer Regression</strong></p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>
<div id="qwebr-interactive-area-18" class="qwebr-interactive-area">
  <div id="qwebr-console-area-18" class="qwebr-console-area">
    <div id="qwebr-editor-18" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-18">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-18" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-18" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-18");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-18");
  const editorDiv = document.getElementById("qwebr-editor-18");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-18");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `res <- matchit(
  formula = dark_mode ~ age + male + hours, 
  data = darkmode, 
  distance = "glm", 
  caliper = .25,
  mahvars = ~ age + male + hours
)
# (Nur K-Beobachtungen mit PS bei Caliper .25 kommen f√ºr MHD-Matching in betracht.)
bal.tab(res)`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-18-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-18-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script><p><strong>4. Eins-zu-Eins-Matching: Propensity scores basierend auf logistischer Regression mit Caliper 0.25</strong></p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>
<div id="qwebr-interactive-area-19" class="qwebr-interactive-area">
  <div id="qwebr-console-area-19" class="qwebr-console-area">
    <div id="qwebr-editor-19" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-19">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-19" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-19" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-19");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-19");
  const editorDiv = document.getElementById("qwebr-editor-19");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-19");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `res <- matchit(
  formula = dark_mode ~ age + male + hours, 
  data = darkmode, 
  method = "nearest", 
  distance = "glm", 
  caliper = .25
)
bal.tab(res)`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-19-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-19-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script><p>Die Vergleichbarkeit der Nutzer in Kontroll- und Treatment-Gruppe hinsichtlich der Variablen <code>age</code>, <code>hours</code> und <code>male</code> k√∂nnen wir graphisch und anhand einer <em>balance table</em> vergleichen. Wir berechnen die balance table mit <code><a href="https://ngreifer.github.io/cobalt/reference/bal.tab.html">cobalt::bal.tab()</a></code> f√ºr den anhand von Variante 4 gematchten Datensatz.</p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>
<div id="qwebr-interactive-area-20" class="qwebr-interactive-area">
  <div id="qwebr-console-area-20" class="qwebr-console-area">
    <div id="qwebr-editor-20" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-20">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-20" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-20" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-20");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-20");
  const editorDiv = document.getElementById("qwebr-editor-20");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-20");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `bal.tab(res, un = T, disp = "m")

# Der gematchte Datensatz enth√§lt Gewichte f√ºr die jeweilige 
# Subklasse zu denen die Beobachtungen geh√∂ren.
#
# Hier 1:1 matching _ohne_ Zur√ºcklegen, d.h. s√§mtliche
# Gewichte sind 1 und wird m√ºssten diese nicht f√ºr nachfolgende 
# Aufrufe von avg comparisons ber√ºcksichtigen.
darkmode_matched <- match.data(res)

darkmode_matched %>%
  group_by(dark_mode) %>%
  select(age, hours) %>%
  mutate_all(scale) %>%
  pivot_longer(cols = c(-dark_mode)) %>%
  
  ggplot(aes(x = value, fill = as.factor(dark_mode))) +
  geom_density( alpha = .5) + 
  facet_wrap(~ name, scales = "free", nrow = 3)

darkmode_matched %>% 
  group_by(dark_mode) %>%
  mutate(
    male = as.factor(male), 
    dark_mode = as.factor(dark_mode)
  ) %>%
  
  ggplot(aes(x = dark_mode, fill = male)) +
  geom_bar(position = "fill") +
  ylab("Anteil")`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-20-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-20-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script><p>Wir beobachten eine bessere Balance bei <code>age</code> und <code>hours</code>. Am wichtigsten: <code>gender</code> (<code>male</code>) ist nahezu ausgeglichen f√ºr Kontroll- und Treatment-Gruppe!</p>
<p>Wir sch√§tzen nun den ATT von <code>dark_mode</code> auf <code>read_time</code> mit linearer Regression f√ºr den gematchten Datensatz aus sowie f√ºr den urspr√ºnglichen Datensatz und berechnen jeweils ein robustes 95%-Konfidenzintervall f√ºr den ATT.</p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>
<div id="qwebr-interactive-area-21" class="qwebr-interactive-area">
  <div id="qwebr-console-area-21" class="qwebr-console-area">
    <div id="qwebr-editor-21" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-21">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-21" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-21" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-21");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-21");
  const editorDiv = document.getElementById("qwebr-editor-21");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-21");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `# ATT mit linearem Modell f√ºr ungematchten Datensatz sch√§tzen
ATT_mod_org <- lm(
  formula = read_time ~ age + male + hours + dark_mode,
  data = darkmode
)
summary(ATT_mod_org)

# ATT mit linearem Modell f√ºr gematchten Datensatz sch√§tzen
ATT_mod <- lm(
  formula = read_time ~ age + male + hours + dark_mode,
  data = darkmode_matched, 
  weights = weights 
)
# (weights = 1 f√ºr alle Beobachtungen weil wg. 1:1-Matching
# nur 2er-Paare von Beobachtungen. Hier also vernachl√§ssigbar.
# Andere Gewichtung bei k:1-Matching!)
summary(ATT_mod)`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-21-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-21-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script><p><strong>Achtung</strong>: F√ºr Matching-Verfahren (<code>ATT_mod</code>) sind die von <code><a href="https://rdrr.io/r/base/summary.html">summary()</a></code> berechneten Standardfehler (und damit KI, t-Statistiken und p-Werte) f√ºr den ATT <em>grunds√§tzlich ung√ºltig</em> Wir haben 3 Quellen von Sch√§tzunsicherheit, die bei der Berechnung von Standardfehlern ber√ºcksichtigt werden m√ºssen: Die Sch√§tzung der PS, der Matching-Prozess und die ‚Äú√ºbliche‚Äù Stichproben-Variabilit√§t. Wir nutzen daher nachfolgende Funktionen gem. Empfehlungen aus der aktuellen Forschung f√ºr Standardfehlerberechnung. S. auch Aufgabe 5 (a).</p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>
<div id="qwebr-interactive-area-22" class="qwebr-interactive-area">
  <div id="qwebr-console-area-22" class="qwebr-console-area">
    <div id="qwebr-editor-22" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-22">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-22" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-22" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-22");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-22");
  const editorDiv = document.getElementById("qwebr-editor-22");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-22");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `library(marginaleffects)

# Inferenz Multiple Regression bei ungematchten Beobachtungen
# identisch zu 'coeftest(ATT_mod_org, vcovHC, type = "HC3")'
avg_comparisons(
  model = ATT_mod_org,
  variables = "dark_mode",
  vcov = "HC3", # Heteroskedastie-robuster SE
  newdata = subset(darkmode, dark_mode == 1) # Identifiziert Kontrollgruppe
) 

# Inferenz Multiple Regression bei _gematchten_ Beobachtungen
avg_comparisons(
  model = ATT_mod,
  variables = "dark_mode",
  vcov = ~subclass, # cluster robust SE > als oben => mehr Unsicherheit
  newdata = subset(darkmode_matched, dark_mode == 1),
  wts = "weights"  # = 1
)
# ( Weights = 1 wg. 1:1-Matching.
# Anzahl subclasses = Anzahl gematchter treatment/control units )`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-22-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-22-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script></section></section><section id="inferenz-f√ºr-attate-propensity-score-matching-mit-bootstrap" class="level2" data-number="3.2"><h2 data-number="3.2" class="anchored" data-anchor-id="inferenz-f√ºr-attate-propensity-score-matching-mit-bootstrap">
<span class="header-section-number">3.2</span> Inferenz f√ºr ATT/ATE: Propensity-Score-Matching mit Bootstrap</h2>
<p>Bei Matching mit Zur√ºcklegen besteht zus√§tzliche Unsicherheit durch Zur√ºcklegen, d.h. Beobachtungen aus der Kontroll-Gruppe k√∂nnen mehrfach als Match f√ºr Beobachtungen aus der Treatment-Gruppe genutzt werden. Mit <code><a href="https://rdrr.io/r/base/summary.html">summary()</a></code> berechnete Standardfehler ber√ºcksichtigen dies nicht!</p>
<p>Ein Bootstrap-Verfahren generiert mit Resampling (wiederholtes Ziehen mit Zur√ºcklegen) aus dem Original-Datensatz (viele) k√ºnstliche Datens√§tze, f√ºr die der Sch√§tzer (d.h. das gesamte Verfahren inkl. Matching!) jeweils berechnet wird. Die Verteilung der so gewonnenen Bootstrap-Sch√§tzwerte approximiert die wahre, unbekannte Stichprobenverteilung des Sch√§tzers des Behandlungseffekts. Mit dieser simulierten Verteilung k√∂nnen wir Inferenz betreiben: Wir k√∂nnen einen Bootstrap-Punktsch√§tzer des Behandlungseffekts (Stichprobenmittel der Bootstrap-Sch√§tzungen) sowie Standardfehler (Standardabweichung der der Bootstrap-Sch√§tzungen) und p-Werte berechnen.</p>
<p>Wir Implementieren nun einen Bootstrap-Sch√§tzer des ATT als <code>R</code>-Funktion <code>boot_fun()</code>.</p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>
<div id="qwebr-interactive-area-23" class="qwebr-interactive-area">
  <div id="qwebr-console-area-23" class="qwebr-console-area">
    <div id="qwebr-editor-23" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-23">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-23" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-23" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-23");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-23");
  const editorDiv = document.getElementById("qwebr-editor-23");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-23");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `boot_fun <- function(data, i) {
  
  boot_data <- data[i, ]
  
  # 1:1 PS Matching _mit_ Zur√ºcklegen
  match_res <- matchit(dark_mode ~ age + hours + male,
                       data = boot_data,
                       caliper = .25,
                       replace = TRUE) # Zur√ºcklegen
  
  # Gematchten Datensatz zuweisen
  darkmode_matched <- match.data(match_res, data = boot_data)
  
  # Outcome-Modell sch√§tzen
  ATT_mod <- lm(
    formula = read_time ~ age + male + hours + dark_mode,
    data = darkmode_matched, 
    weights = weights # hier teilweise > 1 wg. Matching mit Zur√ºcklegen!
  )
  
  #  ATT-Sch√§tzer auslesen
  return(
    ATT_mod$coefficients["dark_mode"]  
  )
}`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-23-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-23-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script><p>Abadie &amp; Imbens (2008) zeigen analytisch, dass ein Standard-Bootstrap bei Matching grunds√§tzlich ung√ºltig ist: Die unbekannte Varianz der Stichprobenverteilung des Matching-Sch√§tzers (und damit der Standardfehler des Sch√§tzers) kann durch den Bootstrap nicht repliziert werden. Problematisch hierbei sind grunds√§tzlich zu liberale (d.h. zu gro√üe) mit dem Bootstrap berechnete Standardfehler. Es gibt jedoch Simulationsnachweise die zeigen, dass Bootstrap-Standardfehler bei Matching mit Zur√ºcklegen konservativ sind (Bodory et al., 2020), also tendentiell zu kleine Standardfehler produzieren und damit das gew√ºnschte nominale Signifikanzniveau eines Bootstrap-Hypothesentests nicht √ºberschritten wird.</p>
<p>Wir berechnen nun eine Bootstrap-Sch√§tzung des ATT von <code>dark_mode</code> auf <code>readingtime</code> sowie den zugeh√∂rigen Standardfehler und ein 95%-KI mit der zuvor definierten Funktion <code>boot_fun</code>.</p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>
<div id="qwebr-interactive-area-24" class="qwebr-interactive-area">
  <div id="qwebr-console-area-24" class="qwebr-console-area">
    <div id="qwebr-editor-24" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-24">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-24" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-24" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-24");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-24");
  const editorDiv = document.getElementById("qwebr-editor-24");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-24");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `library("boot")
set.seed(4321)
boot_out <- boot(darkmode, boot_fun, R = 999)

boot_out`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-24-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-24-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script><style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>
<div id="qwebr-interactive-area-25" class="qwebr-interactive-area">
  <div id="qwebr-console-area-25" class="qwebr-console-area">
    <div id="qwebr-editor-25" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-25">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-25" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-25" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-25");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-25");
  const editorDiv = document.getElementById("qwebr-editor-25");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-25");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `# Bootstrap-Sch√§tzer f√ºr den Treatment-Effekt
mean(boot_out$t) 
# = mean(t0) + bias = mean(Bootstrap_samples)
# vgl. 't0 = boot_fun(darkmode, i = 1:1e3)'

# Bootstrap-Standardfehler
sd(boot_out$t)

# 95% Bootstrap-KI f√ºr den Treatment-Effekt
boot.ci(boot_out, type = "perc")`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-25-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-25-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script></section><section id="doubly-robust-sch√§tzer-f√ºr-attate" class="level2" data-number="3.3"><h2 data-number="3.3" class="anchored" data-anchor-id="doubly-robust-sch√§tzer-f√ºr-attate">
<span class="header-section-number">3.3</span> Doubly-Robust-Sch√§tzer f√ºr ATT/ATE</h2>
<p>Implementieren und berechnen Sie einen Doubly-Robust-Sch√§tzer des ATT (vgl. Wooldridge, 2010) f√ºr den kausalen Effekt in Aufgabe 5. Vergleichen Sie mit den Ergebnissen der Aufgaben 1 (d), 4 (f) und 5 (d).</p>
<style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>
<div id="qwebr-interactive-area-26" class="qwebr-interactive-area">
  <div id="qwebr-console-area-26" class="qwebr-console-area">
    <div id="qwebr-editor-26" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-26">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-26" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-26" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-26");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-26");
  const editorDiv = document.getElementById("qwebr-editor-26");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-26");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `# IPW estimation with regression adjustment
ipwra <- function(br, index = 1:nrow(br)) {
    # slice bootstrapped observations
    br <- br %>% slice(index)
    
    # estimate and predict propensity score
    m <- glm(formula = dark_mode ~ age + hours + male,
             data = br, 
             family = binomial(link = 'logit'))
    
    br <- br %>%
        mutate(ps = predict(m, type = 'response'))
    
    # trim control observations outside of treated PS range
    minps <- br %>%
        filter(dark_mode == 1) %>%
        pull(ps) %>%
        min(na.rm = TRUE)
    
    maxps <- br %>%
        filter(dark_mode == 1) %>%
        pull(ps) %>%
        max(na.rm = TRUE)
    
    # do the trimming
    br <- br %>%
        filter(ps >= minps & ps <= maxps)
    
    # compute IPWs
    br <- br %>%
      mutate(
        ipw = case_when(
          dark_mode == 1 ~ 1 / ps,
          dark_mode == 0 ~ 1 / (1 - ps))
      )
    
    # Simple _ATT_ estimate:
    # w_means <- br %>%
    #     group_by(dark_mode) %>%
    #     summarize(m = weighted.mean(read_time, w = ipw)) %>% 
    #     arrange(dark_mode)
    # 
    # # simple diff-in-means _ATT_ estimate
    #  return(w_means$m[2] - w_means$m[1]) 
    
    # Do regression adjustment for _ATE_ estimate
    # TE prediction for whole sample based on TG model
    mtreat <- br %>%
      filter(dark_mode == 1) %>%
      lm(read_time ~ 1 + age + hours + male, data = ., weights = .$ipw) %>%
      predict(newdata = br) %>%
      mean()
    
    # TE prediction for whole sample based on CG model
    mcont <- br %>%
      filter(dark_mode == 0) %>%
      lm(read_time ~ 1 + age + hours + male, data = ., weights = .$ipw) %>%
      predict(newdata = br) %>%
      mean()

    return(mtreat - mcont) # Regression adjusted _ATE_ estimate
}`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-26-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-26-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script><style>
.monaco-editor,
.overflow-guard,
.qwebr-editor {
  border-radius: 15px 15px 0 0;
  border-color: gray;
  border-bottom-width: 0;
}

.qwebr-button-run,
.qwebr-button-run:disabled {
    position: relative;
    z-index: 1;
    border: 2px solid darkgreen;
    color: white;
    background-color: darkgreen;
    border-radius: 0 0 15px 15px;
    width: 100%;
    height: 30px;
    -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

.qwebr-button-run:hover {
  position: relative;
  z-index: 1;
  border: 2px solid darkgreen;
  color: darkgreen;
  background-color: white;
  border-radius: 0 0 15px 15px;
  width: 100%;
  height: 30px;
  -webkit-box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3);
  box-shadow: 0px 5px 15px 5px rgba(0, 0, 0, 0.3); 
}

</style>
<div id="qwebr-interactive-area-27" class="qwebr-interactive-area">
  <div id="qwebr-console-area-27" class="qwebr-console-area">
    <div id="qwebr-editor-27" class="qwebr-editor"></div>
    <button class="btn btn-default qwebr-button-run" disabled="" type="button" id="qwebr-button-run-27">
      <i class="fas fa-cog fa-spin" alt="Ein sich drehendes Zahnrad."></i>
      R l√§dt. Etwas Geduld bitte‚Ä¶.
    </button>
    <div id="qwebr-output-code-area-27" class="qwebr-output-code-area" aria-live="assertive">
      <pre style="visibility: hidden"></pre>
    </div>
  </div>
  <div id="qwebr-output-graph-area-27" class="qwebr-output-graph-area">
  </div>
</div>
<script type="module">
  // Retrieve webR code cell information
  const runButton = document.getElementById("qwebr-button-run-27");
  const outputCodeDiv = document.getElementById("qwebr-output-code-area-27");
  const editorDiv = document.getElementById("qwebr-editor-27");
  const outputGraphDiv = document.getElementById("qwebr-output-graph-area-27");

  // Load the Monaco Editor and create an instance
  let editor;
  require(['vs/editor/editor.main'], function () {
    editor = monaco.editor.create(editorDiv, {
      value: `b <- boot(data = darkmode, ipwra, R = 999)
# Bootstrap estimate and standard error
mean(b$t)
sd(b$t)`,
      language: 'r',
      theme: 'vs-light',
      automaticLayout: true,           
      scrollBeyondLastLine: false,
      minimap: {
        enabled: false
      },
      padding: {
        top: 5,
        bottom: 5
      },
      fontSize: '14pt',               // Bootstrap is 1 rem
      renderLineHighlight: "none",     // Disable current line highlighting
      hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
      alwaysConsumeMouseWheel: false,
      scrollbar: {
        handleMouseWheel: false
      }
    });

    // Dynamically modify the height of the editor window if new lines are added.
    let ignoreEvent = false;
    const updateHeight = () => {
      const contentHeight = editor.getContentHeight();
      // We're avoiding a width change
      //editorDiv.style.width = `${width}px`;
      editorDiv.style.height = `${contentHeight}px`;
      try {
        ignoreEvent = true;

        // The key to resizing is this call
        editor.layout();
      } finally {
        ignoreEvent = false;
      }
    };

    // Helper function to check if selected text is empty
    function isEmptyCodeText(selectedCodeText) {
      return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
    }

    // Registry of keyboard shortcuts that should be re-added to each editor window
    // when focus changes.
    const addWebRKeyboardShortCutCommands = () => {
      // Add a keydown event listener for Shift+Enter to run all code in cell
      editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {

        // Retrieve all text inside the editor
        executeCode(editor.getValue());
      });

      // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {

        // Get the selected text from the editor
        const selectedText = editor.getModel().getValueInRange(editor.getSelection());
        // Check if no code is selected
        if (isEmptyCodeText(selectedText)) {
          // Obtain the current cursor position
          let currentPosition = editor.getPosition();
          // Retrieve the current line content
          let currentLine = editor.getModel().getLineContent(currentPosition.lineNumber);

          // Propose a new position to move the cursor to
          let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);

          // Check if the new position is beyond the last line of the editor
          if (newPosition.lineNumber > editor.getModel().getLineCount()) {
            // Add a new line at the end of the editor
            editor.executeEdits("addNewLine", [{
            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
            text: "\n", 
            forceMoveMarkers: true,
            }]);
          }
          
          // Run the entire line of code.
          executeCode(currentLine);

          // Move cursor to new position
          editor.setPosition(newPosition);
        } else {
          // Code to run when Ctrl+Enter is pressed with selected code
          executeCode(selectedText);
        }
      });
    }

    // Register an on focus event handler for when a code cell is selected to update
    // what keyboard shortcut commands should work.
    // This is a workaround to fix a regression that happened with multiple
    // editor windows since Monaco 0.32.0 
    // https://github.com/microsoft/monaco-editor/issues/2947
    editor.onDidFocusEditorText(addWebRKeyboardShortCutCommands);

    // Register an on change event for when new code is added to the editor window
    editor.onDidContentSizeChange(updateHeight);

    // Manually re-update height to account for the content we inserted into the call
    updateHeight();
  });

  // Function to execute the code (accepts code as an argument)
  async function executeCode(codeToRun) {

    // Disallowing execution of other code cells
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = true;
    });

    // Emphasize the active code cell
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span>';

    // Create a canvas variable for graphics
    let canvas = undefined;

    // Create a pager variable for help/file contents
    let pager = [];

    // Process 
    async function parseTypePager(msg) { 

        // Split out the event data
        const { path, title, deleteFile } = msg.data; 

        // Process the pager data by reading the information from disk
        const paged_data = await webR.FS.readFile(path).then((data) => {
          // Obtain the file content
          let content = new TextDecoder().decode(data);

          // Remove excessive backspace characters until none remain
          while(content.match(/.[\b]/)){
            content = content.replace(/.[\b]/g, '');
          }

          // Returned cleaned data
          return content;
        });

        // Unlink file if needed
        if (deleteFile) { 
          await webR.FS.unlink(path); 
        } 

        // Return extracted data with spaces
        return paged_data;
    } 

    // Initialize webR
    await webR.init();

    // Setup a webR canvas by making a namespace call into the {webr} package
    await webR.evalRVoid("webr::canvas(width=504, height=360)");

    // Capture output data from evaluating the code
    const result = await webRCodeShelter.captureR(codeToRun, {
      withAutoprint: true,
      captureStreams: true,
      captureConditions: false//,
      // env: webR.objs.emptyEnv, // maintain a global environment for webR v0.2.0
    });

    // Start attempting to parse the result data
    try {

      // Stop creating images
      await webR.evalRVoid("dev.off()");

      // Merge output streams of STDOUT and STDErr (messages and errors are combined.)
      const out = result.output
        .filter(evt => evt.type === "stdout" || evt.type === "stderr")
        .map((evt, index) => {
          const className = `qwebr-output-code-${evt.type}`;
          return `<code id="${className}-editor-27-result-${index + 1}" class="${className}">${evt.data}</code>`;
        })
        .join("\n");


      // Clean the state
      const msgs = await webR.flush();

      // Output each image event stored
      msgs.forEach((msg) => {
        // Determine if old canvas can be used or a new canvas is required.
        if (msg.type === 'canvas'){
          // Add image to the current canvas
          if (msg.data.event === 'canvasImage') {
            canvas.getContext('2d').drawImage(msg.data.image, 0, 0);
          } else if (msg.data.event === 'canvasNewPage') {
            // Generate a new canvas element
            canvas = document.createElement("canvas");
            canvas.setAttribute("width", 2 * 504);
            canvas.setAttribute("height", 2 * 360);
            canvas.style.width = "600px";
            canvas.style.display = "block";
            canvas.style.margin = "auto";
          }
        } 
      });

      // Use `map` to process the filtered "pager" events asynchronously
      const pager = await Promise.all(
        msgs.filter(msg => msg.type === 'pager').map(
          async (msg) => {
            return await parseTypePager(msg);
          }
        )
      );

      // Nullify the output area of content
      outputCodeDiv.innerHTML = "";
      outputGraphDiv.innerHTML = "";

      // Design an output object for messages
      const pre = document.createElement("pre");
      if (/\S/.test(out)) {
        // Display results as HTML elements to retain output styling
        const div = document.createElement("div");
        div.innerHTML = out;
        pre.appendChild(div);
      } else {
        // If nothing is present, hide the element.
        pre.style.visibility = "hidden";
      }
      outputCodeDiv.appendChild(pre);

      // Place the graphics on the canvas
      if (canvas) {
        outputGraphDiv.appendChild(canvas);
      }

      // Display the pager data
      if (pager) {
        // Use the `pre` element to preserve whitespace.
        pager.forEach((paged_data, index) => {
          let pre_pager = document.createElement("pre");
          pre_pager.innerText = paged_data;
          pre_pager.classList.add("qwebr-output-code-pager");
          pre_pager.setAttribute("id", "qwebr-output-code-pager-editor-27-result-" + (index + 1));
          outputCodeDiv.appendChild(pre_pager);
        });
      }
    } finally {
      // Clean up the remaining code
      webRCodeShelter.purge();
    }

    // Switch to allowing execution of code
    document.querySelectorAll(".qwebr-button-run").forEach((btn) => {
      btn.disabled = false;
    });

    // Revert to the initial code cell state
    runButton.innerHTML = '<span>R-Code ausf√ºhren.</span><i class="fa fa-sign-in"></i>';
  }

  // Add a click event listener to the run button
  runButton.onclick = function () {
    executeCode(editor.getValue());
  };
</script></section><section id="literatur" class="level1" data-number="4"><h1 data-number="4">
<span class="header-section-number">4</span> Literatur</h1>
<p>Abadie, Alberto, and Guido W. Imbens. (2008). <em>On the Failure of the Bootstrap for Matching Estimators.</em>Econometrica 76 (<strong>6</strong>): 1537‚Äì57.</p>
<p>Bodory, H., Camponovo, L., Huber, M., &amp; Lechner, M. (2020). <em>The Finite Sample Performance of Inference Methods for Propensity Score Matching and Weighting Estimators</em>. Journal of Business &amp; Economic Statistics, 38(<strong>1</strong>), 183‚Äì200.</p>
<p>Wooldridge, J. M. (2010). <em>Econometric analysis of cross section and panel data</em>. MIT press.</p>


<!-- -->

<div id="refs" class="references csl-bib-body hanging-indent" role="list" style="display: none">
<div id="ref-Austin2011" class="csl-entry" role="listitem">
Austin, P. 2011. <span>‚ÄûAn Introduction to Propensity Score Methods for Reducing the Effects of Confounding in Observational Studies‚Äú</span>. <em>Multivariate Behavioral Research</em> 46 (3): 399‚Äì424. <a href="https://doi.org/10.1080/00273171.2011.568786">https://doi.org/10.1080/00273171.2011.568786</a>.
</div>
</div>
</section></main><!-- /main --><script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "Óßã";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Kopiert");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Kopiert");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script><nav class="page-navigation"><div class="nav-page nav-page-previous">
      <a href="./R_Einfuehrung.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Statistische Programmierung mit R</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./RDD.html" class="pagination-link">
        <span class="nav-page-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Regression Discontiniuty Designs</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Quellcode</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb13" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="an">webr:</span><span class="co"> </span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="co">  show-startup-message: true</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="co">  packages: [</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="co">            'boot', </span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="co">            'cobalt', </span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="co">            'marginaleffects', </span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="co">            'MatchIt', </span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a><span class="co">            'sandwich',</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a><span class="co">            'ggplot2'</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a><span class="co">            ]</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a><span class="fu"># Matching</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a><span class="in">```{r, echo=F, message=FALSE}</span></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(gt)</span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(tidyverse)</span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Formatierung von gt-Tabellen</span></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a>tabopts <span class="ot">&lt;-</span> <span class="cf">function</span>(x) {</span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmt_number</span>(x, <span class="at">decimals =</span> <span class="dv">3</span>, <span class="at">drop_trailing_zeros =</span> T) <span class="sc">%&gt;%</span></span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a>  <span class="fu">tab_options</span>(<span class="at">table_body.hlines.color =</span> <span class="st">"white"</span>, </span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a>              <span class="at">column_labels.border.bottom.color =</span> <span class="st">"black"</span>, </span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a>             <span class="at">column_labels.border.top.color =</span> <span class="st">"black"</span>,</span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true" tabindex="-1"></a>             <span class="at">table_body.border.bottom.color =</span> <span class="st">"black"</span>, </span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true" tabindex="-1"></a>             <span class="at">table.border.bottom.color =</span> <span class="st">"black"</span>,</span>
<span id="cb13-27"><a href="#cb13-27" aria-hidden="true" tabindex="-1"></a>             <span class="at">column_labels.font.weight =</span> <span class="st">"bold"</span>, </span>
<span id="cb13-28"><a href="#cb13-28" aria-hidden="true" tabindex="-1"></a>             <span class="at">table.font.color =</span> <span class="st">"black"</span>, </span>
<span id="cb13-29"><a href="#cb13-29" aria-hidden="true" tabindex="-1"></a>             <span class="at">table.font.size =</span> <span class="dv">16</span>)</span>
<span id="cb13-30"><a href="#cb13-30" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb13-31"><a href="#cb13-31" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb13-32"><a href="#cb13-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-33"><a href="#cb13-33" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb13-34"><a href="#cb13-34" aria-hidden="true" tabindex="-1"></a><span class="in">#| context: setup</span></span>
<span id="cb13-35"><a href="#cb13-35" aria-hidden="true" tabindex="-1"></a><span class="in">webr::install("dplyr")</span></span>
<span id="cb13-36"><a href="#cb13-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-37"><a href="#cb13-37" aria-hidden="true" tabindex="-1"></a><span class="in"># create dataset directory</span></span>
<span id="cb13-38"><a href="#cb13-38" aria-hidden="true" tabindex="-1"></a><span class="in">dir.create("datasets")</span></span>
<span id="cb13-39"><a href="#cb13-39" aria-hidden="true" tabindex="-1"></a><span class="in"># Download the dataset</span></span>
<span id="cb13-40"><a href="#cb13-40" aria-hidden="true" tabindex="-1"></a><span class="in">download.file(</span></span>
<span id="cb13-41"><a href="#cb13-41" aria-hidden="true" tabindex="-1"></a><span class="in">    "https://raw.githubusercontent.com/mca91/kausal_data/main/darkmode.csv",</span></span>
<span id="cb13-42"><a href="#cb13-42" aria-hidden="true" tabindex="-1"></a><span class="in">    'datasets/darkmode.csv',</span></span>
<span id="cb13-43"><a href="#cb13-43" aria-hidden="true" tabindex="-1"></a><span class="in">)</span></span>
<span id="cb13-44"><a href="#cb13-44" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb13-45"><a href="#cb13-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-46"><a href="#cb13-46" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb13-47"><a href="#cb13-47" aria-hidden="true" tabindex="-1"></a><span class="in">#| context: setup</span></span>
<span id="cb13-48"><a href="#cb13-48" aria-hidden="true" tabindex="-1"></a><span class="in">library(dplyr)</span></span>
<span id="cb13-49"><a href="#cb13-49" aria-hidden="true" tabindex="-1"></a><span class="in"># make darkmode available using read.csv for now</span></span>
<span id="cb13-50"><a href="#cb13-50" aria-hidden="true" tabindex="-1"></a><span class="in"># because there's some issue with readr::read_csv</span></span>
<span id="cb13-51"><a href="#cb13-51" aria-hidden="true" tabindex="-1"></a><span class="in"># I can't fix right now</span></span>
<span id="cb13-52"><a href="#cb13-52" aria-hidden="true" tabindex="-1"></a><span class="in">darkmode &lt;- read.csv(</span></span>
<span id="cb13-53"><a href="#cb13-53" aria-hidden="true" tabindex="-1"></a><span class="in">    file = "datasets/darkmode.csv", </span></span>
<span id="cb13-54"><a href="#cb13-54" aria-hidden="true" tabindex="-1"></a><span class="in">    colClasses = c("numeric", "logical", "numeric", "numeric", "numeric") </span></span>
<span id="cb13-55"><a href="#cb13-55" aria-hidden="true" tabindex="-1"></a><span class="in">)</span></span>
<span id="cb13-56"><a href="#cb13-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-57"><a href="#cb13-57" aria-hidden="true" tabindex="-1"></a><span class="in">options(pillar.bold = TRUE, pillar.subtle = FALSE)</span></span>
<span id="cb13-58"><a href="#cb13-58" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb13-59"><a href="#cb13-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-60"><a href="#cb13-60" aria-hidden="true" tabindex="-1"></a>In randomisierten kontrollierten Studien stellt eine randomisierte Behandlung sicher, dass die Individuen beider Gruppen im Mittel vergleichbar sind, dass hei√üt es gibt keine systematischen Unterschiede der Studiensubjekte hinsichtlich der Verteilung von Charakteristika zwischen den Gruppen. Dann ist es plausibel eine beobachtete mittlere Differenz in der Outcome-Variable alleine auf die Behandlung zur√ºckzuf√ºhren.</span>
<span id="cb13-61"><a href="#cb13-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-62"><a href="#cb13-62" aria-hidden="true" tabindex="-1"></a>In der Praxis, insbesondere in √∂konomischen Studien, sind randomisierte kontrollierte Studien aus ethischen und/oder finanziellen Gr√ºnden nicht durchf√ºhrbar. Stattdessen werden nicht-experimentelle Daten genutzt, die jedoch nur sehr selten eine Vergleichbarkeit von Behandlungs- und Kontrollgruppe gew√§hrleisten.</span>
<span id="cb13-63"><a href="#cb13-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-64"><a href="#cb13-64" aria-hidden="true" tabindex="-1"></a>In diesem Kapitel betrachten wir Methoden, die in solchen Forschungsdesigns -- bei hinreichenden Informationen √ºber die Studiensubjekte -- eine Sch√§tzung kausaler Effekte erm√∂glichen, indem eine Vergleichbarkeit von Behandlungs- und Kontrollgruppe hergestellt wird. Dies kann √ºber eine gezielte Gewichtung von Beobachtungen anhand invididueller Merkmale erfolgen. Eine etablierte Methode ist die Sch√§tzung des kausalen Effekts nach Selektion von vergleichbaren Teilmengen von Subjekten beider Gruppen aus der urspr√ºnglichen Stichprobe, sogenanntes *Matching*.</span>
<span id="cb13-65"><a href="#cb13-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-66"><a href="#cb13-66" aria-hidden="true" tabindex="-1"></a><span class="fu">## Gewichtete Mittelwerte und Matching</span></span>
<span id="cb13-67"><a href="#cb13-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-68"><a href="#cb13-68" aria-hidden="true" tabindex="-1"></a>Der Lehrstuhl f√ºr √ñkonometrie an der Universit√§t Duisburg-Essen verwaltet betreibt einen √ñkonometrie-Blog und interessiert sich f√ºr den kausalen Effekt der Einf√ºhrung eines <span class="co">[</span><span class="ot">darkmode</span><span class="co">](https://en.wikipedia.org/wiki/Wikipedia:Dark_mode)</span> auf die Verweildauer der User auf der Webseite. Die Webseite ist zwar nicht-kommerziell, hat sich allerdings insb. f√ºr die Aquise internationaler Studierender f√ºr den Studiengang MSc. Econometrics als wichtiges Marketing-Instrument erwiesen. Ein anprechendes Design wird daher als hoch-relevant erachtet. </span>
<span id="cb13-69"><a href="#cb13-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-70"><a href="#cb13-70" aria-hidden="true" tabindex="-1"></a>Idealerweise sollte der Effekt des Design-Relaunches auf die Nutzungsintensit√§t in einem kontrollierten randomisierten Experiment untersucht werden. Hierbei w√ºrden wir Nutzern zuf√§llig das neue oder das alte Design zuweisen und den Effekt als Differnz des durchschnittlichen Verweildauer f√ºr die Gruppen bestimmen. Eine solche Studie ist jedoch aus technischen und finanziellen Gr√ºnden nicht realisierbar, sodass die Auswirkungen des darkmode mit vorliegenden nicht-experimenellen Nutzungsstatistiken f√ºr die Webseite gesch√§tzt werden sollen. </span>
<span id="cb13-71"><a href="#cb13-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-72"><a href="#cb13-72" aria-hidden="true" tabindex="-1"></a>Die Nutzungsstatistiken sind im Datensatz <span class="co">[</span><span class="ot">*darkmode.csv*</span><span class="co">](https://raw.githubusercontent.com/mca91/kasa_data/main/darkmode.csv)</span> enthalten und sollen der Analyse des Effekts des darkmode (<span class="in">`dark_mode`</span>) auf die Verweildauer der Leser auf der Webseite (<span class="in">`read_time`</span>) dienen.</span>
<span id="cb13-73"><a href="#cb13-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-74"><a href="#cb13-74" aria-hidden="true" tabindex="-1"></a>@tbl-darkmode zeigt die Definitionen der Variablen in *darkmode.csv*.</span>
<span id="cb13-75"><a href="#cb13-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-76"><a href="#cb13-76" aria-hidden="true" tabindex="-1"></a><span class="in">```{r, echo = F}</span></span>
<span id="cb13-77"><a href="#cb13-77" aria-hidden="true" tabindex="-1"></a><span class="co">#| tbl-cap: "Variablen im Datensatz *darkmode*"</span></span>
<span id="cb13-78"><a href="#cb13-78" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: tbl-darkmode</span></span>
<span id="cb13-79"><a href="#cb13-79" aria-hidden="true" tabindex="-1"></a><span class="fu">tibble</span>(</span>
<span id="cb13-80"><a href="#cb13-80" aria-hidden="true" tabindex="-1"></a>  <span class="at">Variable =</span> <span class="fu">c</span>(</span>
<span id="cb13-81"><a href="#cb13-81" aria-hidden="true" tabindex="-1"></a>    <span class="st">"read_time"</span>, </span>
<span id="cb13-82"><a href="#cb13-82" aria-hidden="true" tabindex="-1"></a>    <span class="st">"dark_mode"</span>, </span>
<span id="cb13-83"><a href="#cb13-83" aria-hidden="true" tabindex="-1"></a>    <span class="st">"male"</span>, </span>
<span id="cb13-84"><a href="#cb13-84" aria-hidden="true" tabindex="-1"></a>    <span class="st">"age"</span>, </span>
<span id="cb13-85"><a href="#cb13-85" aria-hidden="true" tabindex="-1"></a>    <span class="st">"hours"</span></span>
<span id="cb13-86"><a href="#cb13-86" aria-hidden="true" tabindex="-1"></a>    ),</span>
<span id="cb13-87"><a href="#cb13-87" aria-hidden="true" tabindex="-1"></a>  <span class="at">Beschreibung =</span> <span class="fu">c</span>(</span>
<span id="cb13-88"><a href="#cb13-88" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Lesezeit (Minuten/Woche)"</span>,</span>
<span id="cb13-89"><a href="#cb13-89" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Indikator: Beobachtung nach Einf√ºhrung darkmode"</span>,</span>
<span id="cb13-90"><a href="#cb13-90" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Indikator: Individuum m√§nnlich"</span>,</span>
<span id="cb13-91"><a href="#cb13-91" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Alter (in Jahren)"</span>,</span>
<span id="cb13-92"><a href="#cb13-92" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Bisherige Verweildauer auf der Seite"</span></span>
<span id="cb13-93"><a href="#cb13-93" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb13-94"><a href="#cb13-94" aria-hidden="true" tabindex="-1"></a>) <span class="sc">%&gt;%</span></span>
<span id="cb13-95"><a href="#cb13-95" aria-hidden="true" tabindex="-1"></a>  <span class="fu">gt</span>() <span class="sc">%&gt;%</span></span>
<span id="cb13-96"><a href="#cb13-96" aria-hidden="true" tabindex="-1"></a>  tabopts</span>
<span id="cb13-97"><a href="#cb13-97" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb13-98"><a href="#cb13-98" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-99"><a href="#cb13-99" aria-hidden="true" tabindex="-1"></a>F√ºr die Analyse lesen wir zun√§chst den Datensatz *darkmode.csv* mit <span class="in">`readr::read_csv()`</span> ein und verschaffen uns einen √úberblick √ºber die verf√ºgbaren Variablen. </span>
<span id="cb13-100"><a href="#cb13-100" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-101"><a href="#cb13-101" aria-hidden="true" tabindex="-1"></a><span class="in">```{r, message=FALSE}</span></span>
<span id="cb13-102"><a href="#cb13-102" aria-hidden="true" tabindex="-1"></a><span class="co"># Paket `tidyverse` laden</span></span>
<span id="cb13-103"><a href="#cb13-103" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(tidyverse)</span>
<span id="cb13-104"><a href="#cb13-104" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-105"><a href="#cb13-105" aria-hidden="true" tabindex="-1"></a><span class="co"># Datensatz 'darkmode' einlesen</span></span>
<span id="cb13-106"><a href="#cb13-106" aria-hidden="true" tabindex="-1"></a>darkmode <span class="ot">&lt;-</span> <span class="fu">read_csv</span>(</span>
<span id="cb13-107"><a href="#cb13-107" aria-hidden="true" tabindex="-1"></a>  <span class="at">file =</span> <span class="st">"datasets/darkmode.csv"</span></span>
<span id="cb13-108"><a href="#cb13-108" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb13-109"><a href="#cb13-109" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb13-110"><a href="#cb13-110" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-111"><a href="#cb13-111" aria-hidden="true" tabindex="-1"></a><span class="in">`dark_mode`</span> hat den Typ <span class="in">`logical`</span>. Mit <span class="in">`dplyr::mutate_all()`</span> k√∂nnen wir komfortabel alle Spalten in den Typ <span class="in">`numeric`</span> transformieren.</span>
<span id="cb13-112"><a href="#cb13-112" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-115"><a href="#cb13-115" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb13-116"><a href="#cb13-116" aria-hidden="true" tabindex="-1"></a><span class="co"># Alle Variablen zu typ 'numeric' formatieren...</span></span>
<span id="cb13-117"><a href="#cb13-117" aria-hidden="true" tabindex="-1"></a>darkmode <span class="ot">&lt;-</span> darkmode <span class="sc">%&gt;%</span> </span>
<span id="cb13-118"><a href="#cb13-118" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate_all</span>(<span class="at">.funs =</span> as.numeric)</span>
<span id="cb13-119"><a href="#cb13-119" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-120"><a href="#cb13-120" aria-hidden="true" tabindex="-1"></a><span class="co"># ... und √ºberpr√ºfen</span></span>
<span id="cb13-121"><a href="#cb13-121" aria-hidden="true" tabindex="-1"></a><span class="fu">glimpse</span>(darkmode)</span>
<span id="cb13-122"><a href="#cb13-122" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb13-123"><a href="#cb13-123" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-124"><a href="#cb13-124" aria-hidden="true" tabindex="-1"></a>Eine naive Sch√§tzung des durchschnittlichen Behandlungseffekts (ATE) $\widehat{\tau}^{\text{naiv}}$ erhalten wir als Mittelwertdifferenz von <span class="in">`read_time`</span> f√ºr die Behandlungsgruppe (<span class="in">`dark_mode == 1`</span>) und die Kontrollgruppe (<span class="in">`dark_mode == 0`</span>)</span>
<span id="cb13-125"><a href="#cb13-125" aria-hidden="true" tabindex="-1"></a>\begin{align}</span>
<span id="cb13-126"><a href="#cb13-126" aria-hidden="true" tabindex="-1"></a>  \widehat{\tau}^{\text{naiv}} = \overline{\text{read<span class="sc">\_</span>time}}_{\text{Behandlung}} - \overline{\text{read\_time}}_{\text{Kontrolle}}.\label{eq:naivATEdarkmode}</span>
<span id="cb13-127"><a href="#cb13-127" aria-hidden="true" tabindex="-1"></a>\end{align}</span>
<span id="cb13-128"><a href="#cb13-128" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-129"><a href="#cb13-129" aria-hidden="true" tabindex="-1"></a>Diese Berechnung ist schnell mit R durchgef√ºhrt.</span>
<span id="cb13-130"><a href="#cb13-130" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-133"><a href="#cb13-133" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb13-134"><a href="#cb13-134" aria-hidden="true" tabindex="-1"></a><span class="co"># Naiver Sch√§tzer f√ºr ATE: </span></span>
<span id="cb13-135"><a href="#cb13-135" aria-hidden="true" tabindex="-1"></a><span class="co"># Differenz der Gruppen-Durchschnitte</span></span>
<span id="cb13-136"><a href="#cb13-136" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-137"><a href="#cb13-137" aria-hidden="true" tabindex="-1"></a><span class="co"># Outcome in Behandlungsgruppe</span></span>
<span id="cb13-138"><a href="#cb13-138" aria-hidden="true" tabindex="-1"></a>read_time_mTG <span class="ot">&lt;-</span> darkmode <span class="sc">%&gt;%</span> </span>
<span id="cb13-139"><a href="#cb13-139" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(dark_mode <span class="sc">==</span> <span class="dv">1</span>) <span class="sc">%&gt;%</span> </span>
<span id="cb13-140"><a href="#cb13-140" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pull</span>(<span class="st">"read_time"</span>)</span>
<span id="cb13-141"><a href="#cb13-141" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-142"><a href="#cb13-142" aria-hidden="true" tabindex="-1"></a><span class="co"># Outcome in Kontrollgruppe</span></span>
<span id="cb13-143"><a href="#cb13-143" aria-hidden="true" tabindex="-1"></a>read_time_mKG <span class="ot">&lt;-</span> darkmode <span class="sc">%&gt;%</span> </span>
<span id="cb13-144"><a href="#cb13-144" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(dark_mode <span class="sc">==</span> <span class="dv">0</span>) <span class="sc">%&gt;%</span> </span>
<span id="cb13-145"><a href="#cb13-145" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pull</span>(<span class="st">"read_time"</span>)</span>
<span id="cb13-146"><a href="#cb13-146" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-147"><a href="#cb13-147" aria-hidden="true" tabindex="-1"></a><span class="co"># Mittelwert-Differenz</span></span>
<span id="cb13-148"><a href="#cb13-148" aria-hidden="true" tabindex="-1"></a><span class="fu">mean</span>(read_time_mTG) <span class="sc">-</span> <span class="fu">mean</span>(read_time_mKG)</span>
<span id="cb13-149"><a href="#cb13-149" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb13-150"><a href="#cb13-150" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-151"><a href="#cb13-151" aria-hidden="true" tabindex="-1"></a>Die Sch√§tzung ergibt einen negativen Behandlungseffekt, mit der Interpreation, dass das neue Design zu einer Reduktion der Lesezeit um etwa 0.44 Minuten pro Woche f√ºhrt. Dieses Ergebnis ist allerdings zweifelhaft, weil eine Isolierung des Behandlungseffekts aufgrund von Backdoor-Pfaden im DGP vermutlich nicht gew√§hleistet ist. Ein Indikator hierf√ºr sind systematische Unterschiede hinsichtlich von (m√∂glicherweise unbeobachtbaren) Charakteristika von Kontrollgruppe und Behandlungsgruppe.</span>
<span id="cb13-152"><a href="#cb13-152" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-153"><a href="#cb13-153" aria-hidden="true" tabindex="-1"></a>Da die User sich beim Aufrufen der Seite aktiv f√ºr oder gegen den das neue Design entscheiden m√ºssen (und somit selektieren, ob Sie in der Behandlungs- oder Kontrollgruppe landen), liegt wahrscheinlich *Confounding* vor: Unsere Hypothese ist zun√§chst, dass m√§nnliche User eine durchschnittlich l√§ngere Lesezeit aufweisen *und* mit gr√∂√üerer Wahrscheinlichkeit auf das neue Design wechseln als nicht-m√§nnliche Leser. Dann ist <span class="in">`male`</span> eine Backdoor-Variable. Diese Situation ist unter der Annahme, dass nur diese Faktoren den DGP bestimmen, in @fig-maleCDdarkmode dargestellt.</span>
<span id="cb13-154"><a href="#cb13-154" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-157"><a href="#cb13-157" aria-hidden="true" tabindex="-1"></a><span class="in">```{dot}</span></span>
<span id="cb13-158"><a href="#cb13-158" aria-hidden="true" tabindex="-1"></a>//| fig<span class="ot">-w</span>idth: <span class="dv">4</span></span>
<span id="cb13-159"><a href="#cb13-159" aria-hidden="true" tabindex="-1"></a>//| fig-height: <span class="dv">3</span></span>
<span id="cb13-160"><a href="#cb13-160" aria-hidden="true" tabindex="-1"></a>//| fig-align: <span class="ot">'</span><span class="ss">center</span><span class="ot">'</span></span>
<span id="cb13-161"><a href="#cb13-161" aria-hidden="true" tabindex="-1"></a>//| fig<span class="ot">-c</span>ap: <span class="ot">"</span><span class="st">Backdoor durch 'male' im Website-Design-Bespiel</span><span class="ot">"</span></span>
<span id="cb13-162"><a href="#cb13-162" aria-hidden="true" tabindex="-1"></a>//| label: <span class="ot">"</span><span class="st">fig-maleCDdarkmode</span><span class="ot">"</span> </span>
<span id="cb13-163"><a href="#cb13-163" aria-hidden="true" tabindex="-1"></a>digraph {</span>
<span id="cb13-164"><a href="#cb13-164" aria-hidden="true" tabindex="-1"></a>  layout=neato</span>
<span id="cb13-165"><a href="#cb13-165" aria-hidden="true" tabindex="-1"></a>  fontname=<span class="ot">"</span><span class="st">Helvetica,Arial,sans-serif</span><span class="ot">"</span></span>
<span id="cb13-166"><a href="#cb13-166" aria-hidden="true" tabindex="-1"></a>  node [fontname=<span class="ot">"</span><span class="st">Helvetica,Arial,sans-serif</span><span class="ot">"</span>]</span>
<span id="cb13-167"><a href="#cb13-167" aria-hidden="true" tabindex="-1"></a>  edge [fontname=<span class="ot">"</span><span class="st">Helvetica,Arial,sans-serif</span><span class="ot">"</span>]</span>
<span id="cb13-168"><a href="#cb13-168" aria-hidden="true" tabindex="-1"></a>  node [shape=none];</span>
<span id="cb13-169"><a href="#cb13-169" aria-hidden="true" tabindex="-1"></a>  <span class="ot">"</span><span class="st">read_time</span><span class="ot">"</span> [<span class="fu">pos</span>=<span class="ot">"</span><span class="st">4,0.5!</span><span class="ot">"</span>]</span>
<span id="cb13-170"><a href="#cb13-170" aria-hidden="true" tabindex="-1"></a>  <span class="ot">"</span><span class="st">dark_mode</span><span class="ot">"</span> [<span class="fu">pos</span>=<span class="ot">"</span><span class="st">0,0.5!</span><span class="ot">"</span>]</span>
<span id="cb13-171"><a href="#cb13-171" aria-hidden="true" tabindex="-1"></a>  <span class="ot">"</span><span class="st">male</span><span class="ot">"</span> [<span class="fu">pos</span>=<span class="ot">"</span><span class="st">2,-1!</span><span class="ot">"</span>]</span>
<span id="cb13-172"><a href="#cb13-172" aria-hidden="true" tabindex="-1"></a>  <span class="ot">"</span><span class="st">dark_mode</span><span class="ot">"</span> -&gt; <span class="ot">"</span><span class="st">read_time</span><span class="ot">"</span> [color=<span class="ot">"</span><span class="st">green</span><span class="ot">"</span>]</span>
<span id="cb13-173"><a href="#cb13-173" aria-hidden="true" tabindex="-1"></a>  <span class="ot">"</span><span class="st">male</span><span class="ot">"</span> -&gt; <span class="ot">"</span><span class="st">dark_mode</span><span class="ot">"</span> [color=<span class="ot">"</span><span class="st">red</span><span class="ot">"</span>]</span>
<span id="cb13-174"><a href="#cb13-174" aria-hidden="true" tabindex="-1"></a>  <span class="ot">"</span><span class="st">male</span><span class="ot">"</span> -&gt; <span class="ot">"</span><span class="st">read_time</span><span class="ot">"</span> [color=<span class="ot">"</span><span class="st">red</span><span class="ot">"</span>]</span>
<span id="cb13-175"><a href="#cb13-175" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb13-176"><a href="#cb13-176" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb13-177"><a href="#cb13-177" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-178"><a href="#cb13-178" aria-hidden="true" tabindex="-1"></a>Der DGP in @fig-maleCDdarkmode f√ºhrt zu einer verzerrten Sch√§tzung des kausalen Effekts von <span class="in">`dark_mode`</span> auf <span class="in">`read_time`</span> mit \eqref{eq:naivATEdarkmode}, wenn das Verh√§ltnis von m√§nnlichen und nicht-m√§nnlichen Usern in Bahandlungs- und Kontrollgruppe sich systematisch unterscheided. Wir √ºberpr√ºfen dies mit R.</span>
<span id="cb13-179"><a href="#cb13-179" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-182"><a href="#cb13-182" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb13-183"><a href="#cb13-183" aria-hidden="true" tabindex="-1"></a><span class="co"># Anteile m√§nnlicher und nicht-m√§nnlicher User</span></span>
<span id="cb13-184"><a href="#cb13-184" aria-hidden="true" tabindex="-1"></a>(</span>
<span id="cb13-185"><a href="#cb13-185" aria-hidden="true" tabindex="-1"></a>  anteile <span class="ot">&lt;-</span> darkmode <span class="sc">%&gt;%</span> </span>
<span id="cb13-186"><a href="#cb13-186" aria-hidden="true" tabindex="-1"></a>  <span class="fu">group_by</span>(dark_mode) <span class="sc">%&gt;%</span> </span>
<span id="cb13-187"><a href="#cb13-187" aria-hidden="true" tabindex="-1"></a>  <span class="fu">summarise</span>(</span>
<span id="cb13-188"><a href="#cb13-188" aria-hidden="true" tabindex="-1"></a>    <span class="at">gesamt =</span> <span class="fu">n</span>(),</span>
<span id="cb13-189"><a href="#cb13-189" aria-hidden="true" tabindex="-1"></a>    <span class="at">ant_m =</span> <span class="fu">mean</span>(male),</span>
<span id="cb13-190"><a href="#cb13-190" aria-hidden="true" tabindex="-1"></a>    <span class="at">ant_nm =</span> <span class="dv">1</span> <span class="sc">-</span> ant_m,</span>
<span id="cb13-191"><a href="#cb13-191" aria-hidden="true" tabindex="-1"></a>    <span class="at">anz_m =</span> <span class="fu">sum</span>(male),</span>
<span id="cb13-192"><a href="#cb13-192" aria-hidden="true" tabindex="-1"></a>    <span class="at">anz_nm =</span> gesamt <span class="sc">-</span> anz_m</span>
<span id="cb13-193"><a href="#cb13-193" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb13-194"><a href="#cb13-194" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb13-195"><a href="#cb13-195" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb13-196"><a href="#cb13-196" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-197"><a href="#cb13-197" aria-hidden="true" tabindex="-1"></a>Die Zusammenfassung <span class="in">`anteile_m`</span> zeigt, dass der Anteil m√§nnlicher User in der Behandlungsgruppe deutlich h√∂her ist als in der Kontrollgruppe.</span>
<span id="cb13-198"><a href="#cb13-198" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-199"><a href="#cb13-199" aria-hidden="true" tabindex="-1"></a>Ein Sch√§tzer basierend auf einem Matching eliminiert die Variation von <span class="in">`male`</span> zwischen den Gruppen. Eine M√∂glichkeit hierf√ºr ist die Gewichtung der Beobachtungen in der Kontrollgruppe entsprechend der Anteile von M√∂nnern und Nicht-M√§nnern in der Behandlungsgruppe, sodass die Vergleichbarkeit hinsichtlich des Geschlechts gew√§hrleistet ist. Hierzu berechnen wir zun√§chst die Gewichte als</span>
<span id="cb13-200"><a href="#cb13-200" aria-hidden="true" tabindex="-1"></a>\begin{align}</span>
<span id="cb13-201"><a href="#cb13-201" aria-hidden="true" tabindex="-1"></a>  w_i = </span>
<span id="cb13-202"><a href="#cb13-202" aria-hidden="true" tabindex="-1"></a>  \begin{cases}</span>
<span id="cb13-203"><a href="#cb13-203" aria-hidden="true" tabindex="-1"></a>    \text{ant<span class="sc">\_</span>m}_B/\text{anz\_m}_{K}, &amp; \text{falls } \text{male}_i = 1<span class="sc">\\</span></span>
<span id="cb13-204"><a href="#cb13-204" aria-hidden="true" tabindex="-1"></a>        \text{ant<span class="sc">\_</span>nm}_B/\text{anz\_nm}_{K}, &amp; \text{sonst.}<span class="sc">\\</span></span>
<span id="cb13-205"><a href="#cb13-205" aria-hidden="true" tabindex="-1"></a>  \end{cases}</span>
<span id="cb13-206"><a href="#cb13-206" aria-hidden="true" tabindex="-1"></a>\end{align}</span>
<span id="cb13-207"><a href="#cb13-207" aria-hidden="true" tabindex="-1"></a>Anhand der Formel</span>
<span id="cb13-208"><a href="#cb13-208" aria-hidden="true" tabindex="-1"></a>\begin{align}</span>
<span id="cb13-209"><a href="#cb13-209" aria-hidden="true" tabindex="-1"></a>  \overline{X}_w = \frac{\sum_i w_i \cdot X_i}{\sum_i w_i}</span>
<span id="cb13-210"><a href="#cb13-210" aria-hidden="true" tabindex="-1"></a>\end{align}</span>
<span id="cb13-211"><a href="#cb13-211" aria-hidden="true" tabindex="-1"></a>berechnen wir die gewichteten Mittelwerte f√ºr <span class="in">`male`</span> und <span class="in">`read_time`</span> in der Kontrollgruppe.</span>
<span id="cb13-212"><a href="#cb13-212" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-215"><a href="#cb13-215" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb13-216"><a href="#cb13-216" aria-hidden="true" tabindex="-1"></a><span class="co"># Anteile und Anzahlen auslesen</span></span>
<span id="cb13-217"><a href="#cb13-217" aria-hidden="true" tabindex="-1"></a>anz_m_K <span class="ot">&lt;-</span> anteile <span class="sc">%&gt;%</span> </span>
<span id="cb13-218"><a href="#cb13-218" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(dark_mode <span class="sc">==</span> <span class="dv">0</span>) <span class="sc">%&gt;%</span> <span class="fu">pull</span>(anz_m)</span>
<span id="cb13-219"><a href="#cb13-219" aria-hidden="true" tabindex="-1"></a>anz_nm_K <span class="ot">&lt;-</span> anteile <span class="sc">%&gt;%</span> </span>
<span id="cb13-220"><a href="#cb13-220" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(dark_mode <span class="sc">==</span> <span class="dv">0</span>) <span class="sc">%&gt;%</span> <span class="fu">pull</span>(anz_nm)</span>
<span id="cb13-221"><a href="#cb13-221" aria-hidden="true" tabindex="-1"></a>ant_m_B <span class="ot">&lt;-</span> anteile <span class="sc">%&gt;%</span> </span>
<span id="cb13-222"><a href="#cb13-222" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(dark_mode <span class="sc">==</span> <span class="dv">1</span>) <span class="sc">%&gt;%</span> <span class="fu">pull</span>(ant_m)</span>
<span id="cb13-223"><a href="#cb13-223" aria-hidden="true" tabindex="-1"></a>ant_nm_B <span class="ot">&lt;-</span> anteile <span class="sc">%&gt;%</span> </span>
<span id="cb13-224"><a href="#cb13-224" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(dark_mode <span class="sc">==</span> <span class="dv">1</span>) <span class="sc">%&gt;%</span> <span class="fu">pull</span>(ant_nm)</span>
<span id="cb13-225"><a href="#cb13-225" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb13-226"><a href="#cb13-226" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-229"><a href="#cb13-229" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb13-230"><a href="#cb13-230" aria-hidden="true" tabindex="-1"></a><span class="co"># Gewichtete Mittelwerte f√ºr Kontrollgruppe</span></span>
<span id="cb13-231"><a href="#cb13-231" aria-hidden="true" tabindex="-1"></a>(</span>
<span id="cb13-232"><a href="#cb13-232" aria-hidden="true" tabindex="-1"></a>gew_K <span class="ot">&lt;-</span> darkmode <span class="sc">%&gt;%</span> </span>
<span id="cb13-233"><a href="#cb13-233" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(dark_mode <span class="sc">==</span> <span class="dv">0</span>) <span class="sc">%&gt;%</span> </span>
<span id="cb13-234"><a href="#cb13-234" aria-hidden="true" tabindex="-1"></a>  <span class="fu">select</span>(read_time, male) <span class="sc">%&gt;%</span></span>
<span id="cb13-235"><a href="#cb13-235" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">w =</span> <span class="fu">ifelse</span>(</span>
<span id="cb13-236"><a href="#cb13-236" aria-hidden="true" tabindex="-1"></a>    male <span class="sc">==</span> <span class="dv">1</span>, </span>
<span id="cb13-237"><a href="#cb13-237" aria-hidden="true" tabindex="-1"></a>    ant_m_B<span class="sc">/</span>anz_m_K, </span>
<span id="cb13-238"><a href="#cb13-238" aria-hidden="true" tabindex="-1"></a>    ant_nm_B<span class="sc">/</span>anz_nm_K)</span>
<span id="cb13-239"><a href="#cb13-239" aria-hidden="true" tabindex="-1"></a>    ) <span class="sc">%&gt;%</span></span>
<span id="cb13-240"><a href="#cb13-240" aria-hidden="true" tabindex="-1"></a>  <span class="fu">summarise</span>(</span>
<span id="cb13-241"><a href="#cb13-241" aria-hidden="true" tabindex="-1"></a>    <span class="at">male_k =</span> <span class="fu">sum</span>(male <span class="sc">*</span> w) <span class="sc">/</span> <span class="fu">sum</span>(w),</span>
<span id="cb13-242"><a href="#cb13-242" aria-hidden="true" tabindex="-1"></a>    <span class="at">mean_read_time_wK =</span> <span class="fu">sum</span>(read_time <span class="sc">*</span> w) <span class="sc">/</span> <span class="fu">sum</span>(w)</span>
<span id="cb13-243"><a href="#cb13-243" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb13-244"><a href="#cb13-244" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb13-245"><a href="#cb13-245" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb13-246"><a href="#cb13-246" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-247"><a href="#cb13-247" aria-hidden="true" tabindex="-1"></a>Ein Vergleich des gewichteten Mittelwertes von <span class="in">`male`</span> in der Kontrollgruppe mit dem Mittelwert in der Behandlungsgruppe (<span class="in">`male_k`</span>) zeigt, dass die Gewichte die Variation in <span class="in">`male`</span> zwischen beiden Gruppen eliminieren. Mit <span class="in">`wmean_read_time_K`</span> haben wir einen entsprechend gewichteten Mittelwert der Verweildauer f√ºr die Kontrollgruppe berechnet. Wir sch√§tzen den Behandlungseffekt nun als</span>
<span id="cb13-248"><a href="#cb13-248" aria-hidden="true" tabindex="-1"></a>\begin{align}</span>
<span id="cb13-249"><a href="#cb13-249" aria-hidden="true" tabindex="-1"></a>  \widehat{\tau}^{\text{w}} = \overline{\text{read<span class="sc">\_</span>time}}_{B} - \overline{\text{read\_time}}_{w,K}.</span>
<span id="cb13-250"><a href="#cb13-250" aria-hidden="true" tabindex="-1"></a>\end{align}</span>
<span id="cb13-251"><a href="#cb13-251" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-254"><a href="#cb13-254" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb13-255"><a href="#cb13-255" aria-hidden="true" tabindex="-1"></a><span class="fu">mean</span>(read_time_mTG)  <span class="sc">-</span> gew_K<span class="sc">$</span>mean_read_time_wK</span>
<span id="cb13-256"><a href="#cb13-256" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb13-257"><a href="#cb13-257" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-258"><a href="#cb13-258" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-259"><a href="#cb13-259" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-260"><a href="#cb13-260" aria-hidden="true" tabindex="-1"></a><span class="fu">### *Balance*: Vergleichbarkeit von Behandlungs- und Kontrollgruppe</span></span>
<span id="cb13-261"><a href="#cb13-261" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-262"><a href="#cb13-262" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-263"><a href="#cb13-263" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-264"><a href="#cb13-264" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-265"><a href="#cb13-265" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-266"><a href="#cb13-266" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-267"><a href="#cb13-267" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-268"><a href="#cb13-268" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-269"><a href="#cb13-269" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-270"><a href="#cb13-270" aria-hidden="true" tabindex="-1"></a>Weiterhin scheint plausibel, dass das Alter der Nutzer sowohl die Akzeptanz des Design-Updates als auch die Lesezeit beeinflusst. Die bisherige Verweildauer ist ebenfalls eine plausible Determinante der Lesezeit.</span>
<span id="cb13-271"><a href="#cb13-271" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-272"><a href="#cb13-272" aria-hidden="true" tabindex="-1"></a>Der angenommene DGP ist in Abbildung @fig-CDdarkmode dargestellt, wobei Backdoor-Pfade mit roten Pfeilen gekennzeichnet sind.</span>
<span id="cb13-273"><a href="#cb13-273" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-276"><a href="#cb13-276" aria-hidden="true" tabindex="-1"></a><span class="in">```{dot}</span></span>
<span id="cb13-277"><a href="#cb13-277" aria-hidden="true" tabindex="-1"></a>//| fig<span class="ot">-w</span>idth: <span class="dv">4</span></span>
<span id="cb13-278"><a href="#cb13-278" aria-hidden="true" tabindex="-1"></a>//| fig-height: <span class="dv">3</span></span>
<span id="cb13-279"><a href="#cb13-279" aria-hidden="true" tabindex="-1"></a>//| fig-align: <span class="ot">'</span><span class="ss">center</span><span class="ot">'</span></span>
<span id="cb13-280"><a href="#cb13-280" aria-hidden="true" tabindex="-1"></a>//| fig<span class="ot">-c</span>ap: <span class="ot">"</span><span class="st">Vermuteter DGP im Website-Design-Bespiel</span><span class="ot">"</span></span>
<span id="cb13-281"><a href="#cb13-281" aria-hidden="true" tabindex="-1"></a>//| label: <span class="ot">"</span><span class="st">fig-CDdarkmode</span><span class="ot">"</span> </span>
<span id="cb13-282"><a href="#cb13-282" aria-hidden="true" tabindex="-1"></a>digraph {</span>
<span id="cb13-283"><a href="#cb13-283" aria-hidden="true" tabindex="-1"></a>  layout=neato</span>
<span id="cb13-284"><a href="#cb13-284" aria-hidden="true" tabindex="-1"></a>  fontname=<span class="ot">"</span><span class="st">Helvetica,Arial,sans-serif</span><span class="ot">"</span></span>
<span id="cb13-285"><a href="#cb13-285" aria-hidden="true" tabindex="-1"></a>  node [fontname=<span class="ot">"</span><span class="st">Helvetica,Arial,sans-serif</span><span class="ot">"</span>]</span>
<span id="cb13-286"><a href="#cb13-286" aria-hidden="true" tabindex="-1"></a>  edge [fontname=<span class="ot">"</span><span class="st">Helvetica,Arial,sans-serif</span><span class="ot">"</span>]</span>
<span id="cb13-287"><a href="#cb13-287" aria-hidden="true" tabindex="-1"></a>  node [shape=none];</span>
<span id="cb13-288"><a href="#cb13-288" aria-hidden="true" tabindex="-1"></a>  <span class="ot">"</span><span class="st">read_time</span><span class="ot">"</span> [<span class="fu">pos</span>=<span class="ot">"</span><span class="st">4,0.5!</span><span class="ot">"</span>]</span>
<span id="cb13-289"><a href="#cb13-289" aria-hidden="true" tabindex="-1"></a>  <span class="ot">"</span><span class="st">dark_mode</span><span class="ot">"</span> [<span class="fu">pos</span>=<span class="ot">"</span><span class="st">0,0.5!</span><span class="ot">"</span>]</span>
<span id="cb13-290"><a href="#cb13-290" aria-hidden="true" tabindex="-1"></a>  <span class="ot">"</span><span class="st">male</span><span class="ot">"</span> [<span class="fu">pos</span>=<span class="ot">"</span><span class="st">2,-1!</span><span class="ot">"</span>]</span>
<span id="cb13-291"><a href="#cb13-291" aria-hidden="true" tabindex="-1"></a>  <span class="ot">"</span><span class="st">age</span><span class="ot">"</span> [<span class="fu">pos</span>=<span class="ot">"</span><span class="st">2,2!</span><span class="ot">"</span>]</span>
<span id="cb13-292"><a href="#cb13-292" aria-hidden="true" tabindex="-1"></a>  <span class="ot">"</span><span class="st">hours</span><span class="ot">"</span> [<span class="fu">pos</span>=<span class="ot">"</span><span class="st">4,2!</span><span class="ot">"</span>]</span>
<span id="cb13-293"><a href="#cb13-293" aria-hidden="true" tabindex="-1"></a>  <span class="ot">"</span><span class="st">hours</span><span class="ot">"</span> -&gt; <span class="ot">"</span><span class="st">read_time</span><span class="ot">"</span></span>
<span id="cb13-294"><a href="#cb13-294" aria-hidden="true" tabindex="-1"></a>  <span class="ot">"</span><span class="st">age</span><span class="ot">"</span> -&gt; <span class="ot">"</span><span class="st">dark_mode</span><span class="ot">"</span> [color=<span class="ot">"</span><span class="st">red</span><span class="ot">"</span>]</span>
<span id="cb13-295"><a href="#cb13-295" aria-hidden="true" tabindex="-1"></a>  <span class="ot">"</span><span class="st">age</span><span class="ot">"</span> -&gt; <span class="ot">"</span><span class="st">read_time</span><span class="ot">"</span> [color=<span class="ot">"</span><span class="st">red</span><span class="ot">"</span>]</span>
<span id="cb13-296"><a href="#cb13-296" aria-hidden="true" tabindex="-1"></a>  <span class="ot">"</span><span class="st">dark_mode</span><span class="ot">"</span> -&gt; <span class="ot">"</span><span class="st">read_time</span><span class="ot">"</span> [color=<span class="ot">"</span><span class="st">green</span><span class="ot">"</span>]</span>
<span id="cb13-297"><a href="#cb13-297" aria-hidden="true" tabindex="-1"></a>  <span class="ot">"</span><span class="st">male</span><span class="ot">"</span> -&gt; <span class="ot">"</span><span class="st">dark_mode</span><span class="ot">"</span> [color=<span class="ot">"</span><span class="st">red</span><span class="ot">"</span>]</span>
<span id="cb13-298"><a href="#cb13-298" aria-hidden="true" tabindex="-1"></a>  <span class="ot">"</span><span class="st">male</span><span class="ot">"</span> -&gt; <span class="ot">"</span><span class="st">read_time</span><span class="ot">"</span> [color=<span class="ot">"</span><span class="st">red</span><span class="ot">"</span>]</span>
<span id="cb13-299"><a href="#cb13-299" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb13-300"><a href="#cb13-300" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb13-301"><a href="#cb13-301" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-302"><a href="#cb13-302" aria-hidden="true" tabindex="-1"></a>Zur Beurteilung der Vergleichbarkeit von Kontrollgruppe und Behandlungsgruppe empfiehlt sich eine Gegen√ºberstellung der empirischen Verteilungen der Kovariablen beider Gruppen. Wir visualisieren die empirischen Verteilungen zun√§chst mit <span class="in">`ggplot2`</span>. Hierzu transformieren wir <span class="in">`male`</span> und <span class="in">`dark_mode`</span> in den Typ <span class="in">`factor`</span> und standardisieren <span class="in">`age`</span> und <span class="in">`hours`</span> mit <span class="in">`scale()`</span>.</span>
<span id="cb13-303"><a href="#cb13-303" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-304"><a href="#cb13-304" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb13-305"><a href="#cb13-305" aria-hidden="true" tabindex="-1"></a><span class="in"># Datensatz f√ºr graphische Darstellung formatieren</span></span>
<span id="cb13-306"><a href="#cb13-306" aria-hidden="true" tabindex="-1"></a><span class="in">darkmode_p &lt;- darkmode %&gt;% </span></span>
<span id="cb13-307"><a href="#cb13-307" aria-hidden="true" tabindex="-1"></a><span class="in">  # Standardisierung mit 'scale()'</span></span>
<span id="cb13-308"><a href="#cb13-308" aria-hidden="true" tabindex="-1"></a><span class="in">  mutate(</span></span>
<span id="cb13-309"><a href="#cb13-309" aria-hidden="true" tabindex="-1"></a><span class="in">    male = as.factor(male), </span></span>
<span id="cb13-310"><a href="#cb13-310" aria-hidden="true" tabindex="-1"></a><span class="in">    dark_mode = as.factor(dark_mode),</span></span>
<span id="cb13-311"><a href="#cb13-311" aria-hidden="true" tabindex="-1"></a><span class="in">    age = scale(age), </span></span>
<span id="cb13-312"><a href="#cb13-312" aria-hidden="true" tabindex="-1"></a><span class="in">    hours = scale(hours)</span></span>
<span id="cb13-313"><a href="#cb13-313" aria-hidden="true" tabindex="-1"></a><span class="in">  )</span></span>
<span id="cb13-314"><a href="#cb13-314" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-315"><a href="#cb13-315" aria-hidden="true" tabindex="-1"></a><span class="in">head(darkmode_p)</span></span>
<span id="cb13-316"><a href="#cb13-316" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb13-317"><a href="#cb13-317" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-318"><a href="#cb13-318" aria-hidden="true" tabindex="-1"></a>F√ºr <span class="in">`age`</span> und <span class="in">`hours`</span> eignen sich die gesch√§tzten Dichtefunktionen f√ºr einen Vergleich der Verteilungen in Behandlungs- und Kontrollgruppe.</span>
<span id="cb13-319"><a href="#cb13-319" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-320"><a href="#cb13-320" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb13-321"><a href="#cb13-321" aria-hidden="true" tabindex="-1"></a><span class="in"># Vergleich mit Dichtesch√§tzungen</span></span>
<span id="cb13-322"><a href="#cb13-322" aria-hidden="true" tabindex="-1"></a><span class="in">darkmode_p %&gt;%</span></span>
<span id="cb13-323"><a href="#cb13-323" aria-hidden="true" tabindex="-1"></a><span class="in">  select(dark_mode, hours, age) %&gt;%</span></span>
<span id="cb13-324"><a href="#cb13-324" aria-hidden="true" tabindex="-1"></a><span class="in">  # in langes Format √ºberf√ºhren</span></span>
<span id="cb13-325"><a href="#cb13-325" aria-hidden="true" tabindex="-1"></a><span class="in">  pivot_longer(cols = c(-dark_mode)) %&gt;%</span></span>
<span id="cb13-326"><a href="#cb13-326" aria-hidden="true" tabindex="-1"></a><span class="in">  </span></span>
<span id="cb13-327"><a href="#cb13-327" aria-hidden="true" tabindex="-1"></a><span class="in">  ggplot(</span></span>
<span id="cb13-328"><a href="#cb13-328" aria-hidden="true" tabindex="-1"></a><span class="in">    aes(x = value, fill = dark_mode)</span></span>
<span id="cb13-329"><a href="#cb13-329" aria-hidden="true" tabindex="-1"></a><span class="in">    ) +</span></span>
<span id="cb13-330"><a href="#cb13-330" aria-hidden="true" tabindex="-1"></a><span class="in">  geom_density(alpha = .5) + </span></span>
<span id="cb13-331"><a href="#cb13-331" aria-hidden="true" tabindex="-1"></a><span class="in">  facet_wrap(</span></span>
<span id="cb13-332"><a href="#cb13-332" aria-hidden="true" tabindex="-1"></a><span class="in">    facets = ~ name, </span></span>
<span id="cb13-333"><a href="#cb13-333" aria-hidden="true" tabindex="-1"></a><span class="in">    scales = "free", </span></span>
<span id="cb13-334"><a href="#cb13-334" aria-hidden="true" tabindex="-1"></a><span class="in">    nrow = 2</span></span>
<span id="cb13-335"><a href="#cb13-335" aria-hidden="true" tabindex="-1"></a><span class="in">    )</span></span>
<span id="cb13-336"><a href="#cb13-336" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb13-337"><a href="#cb13-337" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-338"><a href="#cb13-338" aria-hidden="true" tabindex="-1"></a>F√ºr <span class="in">`male`</span> vergleichen wir die relativen H√§ufigkeiten mit Balkendiagrammen.</span>
<span id="cb13-339"><a href="#cb13-339" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-340"><a href="#cb13-340" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb13-341"><a href="#cb13-341" aria-hidden="true" tabindex="-1"></a><span class="in"># Relative Hfkt. f√ºr 'male' als barplot</span></span>
<span id="cb13-342"><a href="#cb13-342" aria-hidden="true" tabindex="-1"></a><span class="in">darkmode_p %&gt;%</span></span>
<span id="cb13-343"><a href="#cb13-343" aria-hidden="true" tabindex="-1"></a><span class="in">  ggplot(</span></span>
<span id="cb13-344"><a href="#cb13-344" aria-hidden="true" tabindex="-1"></a><span class="in">    aes(x = dark_mode, fill = male)</span></span>
<span id="cb13-345"><a href="#cb13-345" aria-hidden="true" tabindex="-1"></a><span class="in">    ) +</span></span>
<span id="cb13-346"><a href="#cb13-346" aria-hidden="true" tabindex="-1"></a><span class="in">  geom_bar(position = "fill") +</span></span>
<span id="cb13-347"><a href="#cb13-347" aria-hidden="true" tabindex="-1"></a><span class="in">  ylab("Anteil")</span></span>
<span id="cb13-348"><a href="#cb13-348" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb13-349"><a href="#cb13-349" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-350"><a href="#cb13-350" aria-hidden="true" tabindex="-1"></a>Die graphische Analyse zeigt deutliche Unterschiede in den Verteilungen von <span class="in">`age`</span> und <span class="in">`male`</span> zwischen Kontroll- und Behandlungsgruppe. F√ºr einen Beurteilung mit deskriptiven Statistiken wird h√§ufig eine sogenannte *Balance Table* herangezogen. Wir berechnen diese f√ºr <span class="in">`age`</span>, <span class="in">`hours`</span> und <span class="in">`male`</span> mit <span class="in">`cobalt::bal.tab()`</span></span>
<span id="cb13-351"><a href="#cb13-351" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-352"><a href="#cb13-352" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb13-353"><a href="#cb13-353" aria-hidden="true" tabindex="-1"></a><span class="in">library(cobalt)</span></span>
<span id="cb13-354"><a href="#cb13-354" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-355"><a href="#cb13-355" aria-hidden="true" tabindex="-1"></a><span class="in"># Balance table mit 'cobalt::bal.tab()'</span></span>
<span id="cb13-356"><a href="#cb13-356" aria-hidden="true" tabindex="-1"></a><span class="in">bal.tab(</span></span>
<span id="cb13-357"><a href="#cb13-357" aria-hidden="true" tabindex="-1"></a><span class="in">  x = darkmode %&gt;% </span></span>
<span id="cb13-358"><a href="#cb13-358" aria-hidden="true" tabindex="-1"></a><span class="in">    select(age, hours, male), </span></span>
<span id="cb13-359"><a href="#cb13-359" aria-hidden="true" tabindex="-1"></a><span class="in">  treat = darkmode$dark_mode, </span></span>
<span id="cb13-360"><a href="#cb13-360" aria-hidden="true" tabindex="-1"></a><span class="in">   # berechne SMD f√ºr KG und TG:</span></span>
<span id="cb13-361"><a href="#cb13-361" aria-hidden="true" tabindex="-1"></a><span class="in">  disp = "m", </span></span>
<span id="cb13-362"><a href="#cb13-362" aria-hidden="true" tabindex="-1"></a><span class="in">  s.d.denom = "pooled"</span></span>
<span id="cb13-363"><a href="#cb13-363" aria-hidden="true" tabindex="-1"></a><span class="in">)</span></span>
<span id="cb13-364"><a href="#cb13-364" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb13-365"><a href="#cb13-365" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-366"><a href="#cb13-366" aria-hidden="true" tabindex="-1"></a>Die Eintr√§ge <span class="in">`M.0.Un`</span> und <span class="in">`M.1.Un`</span> zeigen die jeweiligen Stichprobenmittelwerte der Variablen f√ºr Kontroll- und Behandlungsgruppe. <span class="in">`Diff.U`</span> gibt eine standardisierte Mittelwertdifferenz $SMD$ an, wobei</span>
<span id="cb13-367"><a href="#cb13-367" aria-hidden="true" tabindex="-1"></a>\begin{align*}</span>
<span id="cb13-368"><a href="#cb13-368" aria-hidden="true" tabindex="-1"></a>  SMD_j := \left(\overline{X}_{j,B} - \overline{X}_{j,K}\right) \bigg/ \sqrt{\frac{1}{2}\left(\widehat{\text{Var}}(X_{j,B}) + \widehat{\text{Var}}(X_{j,K})\right)},</span>
<span id="cb13-369"><a href="#cb13-369" aria-hidden="true" tabindex="-1"></a>\end{align*}</span>
<span id="cb13-370"><a href="#cb13-370" aria-hidden="true" tabindex="-1"></a>mit Stichprobenmitteln $\overline{X}_{j,B}$ und $\overline{X}_{j,K}$ und Stichprobenvarianzen $\widehat{\text{Var}}(X_{j,B})$ und $\widehat{\text{Var}}(X_{j,K})$ f√ºr eine kontinuierliche Kovariable $j$.^<span class="co">[</span><span class="ot">Siehe @Austin2011 f√ºr einen √úberblick zu Balance-Statistiken.</span><span class="co">]</span> Obwohl es keinen einheitlichen Schwellenwert f√ºr die standardisierte Differenz gibt, der ein erhebliches Ungleichgewicht anzeigt, gilt f√ºr kontinuierliche Variablen eine standardisierte (absolute) Differenz von weniger als $0.1$ als Hinweis auf einen vernachl√§ssigbaren Unterschied zwischen den Gruppen.</span>
<span id="cb13-371"><a href="#cb13-371" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-372"><a href="#cb13-372" aria-hidden="true" tabindex="-1"></a>Die Balance Table weist also auf einen vernachl√§ssigbaren Unterschied f√ºr <span class="in">`hours`</span> und best√§tigt die aus den Grafiken abgeleiteten Hinweise auf relevante Differenzen f√ºr <span class="in">`age`</span> und <span class="in">`male`</span>. </span>
<span id="cb13-373"><a href="#cb13-373" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-374"><a href="#cb13-374" aria-hidden="true" tabindex="-1"></a>###</span>
<span id="cb13-375"><a href="#cb13-375" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-376"><a href="#cb13-376" aria-hidden="true" tabindex="-1"></a><span class="fu">### Inverse Probability Weighting</span></span>
<span id="cb13-377"><a href="#cb13-377" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-378"><a href="#cb13-378" aria-hidden="true" tabindex="-1"></a><span class="fu">### Propensity score</span></span>
<span id="cb13-379"><a href="#cb13-379" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-380"><a href="#cb13-380" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb13-381"><a href="#cb13-381" aria-hidden="true" tabindex="-1"></a><span class="in">lm(</span></span>
<span id="cb13-382"><a href="#cb13-382" aria-hidden="true" tabindex="-1"></a><span class="in">   formula = read_time ~ dark_mode + age + male + hours,</span></span>
<span id="cb13-383"><a href="#cb13-383" aria-hidden="true" tabindex="-1"></a><span class="in">   data = darkmode</span></span>
<span id="cb13-384"><a href="#cb13-384" aria-hidden="true" tabindex="-1"></a><span class="in"> ) %&gt;%</span></span>
<span id="cb13-385"><a href="#cb13-385" aria-hidden="true" tabindex="-1"></a><span class="in">   summary()</span></span>
<span id="cb13-386"><a href="#cb13-386" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb13-387"><a href="#cb13-387" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-388"><a href="#cb13-388" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-389"><a href="#cb13-389" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb13-390"><a href="#cb13-390" aria-hidden="true" tabindex="-1"></a><span class="in"># Logit-Modell mit 'glm()' sch√§tzen</span></span>
<span id="cb13-391"><a href="#cb13-391" aria-hidden="true" tabindex="-1"></a><span class="in">(</span></span>
<span id="cb13-392"><a href="#cb13-392" aria-hidden="true" tabindex="-1"></a><span class="in">  darkmode_ps_logit &lt;- glm(</span></span>
<span id="cb13-393"><a href="#cb13-393" aria-hidden="true" tabindex="-1"></a><span class="in">    formula = dark_mode ~ age + male + hours,</span></span>
<span id="cb13-394"><a href="#cb13-394" aria-hidden="true" tabindex="-1"></a><span class="in">    data = darkmode,</span></span>
<span id="cb13-395"><a href="#cb13-395" aria-hidden="true" tabindex="-1"></a><span class="in">    family = binomial</span></span>
<span id="cb13-396"><a href="#cb13-396" aria-hidden="true" tabindex="-1"></a><span class="in">  )</span></span>
<span id="cb13-397"><a href="#cb13-397" aria-hidden="true" tabindex="-1"></a><span class="in">)</span></span>
<span id="cb13-398"><a href="#cb13-398" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb13-399"><a href="#cb13-399" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-400"><a href="#cb13-400" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb13-401"><a href="#cb13-401" aria-hidden="true" tabindex="-1"></a><span class="in"># Datensatz um propensity scores erweitern</span></span>
<span id="cb13-402"><a href="#cb13-402" aria-hidden="true" tabindex="-1"></a><span class="in">(</span></span>
<span id="cb13-403"><a href="#cb13-403" aria-hidden="true" tabindex="-1"></a><span class="in">  darkmode_probabilities &lt;- </span></span>
<span id="cb13-404"><a href="#cb13-404" aria-hidden="true" tabindex="-1"></a><span class="in">    darkmode %&gt;%</span></span>
<span id="cb13-405"><a href="#cb13-405" aria-hidden="true" tabindex="-1"></a><span class="in">    mutate(</span></span>
<span id="cb13-406"><a href="#cb13-406" aria-hidden="true" tabindex="-1"></a><span class="in">      propensity = fitted(darkmode_ps_logit)</span></span>
<span id="cb13-407"><a href="#cb13-407" aria-hidden="true" tabindex="-1"></a><span class="in">    )</span></span>
<span id="cb13-408"><a href="#cb13-408" aria-hidden="true" tabindex="-1"></a><span class="in">)</span></span>
<span id="cb13-409"><a href="#cb13-409" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb13-410"><a href="#cb13-410" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-411"><a href="#cb13-411" aria-hidden="true" tabindex="-1"></a>Inverse probability weights (IPWs) anhand der PS k√∂nnen schnell anhand der Vorschrift $$\texttt{ipw} = \texttt{dark<span class="sc">\_</span>mode} / \texttt{propensity} + (1 - \texttt{dark<span class="sc">\_</span>mode}) / (1 - \texttt{propensity}), \quad \texttt{dark<span class="sc">\_</span>mode} \in<span class="sc">\{</span>0,1<span class="sc">\}</span>$$</span>
<span id="cb13-412"><a href="#cb13-412" aria-hidden="true" tabindex="-1"></a>berechnet werden.</span>
<span id="cb13-413"><a href="#cb13-413" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-414"><a href="#cb13-414" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb13-415"><a href="#cb13-415" aria-hidden="true" tabindex="-1"></a><span class="in"># Datensatz um IPWs erweitern</span></span>
<span id="cb13-416"><a href="#cb13-416" aria-hidden="true" tabindex="-1"></a><span class="in">darkmode_ipw &lt;- darkmode_probabilities %&gt;%</span></span>
<span id="cb13-417"><a href="#cb13-417" aria-hidden="true" tabindex="-1"></a><span class="in">  mutate(</span></span>
<span id="cb13-418"><a href="#cb13-418" aria-hidden="true" tabindex="-1"></a><span class="in">    ipw = dark_mode / propensity + (1 - dark_mode) / (1 - propensity)</span></span>
<span id="cb13-419"><a href="#cb13-419" aria-hidden="true" tabindex="-1"></a><span class="in">  )</span></span>
<span id="cb13-420"><a href="#cb13-420" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-421"><a href="#cb13-421" aria-hidden="true" tabindex="-1"></a><span class="in">darkmode_ipw %&gt;% </span></span>
<span id="cb13-422"><a href="#cb13-422" aria-hidden="true" tabindex="-1"></a><span class="in">  select(ipw)</span></span>
<span id="cb13-423"><a href="#cb13-423" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb13-424"><a href="#cb13-424" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-425"><a href="#cb13-425" aria-hidden="true" tabindex="-1"></a>Verteilung der Propensity Scores nach Behandlungs-Indikator:</span>
<span id="cb13-426"><a href="#cb13-426" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-427"><a href="#cb13-427" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb13-428"><a href="#cb13-428" aria-hidden="true" tabindex="-1"></a><span class="in"># Dichtesch√§tzung der PS nach Treatment-Indikator</span></span>
<span id="cb13-429"><a href="#cb13-429" aria-hidden="true" tabindex="-1"></a><span class="in">darkmode_ipw %&gt;%</span></span>
<span id="cb13-430"><a href="#cb13-430" aria-hidden="true" tabindex="-1"></a><span class="in">ggplot(</span></span>
<span id="cb13-431"><a href="#cb13-431" aria-hidden="true" tabindex="-1"></a><span class="in">  mapping = aes(</span></span>
<span id="cb13-432"><a href="#cb13-432" aria-hidden="true" tabindex="-1"></a><span class="in">    x = propensity, </span></span>
<span id="cb13-433"><a href="#cb13-433" aria-hidden="true" tabindex="-1"></a><span class="in">    fill = factor(dark_mode))</span></span>
<span id="cb13-434"><a href="#cb13-434" aria-hidden="true" tabindex="-1"></a><span class="in">  ) + </span></span>
<span id="cb13-435"><a href="#cb13-435" aria-hidden="true" tabindex="-1"></a><span class="in">  lims(x = c(0, 1)) +</span></span>
<span id="cb13-436"><a href="#cb13-436" aria-hidden="true" tabindex="-1"></a><span class="in">  geom_density(alpha = .5, )</span></span>
<span id="cb13-437"><a href="#cb13-437" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb13-438"><a href="#cb13-438" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-439"><a href="#cb13-439" aria-hidden="true" tabindex="-1"></a>Beobachtungen aus der Kontroll-Gruppe entfernen, die au√üerhalb des Supports der Treatment-Gruppe liegen.</span>
<span id="cb13-440"><a href="#cb13-440" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-441"><a href="#cb13-441" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb13-442"><a href="#cb13-442" aria-hidden="true" tabindex="-1"></a><span class="in"># Propensity scores auslesen</span></span>
<span id="cb13-443"><a href="#cb13-443" aria-hidden="true" tabindex="-1"></a><span class="in">darkmode_ipws &lt;- darkmode_ipw %&gt;% </span></span>
<span id="cb13-444"><a href="#cb13-444" aria-hidden="true" tabindex="-1"></a><span class="in">  filter(dark_mode == 1) %&gt;% </span></span>
<span id="cb13-445"><a href="#cb13-445" aria-hidden="true" tabindex="-1"></a><span class="in">  pull(propensity)</span></span>
<span id="cb13-446"><a href="#cb13-446" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-447"><a href="#cb13-447" aria-hidden="true" tabindex="-1"></a><span class="in"># Support sicherstellen </span></span>
<span id="cb13-448"><a href="#cb13-448" aria-hidden="true" tabindex="-1"></a><span class="in"># (entfernt 13 Beobachtungen aus der Kontrollgruppe)</span></span>
<span id="cb13-449"><a href="#cb13-449" aria-hidden="true" tabindex="-1"></a><span class="in">darkmode_ipw &lt;- darkmode_ipw %&gt;% </span></span>
<span id="cb13-450"><a href="#cb13-450" aria-hidden="true" tabindex="-1"></a><span class="in">  filter(</span></span>
<span id="cb13-451"><a href="#cb13-451" aria-hidden="true" tabindex="-1"></a><span class="in">    between(</span></span>
<span id="cb13-452"><a href="#cb13-452" aria-hidden="true" tabindex="-1"></a><span class="in">      propensity,</span></span>
<span id="cb13-453"><a href="#cb13-453" aria-hidden="true" tabindex="-1"></a><span class="in">      darkmode_ipws %&gt;% </span></span>
<span id="cb13-454"><a href="#cb13-454" aria-hidden="true" tabindex="-1"></a><span class="in">        min(),</span></span>
<span id="cb13-455"><a href="#cb13-455" aria-hidden="true" tabindex="-1"></a><span class="in">      darkmode_ipws %&gt;% </span></span>
<span id="cb13-456"><a href="#cb13-456" aria-hidden="true" tabindex="-1"></a><span class="in">        max()</span></span>
<span id="cb13-457"><a href="#cb13-457" aria-hidden="true" tabindex="-1"></a><span class="in">    )</span></span>
<span id="cb13-458"><a href="#cb13-458" aria-hidden="true" tabindex="-1"></a><span class="in">  )</span></span>
<span id="cb13-459"><a href="#cb13-459" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb13-460"><a href="#cb13-460" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-461"><a href="#cb13-461" aria-hidden="true" tabindex="-1"></a>Die Abdeckung k√∂nnen wir erneut mit einer Grafik gesch√§tzter Dichtefunktionen vergleichen.</span>
<span id="cb13-462"><a href="#cb13-462" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-463"><a href="#cb13-463" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb13-464"><a href="#cb13-464" aria-hidden="true" tabindex="-1"></a><span class="in"># Dichtesch√§tzung der PS per Treatment-Indikator nach Anpassung</span></span>
<span id="cb13-465"><a href="#cb13-465" aria-hidden="true" tabindex="-1"></a><span class="in">darkmode_ipw %&gt;%</span></span>
<span id="cb13-466"><a href="#cb13-466" aria-hidden="true" tabindex="-1"></a><span class="in">  ggplot(</span></span>
<span id="cb13-467"><a href="#cb13-467" aria-hidden="true" tabindex="-1"></a><span class="in">    mapping = aes(</span></span>
<span id="cb13-468"><a href="#cb13-468" aria-hidden="true" tabindex="-1"></a><span class="in">      x = propensity, </span></span>
<span id="cb13-469"><a href="#cb13-469" aria-hidden="true" tabindex="-1"></a><span class="in">      fill = factor(dark_mode)</span></span>
<span id="cb13-470"><a href="#cb13-470" aria-hidden="true" tabindex="-1"></a><span class="in">    )</span></span>
<span id="cb13-471"><a href="#cb13-471" aria-hidden="true" tabindex="-1"></a><span class="in">  ) + </span></span>
<span id="cb13-472"><a href="#cb13-472" aria-hidden="true" tabindex="-1"></a><span class="in">  lims(x = c(0, 1)) +</span></span>
<span id="cb13-473"><a href="#cb13-473" aria-hidden="true" tabindex="-1"></a><span class="in">  geom_density(alpha = .5)</span></span>
<span id="cb13-474"><a href="#cb13-474" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb13-475"><a href="#cb13-475" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-476"><a href="#cb13-476" aria-hidden="true" tabindex="-1"></a>Wir finden etwas weniger Wahrscheinlichkeits-Masse nahe 0 f√ºr die Kontroll-Gruppe nach filtern von (Kontroll-)Beobachtungen mit PS in der Spannweite der PS in der Behandlungs-Gruppe. Als n√§chstes sch√§tzen wir den ATE mit linearer Regression.</span>
<span id="cb13-477"><a href="#cb13-477" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-478"><a href="#cb13-478" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb13-479"><a href="#cb13-479" aria-hidden="true" tabindex="-1"></a><span class="in"># Mit IPWs gewichteter KQ-Schaetzer berechnet einen ATE</span></span>
<span id="cb13-480"><a href="#cb13-480" aria-hidden="true" tabindex="-1"></a><span class="in">model_ipw &lt;- lm(</span></span>
<span id="cb13-481"><a href="#cb13-481" aria-hidden="true" tabindex="-1"></a><span class="in">  formula = read_time ~ dark_mode, </span></span>
<span id="cb13-482"><a href="#cb13-482" aria-hidden="true" tabindex="-1"></a><span class="in">  data = darkmode_ipw,</span></span>
<span id="cb13-483"><a href="#cb13-483" aria-hidden="true" tabindex="-1"></a><span class="in">  weights = ipw</span></span>
<span id="cb13-484"><a href="#cb13-484" aria-hidden="true" tabindex="-1"></a><span class="in">)</span></span>
<span id="cb13-485"><a href="#cb13-485" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-486"><a href="#cb13-486" aria-hidden="true" tabindex="-1"></a><span class="in">summary(model_ipw)</span></span>
<span id="cb13-487"><a href="#cb13-487" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb13-488"><a href="#cb13-488" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-489"><a href="#cb13-489" aria-hidden="true" tabindex="-1"></a>Unsere Sch√§tzung des ATE ist der gesch√§tzte Koeffizient von <span class="in">`dark_mode`</span>. Die ausgegebenen Standardfehler und Inferenzstatistiken sind *ung√ºltig* aufgrund der Gewichtung mit IPWs, inversen *gesch√§tzten*  Wahrscheinlichkeiten f√ºr eine Behandlung. Der Grund hierf√ºr ist, dass die Standardformel in <span class="in">`summary()`</span>  die zus√§tzliche Unsicherheit durch die IPW-Sch√§tzung nicht ber√ºcksichtigt!</span>
<span id="cb13-490"><a href="#cb13-490" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-491"><a href="#cb13-491" aria-hidden="true" tabindex="-1"></a>Die Vergleichbarkeit der Nutzer in Kontroll- und Behandlungsgruppe-Gruppe f√ºr die Variablen <span class="in">`age`</span>, <span class="in">`hours`</span> und <span class="in">`male`</span> k√∂nnen wir graphisch und anhand einer *balance table* vergleichen.</span>
<span id="cb13-492"><a href="#cb13-492" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-493"><a href="#cb13-493" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb13-494"><a href="#cb13-494" aria-hidden="true" tabindex="-1"></a><span class="in"># Dichtesch√§tzungen</span></span>
<span id="cb13-495"><a href="#cb13-495" aria-hidden="true" tabindex="-1"></a><span class="in">darkmode %&gt;% </span></span>
<span id="cb13-496"><a href="#cb13-496" aria-hidden="true" tabindex="-1"></a><span class="in">  group_by(dark_mode) %&gt;%</span></span>
<span id="cb13-497"><a href="#cb13-497" aria-hidden="true" tabindex="-1"></a><span class="in">  select(age, hours) %&gt;%</span></span>
<span id="cb13-498"><a href="#cb13-498" aria-hidden="true" tabindex="-1"></a><span class="in">  mutate_all(scale) %&gt;% # Standardisierung mit 'scale()'</span></span>
<span id="cb13-499"><a href="#cb13-499" aria-hidden="true" tabindex="-1"></a><span class="in">  pivot_longer(cols = c(-dark_mode)) %&gt;% # langes Format</span></span>
<span id="cb13-500"><a href="#cb13-500" aria-hidden="true" tabindex="-1"></a><span class="in">  </span></span>
<span id="cb13-501"><a href="#cb13-501" aria-hidden="true" tabindex="-1"></a><span class="in">  ggplot(aes(x = value, fill = as.factor(dark_mode))) +</span></span>
<span id="cb13-502"><a href="#cb13-502" aria-hidden="true" tabindex="-1"></a><span class="in">  geom_density( alpha = .5) + </span></span>
<span id="cb13-503"><a href="#cb13-503" aria-hidden="true" tabindex="-1"></a><span class="in">  facet_wrap(~ name, scales = "free", nrow = 3) # Facetting nach 'name'</span></span>
<span id="cb13-504"><a href="#cb13-504" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-505"><a href="#cb13-505" aria-hidden="true" tabindex="-1"></a><span class="in"># Relative Hfkt. f√ºr 'male' als barplot</span></span>
<span id="cb13-506"><a href="#cb13-506" aria-hidden="true" tabindex="-1"></a><span class="in">darkmode %&gt;% </span></span>
<span id="cb13-507"><a href="#cb13-507" aria-hidden="true" tabindex="-1"></a><span class="in">  group_by(dark_mode) %&gt;%</span></span>
<span id="cb13-508"><a href="#cb13-508" aria-hidden="true" tabindex="-1"></a><span class="in">  mutate(</span></span>
<span id="cb13-509"><a href="#cb13-509" aria-hidden="true" tabindex="-1"></a><span class="in">    male = as.factor(male), </span></span>
<span id="cb13-510"><a href="#cb13-510" aria-hidden="true" tabindex="-1"></a><span class="in">    dark_mode = as.factor(dark_mode)</span></span>
<span id="cb13-511"><a href="#cb13-511" aria-hidden="true" tabindex="-1"></a><span class="in">  ) %&gt;%</span></span>
<span id="cb13-512"><a href="#cb13-512" aria-hidden="true" tabindex="-1"></a><span class="in">  </span></span>
<span id="cb13-513"><a href="#cb13-513" aria-hidden="true" tabindex="-1"></a><span class="in">  ggplot(aes(x = dark_mode, fill = male)) +</span></span>
<span id="cb13-514"><a href="#cb13-514" aria-hidden="true" tabindex="-1"></a><span class="in">  geom_bar(position = "fill") +</span></span>
<span id="cb13-515"><a href="#cb13-515" aria-hidden="true" tabindex="-1"></a><span class="in">  ylab("Anteil")</span></span>
<span id="cb13-516"><a href="#cb13-516" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-517"><a href="#cb13-517" aria-hidden="true" tabindex="-1"></a><span class="in"># Balance table mit 'cobalt::bal.tab()'</span></span>
<span id="cb13-518"><a href="#cb13-518" aria-hidden="true" tabindex="-1"></a><span class="in">bal.tab(</span></span>
<span id="cb13-519"><a href="#cb13-519" aria-hidden="true" tabindex="-1"></a><span class="in">  x = darkmode %&gt;% </span></span>
<span id="cb13-520"><a href="#cb13-520" aria-hidden="true" tabindex="-1"></a><span class="in">    select(age, hours, male), </span></span>
<span id="cb13-521"><a href="#cb13-521" aria-hidden="true" tabindex="-1"></a><span class="in">  treat = darkmode$dark_mode, </span></span>
<span id="cb13-522"><a href="#cb13-522" aria-hidden="true" tabindex="-1"></a><span class="in">  disp = "m", # zeige zus√§tzlich Mittelwerte f√ºr C und T</span></span>
<span id="cb13-523"><a href="#cb13-523" aria-hidden="true" tabindex="-1"></a><span class="in">)</span></span>
<span id="cb13-524"><a href="#cb13-524" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb13-525"><a href="#cb13-525" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-526"><a href="#cb13-526" aria-hidden="true" tabindex="-1"></a>Wir zeigen als n√§chstes, wie <span class="in">`MatchIt::matchit()`</span> f√ºr Nearest-neighbor-Matching anhand der Regressoren <span class="in">`age`</span>, <span class="in">`hours`</span>, und <span class="in">`male`</span> in unterschiedlichen Varianten durchgef√ºhrt werden kann. </span>
<span id="cb13-527"><a href="#cb13-527" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-528"><a href="#cb13-528" aria-hidden="true" tabindex="-1"></a><span class="in">`MatchIt::matchit()`</span> f√ºhrt standardm√§√üig 1:1-Matching (ohne Zur√ºcklegen) von Beobachtungen der Treatment-Gruppe mit Beobachtungen der Kontrollgruppe druch. Das Objekt wird f√ºr eine Sch√§tzung des ATT mit einer geeigneten Funktionen vorbereitet, s. <span class="in">`?matchit`</span>, und hier insb. die Argumente <span class="in">`replace = F`</span>, <span class="in">`ratio = 1`</span> und <span class="in">`estimand = "ATT"`</span> f√ºr Details. </span>
<span id="cb13-529"><a href="#cb13-529" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-530"><a href="#cb13-530" aria-hidden="true" tabindex="-1"></a>Mit <span class="in">`cobalt::balt.tab()`</span> erhalten wir eine *balance table* f√ºr den gematchten Datensatz.</span>
<span id="cb13-531"><a href="#cb13-531" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-532"><a href="#cb13-532" aria-hidden="true" tabindex="-1"></a>**Exaktes Matching**</span>
<span id="cb13-533"><a href="#cb13-533" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-534"><a href="#cb13-534" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb13-535"><a href="#cb13-535" aria-hidden="true" tabindex="-1"></a><span class="in">res &lt;- matchit(</span></span>
<span id="cb13-536"><a href="#cb13-536" aria-hidden="true" tabindex="-1"></a><span class="in">  formula = dark_mode ~ age + male + hours, </span></span>
<span id="cb13-537"><a href="#cb13-537" aria-hidden="true" tabindex="-1"></a><span class="in">  data = darkmode, </span></span>
<span id="cb13-538"><a href="#cb13-538" aria-hidden="true" tabindex="-1"></a><span class="in">  method = "exact"</span></span>
<span id="cb13-539"><a href="#cb13-539" aria-hidden="true" tabindex="-1"></a><span class="in">)</span></span>
<span id="cb13-540"><a href="#cb13-540" aria-hidden="true" tabindex="-1"></a><span class="in">bal.tab(res)</span></span>
<span id="cb13-541"><a href="#cb13-541" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb13-542"><a href="#cb13-542" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-543"><a href="#cb13-543" aria-hidden="true" tabindex="-1"></a>**Eins-zu-Eins-Matching: Mahalanobis-Distanz**</span>
<span id="cb13-544"><a href="#cb13-544" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-545"><a href="#cb13-545" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb13-546"><a href="#cb13-546" aria-hidden="true" tabindex="-1"></a><span class="in">res &lt;- matchit(</span></span>
<span id="cb13-547"><a href="#cb13-547" aria-hidden="true" tabindex="-1"></a><span class="in">  formula = dark_mode ~ age + male + hours, </span></span>
<span id="cb13-548"><a href="#cb13-548" aria-hidden="true" tabindex="-1"></a><span class="in">  data = darkmode, </span></span>
<span id="cb13-549"><a href="#cb13-549" aria-hidden="true" tabindex="-1"></a><span class="in">  distance = "mahalanobis", </span></span>
<span id="cb13-550"><a href="#cb13-550" aria-hidden="true" tabindex="-1"></a><span class="in">  method = "nearest"</span></span>
<span id="cb13-551"><a href="#cb13-551" aria-hidden="true" tabindex="-1"></a><span class="in">)</span></span>
<span id="cb13-552"><a href="#cb13-552" aria-hidden="true" tabindex="-1"></a><span class="in">bal.tab(res)</span></span>
<span id="cb13-553"><a href="#cb13-553" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb13-554"><a href="#cb13-554" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-555"><a href="#cb13-555" aria-hidden="true" tabindex="-1"></a>**Eins-zu-Eins-Matching: Mahalanobis-Distanz mit Caliper 0.25 f√ºr propensity scores basierend auf logistischer Regression**</span>
<span id="cb13-556"><a href="#cb13-556" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-557"><a href="#cb13-557" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb13-558"><a href="#cb13-558" aria-hidden="true" tabindex="-1"></a><span class="in">res &lt;- matchit(</span></span>
<span id="cb13-559"><a href="#cb13-559" aria-hidden="true" tabindex="-1"></a><span class="in">  formula = dark_mode ~ age + male + hours, </span></span>
<span id="cb13-560"><a href="#cb13-560" aria-hidden="true" tabindex="-1"></a><span class="in">  data = darkmode, </span></span>
<span id="cb13-561"><a href="#cb13-561" aria-hidden="true" tabindex="-1"></a><span class="in">  distance = "glm", </span></span>
<span id="cb13-562"><a href="#cb13-562" aria-hidden="true" tabindex="-1"></a><span class="in">  caliper = .25,</span></span>
<span id="cb13-563"><a href="#cb13-563" aria-hidden="true" tabindex="-1"></a><span class="in">  mahvars = ~ age + male + hours</span></span>
<span id="cb13-564"><a href="#cb13-564" aria-hidden="true" tabindex="-1"></a><span class="in">)</span></span>
<span id="cb13-565"><a href="#cb13-565" aria-hidden="true" tabindex="-1"></a><span class="in"># (Nur K-Beobachtungen mit PS bei Caliper .25 kommen f√ºr MHD-Matching in betracht.)</span></span>
<span id="cb13-566"><a href="#cb13-566" aria-hidden="true" tabindex="-1"></a><span class="in">bal.tab(res)</span></span>
<span id="cb13-567"><a href="#cb13-567" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb13-568"><a href="#cb13-568" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-569"><a href="#cb13-569" aria-hidden="true" tabindex="-1"></a>**4. Eins-zu-Eins-Matching: Propensity scores basierend auf logistischer Regression mit Caliper 0.25**</span>
<span id="cb13-570"><a href="#cb13-570" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb13-571"><a href="#cb13-571" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb13-572"><a href="#cb13-572" aria-hidden="true" tabindex="-1"></a><span class="in">res &lt;- matchit(</span></span>
<span id="cb13-573"><a href="#cb13-573" aria-hidden="true" tabindex="-1"></a><span class="in">  formula = dark_mode ~ age + male + hours, </span></span>
<span id="cb13-574"><a href="#cb13-574" aria-hidden="true" tabindex="-1"></a><span class="in">  data = darkmode, </span></span>
<span id="cb13-575"><a href="#cb13-575" aria-hidden="true" tabindex="-1"></a><span class="in">  method = "nearest", </span></span>
<span id="cb13-576"><a href="#cb13-576" aria-hidden="true" tabindex="-1"></a><span class="in">  distance = "glm", </span></span>
<span id="cb13-577"><a href="#cb13-577" aria-hidden="true" tabindex="-1"></a><span class="in">  caliper = .25</span></span>
<span id="cb13-578"><a href="#cb13-578" aria-hidden="true" tabindex="-1"></a><span class="in">)</span></span>
<span id="cb13-579"><a href="#cb13-579" aria-hidden="true" tabindex="-1"></a><span class="in">bal.tab(res)</span></span>
<span id="cb13-580"><a href="#cb13-580" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb13-581"><a href="#cb13-581" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-582"><a href="#cb13-582" aria-hidden="true" tabindex="-1"></a>Die Vergleichbarkeit der Nutzer in Kontroll- und Treatment-Gruppe hinsichtlich der Variablen <span class="in">`age`</span>, <span class="in">`hours`</span> und <span class="in">`male`</span> k√∂nnen wir graphisch und anhand einer *balance table* vergleichen. Wir berechnen die balance table mit <span class="in">`cobalt::bal.tab()`</span> f√ºr den anhand von Variante 4 gematchten Datensatz.</span>
<span id="cb13-583"><a href="#cb13-583" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-584"><a href="#cb13-584" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb13-585"><a href="#cb13-585" aria-hidden="true" tabindex="-1"></a><span class="in">bal.tab(res, un = T, disp = "m")</span></span>
<span id="cb13-586"><a href="#cb13-586" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-587"><a href="#cb13-587" aria-hidden="true" tabindex="-1"></a><span class="in"># Der gematchte Datensatz enth√§lt Gewichte f√ºr die jeweilige </span></span>
<span id="cb13-588"><a href="#cb13-588" aria-hidden="true" tabindex="-1"></a><span class="in"># Subklasse zu denen die Beobachtungen geh√∂ren.</span></span>
<span id="cb13-589"><a href="#cb13-589" aria-hidden="true" tabindex="-1"></a><span class="in">#</span></span>
<span id="cb13-590"><a href="#cb13-590" aria-hidden="true" tabindex="-1"></a><span class="in"># Hier 1:1 matching _ohne_ Zur√ºcklegen, d.h. s√§mtliche</span></span>
<span id="cb13-591"><a href="#cb13-591" aria-hidden="true" tabindex="-1"></a><span class="in"># Gewichte sind 1 und wird m√ºssten diese nicht f√ºr nachfolgende </span></span>
<span id="cb13-592"><a href="#cb13-592" aria-hidden="true" tabindex="-1"></a><span class="in"># Aufrufe von avg comparisons ber√ºcksichtigen.</span></span>
<span id="cb13-593"><a href="#cb13-593" aria-hidden="true" tabindex="-1"></a><span class="in">darkmode_matched &lt;- match.data(res)</span></span>
<span id="cb13-594"><a href="#cb13-594" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-595"><a href="#cb13-595" aria-hidden="true" tabindex="-1"></a><span class="in">darkmode_matched %&gt;%</span></span>
<span id="cb13-596"><a href="#cb13-596" aria-hidden="true" tabindex="-1"></a><span class="in">  group_by(dark_mode) %&gt;%</span></span>
<span id="cb13-597"><a href="#cb13-597" aria-hidden="true" tabindex="-1"></a><span class="in">  select(age, hours) %&gt;%</span></span>
<span id="cb13-598"><a href="#cb13-598" aria-hidden="true" tabindex="-1"></a><span class="in">  mutate_all(scale) %&gt;%</span></span>
<span id="cb13-599"><a href="#cb13-599" aria-hidden="true" tabindex="-1"></a><span class="in">  pivot_longer(cols = c(-dark_mode)) %&gt;%</span></span>
<span id="cb13-600"><a href="#cb13-600" aria-hidden="true" tabindex="-1"></a><span class="in">  </span></span>
<span id="cb13-601"><a href="#cb13-601" aria-hidden="true" tabindex="-1"></a><span class="in">  ggplot(aes(x = value, fill = as.factor(dark_mode))) +</span></span>
<span id="cb13-602"><a href="#cb13-602" aria-hidden="true" tabindex="-1"></a><span class="in">  geom_density( alpha = .5) + </span></span>
<span id="cb13-603"><a href="#cb13-603" aria-hidden="true" tabindex="-1"></a><span class="in">  facet_wrap(~ name, scales = "free", nrow = 3)</span></span>
<span id="cb13-604"><a href="#cb13-604" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-605"><a href="#cb13-605" aria-hidden="true" tabindex="-1"></a><span class="in">darkmode_matched %&gt;% </span></span>
<span id="cb13-606"><a href="#cb13-606" aria-hidden="true" tabindex="-1"></a><span class="in">  group_by(dark_mode) %&gt;%</span></span>
<span id="cb13-607"><a href="#cb13-607" aria-hidden="true" tabindex="-1"></a><span class="in">  mutate(</span></span>
<span id="cb13-608"><a href="#cb13-608" aria-hidden="true" tabindex="-1"></a><span class="in">    male = as.factor(male), </span></span>
<span id="cb13-609"><a href="#cb13-609" aria-hidden="true" tabindex="-1"></a><span class="in">    dark_mode = as.factor(dark_mode)</span></span>
<span id="cb13-610"><a href="#cb13-610" aria-hidden="true" tabindex="-1"></a><span class="in">  ) %&gt;%</span></span>
<span id="cb13-611"><a href="#cb13-611" aria-hidden="true" tabindex="-1"></a><span class="in">  </span></span>
<span id="cb13-612"><a href="#cb13-612" aria-hidden="true" tabindex="-1"></a><span class="in">  ggplot(aes(x = dark_mode, fill = male)) +</span></span>
<span id="cb13-613"><a href="#cb13-613" aria-hidden="true" tabindex="-1"></a><span class="in">  geom_bar(position = "fill") +</span></span>
<span id="cb13-614"><a href="#cb13-614" aria-hidden="true" tabindex="-1"></a><span class="in">  ylab("Anteil")</span></span>
<span id="cb13-615"><a href="#cb13-615" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb13-616"><a href="#cb13-616" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-617"><a href="#cb13-617" aria-hidden="true" tabindex="-1"></a>Wir beobachten eine bessere Balance bei <span class="in">`age`</span> und <span class="in">`hours`</span>. Am wichtigsten: <span class="in">`gender`</span> (<span class="in">`male`</span>) ist nahezu ausgeglichen f√ºr Kontroll- und Treatment-Gruppe!</span>
<span id="cb13-618"><a href="#cb13-618" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-619"><a href="#cb13-619" aria-hidden="true" tabindex="-1"></a>Wir sch√§tzen nun den ATT von <span class="in">`dark_mode`</span> auf <span class="in">`read_time`</span> mit linearer Regression f√ºr den gematchten Datensatz aus sowie f√ºr den urspr√ºnglichen Datensatz und berechnen jeweils ein robustes 95%-Konfidenzintervall f√ºr den ATT.</span>
<span id="cb13-620"><a href="#cb13-620" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-621"><a href="#cb13-621" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb13-622"><a href="#cb13-622" aria-hidden="true" tabindex="-1"></a><span class="in"># ATT mit linearem Modell f√ºr ungematchten Datensatz sch√§tzen</span></span>
<span id="cb13-623"><a href="#cb13-623" aria-hidden="true" tabindex="-1"></a><span class="in">ATT_mod_org &lt;- lm(</span></span>
<span id="cb13-624"><a href="#cb13-624" aria-hidden="true" tabindex="-1"></a><span class="in">  formula = read_time ~ age + male + hours + dark_mode,</span></span>
<span id="cb13-625"><a href="#cb13-625" aria-hidden="true" tabindex="-1"></a><span class="in">  data = darkmode</span></span>
<span id="cb13-626"><a href="#cb13-626" aria-hidden="true" tabindex="-1"></a><span class="in">)</span></span>
<span id="cb13-627"><a href="#cb13-627" aria-hidden="true" tabindex="-1"></a><span class="in">summary(ATT_mod_org)</span></span>
<span id="cb13-628"><a href="#cb13-628" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-629"><a href="#cb13-629" aria-hidden="true" tabindex="-1"></a><span class="in"># ATT mit linearem Modell f√ºr gematchten Datensatz sch√§tzen</span></span>
<span id="cb13-630"><a href="#cb13-630" aria-hidden="true" tabindex="-1"></a><span class="in">ATT_mod &lt;- lm(</span></span>
<span id="cb13-631"><a href="#cb13-631" aria-hidden="true" tabindex="-1"></a><span class="in">  formula = read_time ~ age + male + hours + dark_mode,</span></span>
<span id="cb13-632"><a href="#cb13-632" aria-hidden="true" tabindex="-1"></a><span class="in">  data = darkmode_matched, </span></span>
<span id="cb13-633"><a href="#cb13-633" aria-hidden="true" tabindex="-1"></a><span class="in">  weights = weights </span></span>
<span id="cb13-634"><a href="#cb13-634" aria-hidden="true" tabindex="-1"></a><span class="in">)</span></span>
<span id="cb13-635"><a href="#cb13-635" aria-hidden="true" tabindex="-1"></a><span class="in"># (weights = 1 f√ºr alle Beobachtungen weil wg. 1:1-Matching</span></span>
<span id="cb13-636"><a href="#cb13-636" aria-hidden="true" tabindex="-1"></a><span class="in"># nur 2er-Paare von Beobachtungen. Hier also vernachl√§ssigbar.</span></span>
<span id="cb13-637"><a href="#cb13-637" aria-hidden="true" tabindex="-1"></a><span class="in"># Andere Gewichtung bei k:1-Matching!)</span></span>
<span id="cb13-638"><a href="#cb13-638" aria-hidden="true" tabindex="-1"></a><span class="in">summary(ATT_mod)</span></span>
<span id="cb13-639"><a href="#cb13-639" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb13-640"><a href="#cb13-640" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-641"><a href="#cb13-641" aria-hidden="true" tabindex="-1"></a>**Achtung**: F√ºr Matching-Verfahren (<span class="in">`ATT_mod`</span>) sind die von <span class="in">`summary()`</span> berechneten Standardfehler (und damit KI, t-Statistiken und p-Werte) f√ºr den ATT *grunds√§tzlich ung√ºltig* Wir haben 3 Quellen von Sch√§tzunsicherheit, die bei der Berechnung von Standardfehlern ber√ºcksichtigt werden m√ºssen: Die Sch√§tzung der PS, der Matching-Prozess und die "√ºbliche" Stichproben-Variabilit√§t. Wir nutzen daher nachfolgende Funktionen gem. Empfehlungen aus der aktuellen Forschung f√ºr Standardfehlerberechnung. S. auch Aufgabe 5 (a).</span>
<span id="cb13-642"><a href="#cb13-642" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-643"><a href="#cb13-643" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb13-644"><a href="#cb13-644" aria-hidden="true" tabindex="-1"></a><span class="in">library(marginaleffects)</span></span>
<span id="cb13-645"><a href="#cb13-645" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-646"><a href="#cb13-646" aria-hidden="true" tabindex="-1"></a><span class="in"># Inferenz Multiple Regression bei ungematchten Beobachtungen</span></span>
<span id="cb13-647"><a href="#cb13-647" aria-hidden="true" tabindex="-1"></a><span class="in"># identisch zu 'coeftest(ATT_mod_org, vcovHC, type = "HC3")'</span></span>
<span id="cb13-648"><a href="#cb13-648" aria-hidden="true" tabindex="-1"></a><span class="in">avg_comparisons(</span></span>
<span id="cb13-649"><a href="#cb13-649" aria-hidden="true" tabindex="-1"></a><span class="in">  model = ATT_mod_org,</span></span>
<span id="cb13-650"><a href="#cb13-650" aria-hidden="true" tabindex="-1"></a><span class="in">  variables = "dark_mode",</span></span>
<span id="cb13-651"><a href="#cb13-651" aria-hidden="true" tabindex="-1"></a><span class="in">  vcov = "HC3", # Heteroskedastie-robuster SE</span></span>
<span id="cb13-652"><a href="#cb13-652" aria-hidden="true" tabindex="-1"></a><span class="in">  newdata = subset(darkmode, dark_mode == 1) # Identifiziert Kontrollgruppe</span></span>
<span id="cb13-653"><a href="#cb13-653" aria-hidden="true" tabindex="-1"></a><span class="in">) </span></span>
<span id="cb13-654"><a href="#cb13-654" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-655"><a href="#cb13-655" aria-hidden="true" tabindex="-1"></a><span class="in"># Inferenz Multiple Regression bei _gematchten_ Beobachtungen</span></span>
<span id="cb13-656"><a href="#cb13-656" aria-hidden="true" tabindex="-1"></a><span class="in">avg_comparisons(</span></span>
<span id="cb13-657"><a href="#cb13-657" aria-hidden="true" tabindex="-1"></a><span class="in">  model = ATT_mod,</span></span>
<span id="cb13-658"><a href="#cb13-658" aria-hidden="true" tabindex="-1"></a><span class="in">  variables = "dark_mode",</span></span>
<span id="cb13-659"><a href="#cb13-659" aria-hidden="true" tabindex="-1"></a><span class="in">  vcov = ~subclass, # cluster robust SE &gt; als oben =&gt; mehr Unsicherheit</span></span>
<span id="cb13-660"><a href="#cb13-660" aria-hidden="true" tabindex="-1"></a><span class="in">  newdata = subset(darkmode_matched, dark_mode == 1),</span></span>
<span id="cb13-661"><a href="#cb13-661" aria-hidden="true" tabindex="-1"></a><span class="in">  wts = "weights"  # = 1</span></span>
<span id="cb13-662"><a href="#cb13-662" aria-hidden="true" tabindex="-1"></a><span class="in">)</span></span>
<span id="cb13-663"><a href="#cb13-663" aria-hidden="true" tabindex="-1"></a><span class="in"># ( Weights = 1 wg. 1:1-Matching.</span></span>
<span id="cb13-664"><a href="#cb13-664" aria-hidden="true" tabindex="-1"></a><span class="in"># Anzahl subclasses = Anzahl gematchter treatment/control units )</span></span>
<span id="cb13-665"><a href="#cb13-665" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb13-666"><a href="#cb13-666" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-667"><a href="#cb13-667" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-668"><a href="#cb13-668" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-669"><a href="#cb13-669" aria-hidden="true" tabindex="-1"></a><span class="fu">## Inferenz f√ºr ATT/ATE: Propensity-Score-Matching mit Bootstrap</span></span>
<span id="cb13-670"><a href="#cb13-670" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-671"><a href="#cb13-671" aria-hidden="true" tabindex="-1"></a>Bei Matching mit Zur√ºcklegen besteht zus√§tzliche Unsicherheit durch Zur√ºcklegen, d.h. Beobachtungen aus der Kontroll-Gruppe k√∂nnen mehrfach als Match f√ºr Beobachtungen aus der Treatment-Gruppe genutzt werden. Mit <span class="in">`summary()`</span> berechnete Standardfehler ber√ºcksichtigen dies nicht!</span>
<span id="cb13-672"><a href="#cb13-672" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-673"><a href="#cb13-673" aria-hidden="true" tabindex="-1"></a>Ein Bootstrap-Verfahren generiert mit Resampling (wiederholtes Ziehen mit Zur√ºcklegen) aus dem Original-Datensatz (viele) k√ºnstliche Datens√§tze, f√ºr die der Sch√§tzer (d.h. das gesamte Verfahren inkl. Matching!) jeweils berechnet wird. Die Verteilung der so gewonnenen Bootstrap-Sch√§tzwerte approximiert die wahre, unbekannte Stichprobenverteilung des Sch√§tzers des Behandlungseffekts. Mit dieser simulierten Verteilung k√∂nnen wir Inferenz betreiben: Wir k√∂nnen einen Bootstrap-Punktsch√§tzer des Behandlungseffekts (Stichprobenmittel der Bootstrap-Sch√§tzungen) sowie Standardfehler (Standardabweichung der der Bootstrap-Sch√§tzungen) und p-Werte berechnen.</span>
<span id="cb13-674"><a href="#cb13-674" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-675"><a href="#cb13-675" aria-hidden="true" tabindex="-1"></a>Wir Implementieren nun einen Bootstrap-Sch√§tzer des ATT als <span class="in">`R`</span>-Funktion <span class="in">`boot_fun()`</span>.</span>
<span id="cb13-676"><a href="#cb13-676" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-677"><a href="#cb13-677" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb13-678"><a href="#cb13-678" aria-hidden="true" tabindex="-1"></a><span class="in">boot_fun &lt;- function(data, i) {</span></span>
<span id="cb13-679"><a href="#cb13-679" aria-hidden="true" tabindex="-1"></a><span class="in">  </span></span>
<span id="cb13-680"><a href="#cb13-680" aria-hidden="true" tabindex="-1"></a><span class="in">  boot_data &lt;- data[i, ]</span></span>
<span id="cb13-681"><a href="#cb13-681" aria-hidden="true" tabindex="-1"></a><span class="in">  </span></span>
<span id="cb13-682"><a href="#cb13-682" aria-hidden="true" tabindex="-1"></a><span class="in">  # 1:1 PS Matching _mit_ Zur√ºcklegen</span></span>
<span id="cb13-683"><a href="#cb13-683" aria-hidden="true" tabindex="-1"></a><span class="in">  match_res &lt;- matchit(dark_mode ~ age + hours + male,</span></span>
<span id="cb13-684"><a href="#cb13-684" aria-hidden="true" tabindex="-1"></a><span class="in">                       data = boot_data,</span></span>
<span id="cb13-685"><a href="#cb13-685" aria-hidden="true" tabindex="-1"></a><span class="in">                       caliper = .25,</span></span>
<span id="cb13-686"><a href="#cb13-686" aria-hidden="true" tabindex="-1"></a><span class="in">                       replace = TRUE) # Zur√ºcklegen</span></span>
<span id="cb13-687"><a href="#cb13-687" aria-hidden="true" tabindex="-1"></a><span class="in">  </span></span>
<span id="cb13-688"><a href="#cb13-688" aria-hidden="true" tabindex="-1"></a><span class="in">  # Gematchten Datensatz zuweisen</span></span>
<span id="cb13-689"><a href="#cb13-689" aria-hidden="true" tabindex="-1"></a><span class="in">  darkmode_matched &lt;- match.data(match_res, data = boot_data)</span></span>
<span id="cb13-690"><a href="#cb13-690" aria-hidden="true" tabindex="-1"></a><span class="in">  </span></span>
<span id="cb13-691"><a href="#cb13-691" aria-hidden="true" tabindex="-1"></a><span class="in">  # Outcome-Modell sch√§tzen</span></span>
<span id="cb13-692"><a href="#cb13-692" aria-hidden="true" tabindex="-1"></a><span class="in">  ATT_mod &lt;- lm(</span></span>
<span id="cb13-693"><a href="#cb13-693" aria-hidden="true" tabindex="-1"></a><span class="in">    formula = read_time ~ age + male + hours + dark_mode,</span></span>
<span id="cb13-694"><a href="#cb13-694" aria-hidden="true" tabindex="-1"></a><span class="in">    data = darkmode_matched, </span></span>
<span id="cb13-695"><a href="#cb13-695" aria-hidden="true" tabindex="-1"></a><span class="in">    weights = weights # hier teilweise &gt; 1 wg. Matching mit Zur√ºcklegen!</span></span>
<span id="cb13-696"><a href="#cb13-696" aria-hidden="true" tabindex="-1"></a><span class="in">  )</span></span>
<span id="cb13-697"><a href="#cb13-697" aria-hidden="true" tabindex="-1"></a><span class="in">  </span></span>
<span id="cb13-698"><a href="#cb13-698" aria-hidden="true" tabindex="-1"></a><span class="in">  #  ATT-Sch√§tzer auslesen</span></span>
<span id="cb13-699"><a href="#cb13-699" aria-hidden="true" tabindex="-1"></a><span class="in">  return(</span></span>
<span id="cb13-700"><a href="#cb13-700" aria-hidden="true" tabindex="-1"></a><span class="in">    ATT_mod$coefficients["dark_mode"]  </span></span>
<span id="cb13-701"><a href="#cb13-701" aria-hidden="true" tabindex="-1"></a><span class="in">  )</span></span>
<span id="cb13-702"><a href="#cb13-702" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb13-703"><a href="#cb13-703" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb13-704"><a href="#cb13-704" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-705"><a href="#cb13-705" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-706"><a href="#cb13-706" aria-hidden="true" tabindex="-1"></a>Abadie &amp; Imbens (2008) zeigen analytisch, dass ein Standard-Bootstrap bei Matching grunds√§tzlich ung√ºltig ist: Die unbekannte Varianz der Stichprobenverteilung des Matching-Sch√§tzers (und damit der Standardfehler des Sch√§tzers) kann durch den Bootstrap nicht repliziert werden. Problematisch hierbei sind grunds√§tzlich zu liberale (d.h. zu gro√üe) mit dem Bootstrap berechnete Standardfehler. Es gibt jedoch Simulationsnachweise die zeigen, dass Bootstrap-Standardfehler bei Matching mit Zur√ºcklegen konservativ sind (Bodory et al., 2020), also tendentiell zu kleine Standardfehler produzieren und damit das gew√ºnschte nominale Signifikanzniveau eines Bootstrap-Hypothesentests nicht √ºberschritten wird.</span>
<span id="cb13-707"><a href="#cb13-707" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-708"><a href="#cb13-708" aria-hidden="true" tabindex="-1"></a>Wir berechnen nun eine Bootstrap-Sch√§tzung des ATT von <span class="in">`dark_mode`</span> auf <span class="in">`readingtime`</span> sowie den zugeh√∂rigen Standardfehler und ein 95%-KI mit der zuvor definierten Funktion <span class="in">`boot_fun`</span>.</span>
<span id="cb13-709"><a href="#cb13-709" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-710"><a href="#cb13-710" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb13-711"><a href="#cb13-711" aria-hidden="true" tabindex="-1"></a><span class="in">library("boot")</span></span>
<span id="cb13-712"><a href="#cb13-712" aria-hidden="true" tabindex="-1"></a><span class="in">set.seed(4321)</span></span>
<span id="cb13-713"><a href="#cb13-713" aria-hidden="true" tabindex="-1"></a><span class="in">boot_out &lt;- boot(darkmode, boot_fun, R = 999)</span></span>
<span id="cb13-714"><a href="#cb13-714" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-715"><a href="#cb13-715" aria-hidden="true" tabindex="-1"></a><span class="in">boot_out</span></span>
<span id="cb13-716"><a href="#cb13-716" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb13-717"><a href="#cb13-717" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-718"><a href="#cb13-718" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb13-719"><a href="#cb13-719" aria-hidden="true" tabindex="-1"></a><span class="in"># Bootstrap-Sch√§tzer f√ºr den Treatment-Effekt</span></span>
<span id="cb13-720"><a href="#cb13-720" aria-hidden="true" tabindex="-1"></a><span class="in">mean(boot_out$t) </span></span>
<span id="cb13-721"><a href="#cb13-721" aria-hidden="true" tabindex="-1"></a><span class="in"># = mean(t0) + bias = mean(Bootstrap_samples)</span></span>
<span id="cb13-722"><a href="#cb13-722" aria-hidden="true" tabindex="-1"></a><span class="in"># vgl. 't0 = boot_fun(darkmode, i = 1:1e3)'</span></span>
<span id="cb13-723"><a href="#cb13-723" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-724"><a href="#cb13-724" aria-hidden="true" tabindex="-1"></a><span class="in"># Bootstrap-Standardfehler</span></span>
<span id="cb13-725"><a href="#cb13-725" aria-hidden="true" tabindex="-1"></a><span class="in">sd(boot_out$t)</span></span>
<span id="cb13-726"><a href="#cb13-726" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-727"><a href="#cb13-727" aria-hidden="true" tabindex="-1"></a><span class="in"># 95% Bootstrap-KI f√ºr den Treatment-Effekt</span></span>
<span id="cb13-728"><a href="#cb13-728" aria-hidden="true" tabindex="-1"></a><span class="in">boot.ci(boot_out, type = "perc")</span></span>
<span id="cb13-729"><a href="#cb13-729" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb13-730"><a href="#cb13-730" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-731"><a href="#cb13-731" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-732"><a href="#cb13-732" aria-hidden="true" tabindex="-1"></a><span class="fu">## Doubly-Robust-Sch√§tzer f√ºr ATT/ATE</span></span>
<span id="cb13-733"><a href="#cb13-733" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-734"><a href="#cb13-734" aria-hidden="true" tabindex="-1"></a>Implementieren und berechnen Sie einen Doubly-Robust-Sch√§tzer des ATT (vgl. Wooldridge, 2010) f√ºr den kausalen Effekt in Aufgabe 5. Vergleichen Sie mit den Ergebnissen der Aufgaben 1 (d), 4 (f) und 5 (d).</span>
<span id="cb13-735"><a href="#cb13-735" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-736"><a href="#cb13-736" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb13-737"><a href="#cb13-737" aria-hidden="true" tabindex="-1"></a><span class="in"># IPW estimation with regression adjustment</span></span>
<span id="cb13-738"><a href="#cb13-738" aria-hidden="true" tabindex="-1"></a><span class="in">ipwra &lt;- function(br, index = 1:nrow(br)) {</span></span>
<span id="cb13-739"><a href="#cb13-739" aria-hidden="true" tabindex="-1"></a><span class="in">    # slice bootstrapped observations</span></span>
<span id="cb13-740"><a href="#cb13-740" aria-hidden="true" tabindex="-1"></a><span class="in">    br &lt;- br %&gt;% slice(index)</span></span>
<span id="cb13-741"><a href="#cb13-741" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb13-742"><a href="#cb13-742" aria-hidden="true" tabindex="-1"></a><span class="in">    # estimate and predict propensity score</span></span>
<span id="cb13-743"><a href="#cb13-743" aria-hidden="true" tabindex="-1"></a><span class="in">    m &lt;- glm(formula = dark_mode ~ age + hours + male,</span></span>
<span id="cb13-744"><a href="#cb13-744" aria-hidden="true" tabindex="-1"></a><span class="in">             data = br, </span></span>
<span id="cb13-745"><a href="#cb13-745" aria-hidden="true" tabindex="-1"></a><span class="in">             family = binomial(link = 'logit'))</span></span>
<span id="cb13-746"><a href="#cb13-746" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb13-747"><a href="#cb13-747" aria-hidden="true" tabindex="-1"></a><span class="in">    br &lt;- br %&gt;%</span></span>
<span id="cb13-748"><a href="#cb13-748" aria-hidden="true" tabindex="-1"></a><span class="in">        mutate(ps = predict(m, type = 'response'))</span></span>
<span id="cb13-749"><a href="#cb13-749" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb13-750"><a href="#cb13-750" aria-hidden="true" tabindex="-1"></a><span class="in">    # trim control observations outside of treated PS range</span></span>
<span id="cb13-751"><a href="#cb13-751" aria-hidden="true" tabindex="-1"></a><span class="in">    minps &lt;- br %&gt;%</span></span>
<span id="cb13-752"><a href="#cb13-752" aria-hidden="true" tabindex="-1"></a><span class="in">        filter(dark_mode == 1) %&gt;%</span></span>
<span id="cb13-753"><a href="#cb13-753" aria-hidden="true" tabindex="-1"></a><span class="in">        pull(ps) %&gt;%</span></span>
<span id="cb13-754"><a href="#cb13-754" aria-hidden="true" tabindex="-1"></a><span class="in">        min(na.rm = TRUE)</span></span>
<span id="cb13-755"><a href="#cb13-755" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb13-756"><a href="#cb13-756" aria-hidden="true" tabindex="-1"></a><span class="in">    maxps &lt;- br %&gt;%</span></span>
<span id="cb13-757"><a href="#cb13-757" aria-hidden="true" tabindex="-1"></a><span class="in">        filter(dark_mode == 1) %&gt;%</span></span>
<span id="cb13-758"><a href="#cb13-758" aria-hidden="true" tabindex="-1"></a><span class="in">        pull(ps) %&gt;%</span></span>
<span id="cb13-759"><a href="#cb13-759" aria-hidden="true" tabindex="-1"></a><span class="in">        max(na.rm = TRUE)</span></span>
<span id="cb13-760"><a href="#cb13-760" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb13-761"><a href="#cb13-761" aria-hidden="true" tabindex="-1"></a><span class="in">    # do the trimming</span></span>
<span id="cb13-762"><a href="#cb13-762" aria-hidden="true" tabindex="-1"></a><span class="in">    br &lt;- br %&gt;%</span></span>
<span id="cb13-763"><a href="#cb13-763" aria-hidden="true" tabindex="-1"></a><span class="in">        filter(ps &gt;= minps &amp; ps &lt;= maxps)</span></span>
<span id="cb13-764"><a href="#cb13-764" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb13-765"><a href="#cb13-765" aria-hidden="true" tabindex="-1"></a><span class="in">    # compute IPWs</span></span>
<span id="cb13-766"><a href="#cb13-766" aria-hidden="true" tabindex="-1"></a><span class="in">    br &lt;- br %&gt;%</span></span>
<span id="cb13-767"><a href="#cb13-767" aria-hidden="true" tabindex="-1"></a><span class="in">      mutate(</span></span>
<span id="cb13-768"><a href="#cb13-768" aria-hidden="true" tabindex="-1"></a><span class="in">        ipw = case_when(</span></span>
<span id="cb13-769"><a href="#cb13-769" aria-hidden="true" tabindex="-1"></a><span class="in">          dark_mode == 1 ~ 1 / ps,</span></span>
<span id="cb13-770"><a href="#cb13-770" aria-hidden="true" tabindex="-1"></a><span class="in">          dark_mode == 0 ~ 1 / (1 - ps))</span></span>
<span id="cb13-771"><a href="#cb13-771" aria-hidden="true" tabindex="-1"></a><span class="in">      )</span></span>
<span id="cb13-772"><a href="#cb13-772" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb13-773"><a href="#cb13-773" aria-hidden="true" tabindex="-1"></a><span class="in">    # Simple _ATT_ estimate:</span></span>
<span id="cb13-774"><a href="#cb13-774" aria-hidden="true" tabindex="-1"></a><span class="in">    # w_means &lt;- br %&gt;%</span></span>
<span id="cb13-775"><a href="#cb13-775" aria-hidden="true" tabindex="-1"></a><span class="in">    #     group_by(dark_mode) %&gt;%</span></span>
<span id="cb13-776"><a href="#cb13-776" aria-hidden="true" tabindex="-1"></a><span class="in">    #     summarize(m = weighted.mean(read_time, w = ipw)) %&gt;% </span></span>
<span id="cb13-777"><a href="#cb13-777" aria-hidden="true" tabindex="-1"></a><span class="in">    #     arrange(dark_mode)</span></span>
<span id="cb13-778"><a href="#cb13-778" aria-hidden="true" tabindex="-1"></a><span class="in">    # </span></span>
<span id="cb13-779"><a href="#cb13-779" aria-hidden="true" tabindex="-1"></a><span class="in">    # # simple diff-in-means _ATT_ estimate</span></span>
<span id="cb13-780"><a href="#cb13-780" aria-hidden="true" tabindex="-1"></a><span class="in">    #  return(w_means$m[2] - w_means$m[1]) </span></span>
<span id="cb13-781"><a href="#cb13-781" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb13-782"><a href="#cb13-782" aria-hidden="true" tabindex="-1"></a><span class="in">    # Do regression adjustment for _ATE_ estimate</span></span>
<span id="cb13-783"><a href="#cb13-783" aria-hidden="true" tabindex="-1"></a><span class="in">    # TE prediction for whole sample based on TG model</span></span>
<span id="cb13-784"><a href="#cb13-784" aria-hidden="true" tabindex="-1"></a><span class="in">    mtreat &lt;- br %&gt;%</span></span>
<span id="cb13-785"><a href="#cb13-785" aria-hidden="true" tabindex="-1"></a><span class="in">      filter(dark_mode == 1) %&gt;%</span></span>
<span id="cb13-786"><a href="#cb13-786" aria-hidden="true" tabindex="-1"></a><span class="in">      lm(read_time ~ 1 + age + hours + male, data = ., weights = .$ipw) %&gt;%</span></span>
<span id="cb13-787"><a href="#cb13-787" aria-hidden="true" tabindex="-1"></a><span class="in">      predict(newdata = br) %&gt;%</span></span>
<span id="cb13-788"><a href="#cb13-788" aria-hidden="true" tabindex="-1"></a><span class="in">      mean()</span></span>
<span id="cb13-789"><a href="#cb13-789" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb13-790"><a href="#cb13-790" aria-hidden="true" tabindex="-1"></a><span class="in">    # TE prediction for whole sample based on CG model</span></span>
<span id="cb13-791"><a href="#cb13-791" aria-hidden="true" tabindex="-1"></a><span class="in">    mcont &lt;- br %&gt;%</span></span>
<span id="cb13-792"><a href="#cb13-792" aria-hidden="true" tabindex="-1"></a><span class="in">      filter(dark_mode == 0) %&gt;%</span></span>
<span id="cb13-793"><a href="#cb13-793" aria-hidden="true" tabindex="-1"></a><span class="in">      lm(read_time ~ 1 + age + hours + male, data = ., weights = .$ipw) %&gt;%</span></span>
<span id="cb13-794"><a href="#cb13-794" aria-hidden="true" tabindex="-1"></a><span class="in">      predict(newdata = br) %&gt;%</span></span>
<span id="cb13-795"><a href="#cb13-795" aria-hidden="true" tabindex="-1"></a><span class="in">      mean()</span></span>
<span id="cb13-796"><a href="#cb13-796" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-797"><a href="#cb13-797" aria-hidden="true" tabindex="-1"></a><span class="in">    return(mtreat - mcont) # Regression adjusted _ATE_ estimate</span></span>
<span id="cb13-798"><a href="#cb13-798" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb13-799"><a href="#cb13-799" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb13-800"><a href="#cb13-800" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-801"><a href="#cb13-801" aria-hidden="true" tabindex="-1"></a><span class="in">```{webr-r}</span></span>
<span id="cb13-802"><a href="#cb13-802" aria-hidden="true" tabindex="-1"></a><span class="in">b &lt;- boot(data = darkmode, ipwra, R = 999)</span></span>
<span id="cb13-803"><a href="#cb13-803" aria-hidden="true" tabindex="-1"></a><span class="in"># Bootstrap estimate and standard error</span></span>
<span id="cb13-804"><a href="#cb13-804" aria-hidden="true" tabindex="-1"></a><span class="in">mean(b$t)</span></span>
<span id="cb13-805"><a href="#cb13-805" aria-hidden="true" tabindex="-1"></a><span class="in">sd(b$t)</span></span>
<span id="cb13-806"><a href="#cb13-806" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb13-807"><a href="#cb13-807" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-808"><a href="#cb13-808" aria-hidden="true" tabindex="-1"></a>\vfill</span>
<span id="cb13-809"><a href="#cb13-809" aria-hidden="true" tabindex="-1"></a><span class="fu"># Literatur</span></span>
<span id="cb13-810"><a href="#cb13-810" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-811"><a href="#cb13-811" aria-hidden="true" tabindex="-1"></a>Abadie, Alberto, and Guido W. Imbens. (2008). *On the Failure of the Bootstrap for Matching Estimators.*Econometrica 76 (**6**): 1537‚Äì57.</span>
<span id="cb13-812"><a href="#cb13-812" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-813"><a href="#cb13-813" aria-hidden="true" tabindex="-1"></a>Bodory, H., Camponovo, L., Huber, M., &amp; Lechner, M. (2020). *The Finite Sample Performance of Inference Methods for Propensity Score Matching and Weighting Estimators*. Journal of Business &amp; Economic Statistics, 38(**1**), 183‚Äì200.</span>
<span id="cb13-814"><a href="#cb13-814" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-815"><a href="#cb13-815" aria-hidden="true" tabindex="-1"></a>Wooldridge, J. M. (2010). *Econometric analysis of cross section and panel data*. MIT press.</span>
<span id="cb13-816"><a href="#cb13-816" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-817"><a href="#cb13-817" aria-hidden="true" tabindex="-1"></a></span>
</code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->



</body></html>