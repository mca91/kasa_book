---
format: live-html
engine: knitr
webr:
  packages:
    - tibble
---

{{< include ./_extensions/r-wasm/live/_knitr.qmd >}}

# Einleitung

```{r}
#| echo: false
source("setup.R")

# Formatierung von gt-Tabellen
tabopts <- function(x) {
    fmt_number(x, decimals = 3, drop_trailing_zeros = T) %>%
  tab_options(table_body.hlines.color = "white", 
              column_labels.border.bottom.color = "black", 
             column_labels.border.top.color = "black",
             table_body.border.bottom.color = "black",
             column_labels.font.weight = "bold", 
             table.font.color = "black", table.font.size = 14)
}
```

Mit der zunehmenden Verfügbarkeit großer Datenmengen und damit einhergehend komplexeren Forschungsfragen ist der Einsatz fortschrittlicher statistischer Verfahren in den empirischen Wirtschaftswissenschaften notwendig geworden, die über traditionelle Regressionsansätze hinausgehen. Insbesondere Methoden der Kausalanalyse und des maschinellen Lernens haben sich in den letzten Jahren als Teil eines modernen Methoden-Baukastens etabliert und gewinnen auch jenseits des akademischen Bereichs zunehmend an Bedeutung: Die Fähigkeit mit statistischer Analyse in Produktivumgebungen fundierte Aussagen über Ursache-Wirkungs-Zusammenhänge zu treffen und leistungsfähige Vorhersagemodelle zu erstellen, ist für Absolventen wirtschaftswissenschaftlicher Studiengänge in vielen Berufsfeldern zu einer arbeitsmarktrelevanten Qualifikation geworden.

Dieses Online-Kompendium, *Kausalanalyse und Maschinelles Lernen mit R* (KMLR), bietet Studierenden eine interaktive Lernplattform, die darauf ausgerichtet ist, in quantitativen Lehrveranstaltungen vermittelte Inhalte im Selbststudium zu vertiefen und praktisch anzuwenden. KMLR bietet eine Vielzahl dynamischer Elemente, darunter interaktive Grafiken und Anwendungen mit Illustrationen statistischer Konzepte in [Observable](https://observablehq.com/), sowie eine mit [webR](https://docs.r-wasm.org/webr) erzeugte R-Konsole.^[KMLR wird mit dem Publikationssystem [Quarto](https://quarto.org/) erzeugt.] Hiemit können Studierende R-Code direkt im Browser ausführen, um in Fallstudien statistische Analysen eigenständig zu replizieren, die Ergebnisse nachzuvollziehen und zu lernen, wie diese reproduzierbar aufzubereitet werden können – ein wesentlicher Bestandteil moderner wissenschaftlicher Praxis. Für ein besseres Verständnis theoretischer Konzepte kann der vorgegebene R-Code modifiziert werden (beispielsweise zur Anpassung der Parameter von Schätzfunktionen oder Simulation), um durch eigenständiges Experimentieren ein tieferes Verständnis der behandelten Methoden zu erlangen.

Als [offene Bildungsressource](https://github.com/mca91/kasa_book) (open educational ressource, OER) ermöglichen wir Dozierenden, ihre bestehenden Lehrveranstaltungen durch den Einsatz von KLMR um relevante Themen zu erweitern und ihren Studierenden eine innovative und praxisnahe Lernerfahrung zu bieten.

## Inhalt

## Konventionen und Hinweise

Wir verwenden folgende Konventionen hinsichtlich der Formatierung und Einbindung von R-Code:

Mit `so formatiertem Text` referenzieren wir einzeilige Bestandteile komplexerer Code-Statements, häufig R-Objekte oder Funktionsargumente. Solcher *Inline-Code* wird häufig im Fließtext verwendet, um nicht ausführbare und ausführbare Code-Anweisungen besser unterscheidbar zu machen und insbesondere letztere zu erläutern.

Grundsätzlich wird ausführbarer mehrzeiliger R-Code in Form von Blöcken dargestellt, die als *Code-Chunks* bezeichnet werden. In Code-Chunks wird gezeigt, wie die im Fließtext beschriebenen Schritte einer Analyse mit R umgesetzt werden können. Für eine bessere Nachvollziehbarkeit einzelner Bestandteile des Codes werden durch `#` gekennzeichnete `# Kommentare` verwendet.^[Code-Chunks können per Klick auf das Clipboard-Symbol <i class="bi bi-clipboard"></i> (bei mouse-over) in die Zwischenablage kopiert werden.]

Beispiel: Der nächste Code-Chunk definiert das `tibble`-Objekt `dat` mit vier Beobachtungen der Variable `Alter` und berechnet das Durchschnittsalter.

```{r}
library(tibble)

# Beispiel-Datensatz erzeugen  
dat <- tibble(
  Alter = c(28, 34, 23, 45)
)

# Durchschnittsalter berechnen
mean(dat$Alter)
```

Das Ergebnis der Berechnung wird direkt unterhalb des Code-Chunks dargestellt. Der gezeigte *Output* eines Chunks entspricht meist einer solchen Ausgabe in der R-Konsole oder einer Grafik, wie im nächsten Beispiel.
  
```{r}
#| fig-cap: "Die mit `plot(dat$Alter)` erzeugte Grafik"
#| label: fig-replotex
# Alter plotten
plot(dat$Alter)
```

**WebR**

Ein Großteil des gezeigten R-Codes wird in WebR-Chunks eingebunden. Ein WebR-Chunk kann am besten als ein interaktiver R-Editor verstanden werden: R-Code kann per Klick auf *Run Code* zur Auswertung an eine im Hintergrund laufende R-Session übergeben werden.^[Eine Alternative ist die aus *RStudio* bekannte shortcut *CTRL+Enter* (MacOS: *CMD+Enter*).] Wie bei "normalen" Code-Chunks werden die Ergebnisse direkt unter dem Webr-Chunk angezeigt. Der in einem WebR-Chunk vorgegebene Code kann beliebig angepasst werden. Ein Klick auf *Start Over* stellt den ursprünglichen Zustand wieder her. 

Der nachfolgende WebR-Chunk macht die Definition von `dat` und die Berechnung des Durchschnittsalters unmittelbar im Browser reproduzierbar.

```{webr}
#| autorun: false
library(tibble)

# Beispiel-Datensatz erzeugen  
dat <- tibble(
  Alter = c(28, 34, 23, 45)
)

# Durchschnittsalter berechnen
mean(dat$Alter)
```

Bei der Interkation mit WebR-Chunks ist Folgendes zu beachten:

Die WebR-Session wird lokal im Browser ausgeführt. Die Performanz bei komplexeren Berechnungen ist daher von dem verwendeten Broweser und der Hardware des genutzen Endgerätes abghängig. Auch hinsichtlich typischer Limitationen von Mobilgeräten empfehlen wir, KLMR auf einem Notebook oder PC aufzurufen. 

Die WebR-Chunks werden bei jeder Aktualisierung des Browser-Tabs auf den durch uns (die Autoren) definierten Zustand zurückgesetzt. Das Bedeutet, dass durch den Nutzer geschriebener Code, berechnete Ergebnisse und definierte Objekte *bei einer Aktualisierung gelöscht werden*.
  
Innerhalb eines Kapitels sind die WebR-Chunks durch die im Hintergrund laufende R-Session verknüpft und greifen damit auf den selben Speicher für R-Objekte zu. Wir nutzen diese Eigenschaft für prozedurale Analysen, in denen bspw. zunächst einen Datensatz geladen und aufbreitet wird, um im folgenden Chunk ein ökonometrisches Modell zu schätzen.

Sämtliche für die Analyse nötigen Pakete sind bereits vorinstalliert und müssen *nicht* durch den Nutzer installiert werden.^[Eine Installation weiterer Pakete durch Nutzer*innen ist möglich, sofern diese Pakete in einer WebR-kompatiblen Version vorliegen. Installation und laden eines Pakets erfolgen mit `library(Paketname)`.]
  
WebR-Chunks und "nicht-interaktiver" R-Code sind *nicht* miteinander verknüpft: R-Objekte, die wir in normalen Code-Chunks definieren, sind nicht notwendigerweise in WebR-Chunks verfügbar.
  
Insbsondere in Fallstudien werden WebR-Chunks oft automatisch beim Laden des Kapitels ausgeführt, um die Nachvollziehbarkeit der Erläuterungen im Fließtext zu gewährleisten. Hierbei werden oft relevante R-Pakete heruntergeladen, installiert und Berechnungen durchgeführt. Die WebR-Chunk sind erst nach Abschluss dieses Prozesses interaktiv. Der Status des Installationsprozesses wird unten rechts im Browser angezeigt. Bei laufenden Berechnung erscheint in der Kopfzeile aller Chunks ein Indikator.^[Laufende Vorbereitungen und Berechnungen werden durch <span class="exercise-editor-eval-indicator spinner-grow spinner-grow-sm" role="status"></span> angezeigt.]
  
Der nächste Code-Chunk simuliert eine für 5 Sekunden laufende Berechnung und die anschließende Ausgabe eines Ergebnisses.

```{webr}
#| autorun: false
# Die Laufzeit dieser Zeile beträgt 5 Sekunden
Sys.sleep(time = 5) # 5 Sekunden nichts tun

# Leser*innen begrüßen
cat("Hey, willkommen bei KLMR!")
```

**Interaktive Visualisierungen**

In theorie-lastigen Abschnitten des Kompendiums setzen wir interaktive Grafiken und Applikationen (Apps) ein, um komplexere mathematische Konzepte zu veranschaulichen. Diese meist in [Observable](https://observablehq.com/)-Notebooks implementierten Grafiken können durch Variation der Parametern über verschiedene Input-Elemente (meist Slider) angepasst werden.^[Der Quellcode dieser Grafiken ist unter den eingebetteten Links in Observable-Notebooks verfügbar. Die Notebooks sind ebenfalls OER und können in HTML-Lehrmaterialien [eingebettet werden](https://observablehq.com/documentation/embeds/).] Die nachfolgende App ist ein Beispiel aus @sec-regression.

<iframe width="100%" height="682" frameborder="0" class="box-shadow" src="https://observablehq.com/embed/@mca91/latent-variable-cdf?cells=plot%2Cviewof+beta0%2Cviewof+beta"></iframe>

Oftmals geben wir detaillierte Erläuterungen zu voreingestellten Parameterkombination und geben weitere Beispiele zu interessanten Eigenschaften des gezeigten Studienobjekts, die für bestimmte Einstellungen beobachtet werden können.^[Hier zum Beispiel, dass der Schnittpunkt der gezeigten Wahrscheinlichkeitsfunktionen lediglich für $\beta_0 = 0$ unabhängig von $\beta_1$ ist.] Diese Beispiele sind nicht erschöpfend und wir laden Lehrende und Studierende herzlich zum experimentieren ein!


## Verschiedenes und Danksagungen

Unterstützung mit Issues bei github, hypothesis

KLMR und die verlinkten Lehrmaterialien sind im Rahmen des von der [*Stiftung Innovationen in der digitalen Hochschullehre*](https://stiftung-hochschullehre.de) geförderten Projekts *Kausalanalyse, Maschinelles Lernen und Reproduzierbare Forschung* im Förderprogramm [*Freiraum 2022*](https://stiftung-hochschullehre.de/foerderung/freiraum/) entstanden. Wir bedanken uns für die finanzielle Unterstützung.

Wir danken Ilona Braun für ihre unverzichtbare Hilfe bei der Projektadministration, Jens Klenke und Lennard Maßmann für anregende Impulse und ihre Hilfe bei Erprobung und Evaluation der Materialien im Lehrbetrieb sowie unseren wissenschaftlichen Hilfskräften für ihre Unterstützung bei Revisionen.
