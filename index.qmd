---
format: live-html
engine: knitr
webr:
  packages:
    - tibble
---

{{< include ./_extensions/r-wasm/live/_knitr.qmd >}}

# Einleitung

```{r}
#| echo: false
source("setup.R")

# Formatierung von gt-Tabellen
tabopts <- function(x) {
    fmt_number(x, decimals = 3, drop_trailing_zeros = T) %>%
  tab_options(table_body.hlines.color = "white", 
              column_labels.border.bottom.color = "black", 
             column_labels.border.top.color = "black",
             table_body.border.bottom.color = "black",
             column_labels.font.weight = "bold", 
             table.font.color = "black", table.font.size = 14)
}
```

Mit der zunehmenden Verfügbarkeit großer Datenmengen und damit einhergehend komplexeren Forschungsfragen ist der Einsatz fortschrittlicher statistischer Verfahren in den empirischen Wirtschaftswissenschaften notwendig geworden, die über traditionelle Regressionsansätze hinausgehen. Insbesondere Methoden der Kausalanalyse und des maschinellen Lernens haben sich in den letzten Jahren als Teil eines modernen Methoden-Baukastens etabliert und gewinnen auch jenseits des akademischen Bereichs zunehmend an Bedeutung: Die Fähigkeit mit statistischer Analyse in Produktivumgebungen fundierte Aussagen über Ursache-Wirkungs-Zusammenhänge zu treffen und leistungsfähige Vorhersagemodelle zu erstellen, ist für Absolventen wirtschaftswissenschaftlicher Studiengänge in vielen Berufsfeldern zu einer arbeitsmarktrelevanten Qualifikation geworden.

Dieses Online-Kompendium, *Kausalanalyse und Maschinelles Lernen mit R* (KMLR), bietet Studierenden eine interaktive Lernplattform, die darauf ausgerichtet ist, in quantitativen Lehrveranstaltungen vermittelte Inhalte im Selbststudium zu vertiefen und praktisch anzuwenden. KMLR Kompendium eine Vielzahl dynamischer Elemente, darunter interaktive Grafiken und Anwendungen zu Illustration statistischer Konzepte mit [Observable](https://observablehq.com/), sowie eine mit [webR](https://docs.r-wasm.org/webr) erzeugte R-Konsole.^[KMLR wird mit dem Publikationssystem [Quarto](https://quarto.org/) erzeugt.] Hiemit können Studierende R-Code direkt im Browser ausführen, um in Fallstudien statistische Analysen eigenständig zu replizieren, die Ergebnisse nachzuvollziehen und zu lernen, wie diese reproduzierbar aufzubereitet werden können – ein wesentlicher Bestandteil moderner wissenschaftlicher Praxis. Für ein besseres Verständnis theoretischer Konzepte kann der vorgegebene R-Code modifiziert werden (beispielsweise zur Anpassung der Parameter von Schätzfunktionen oder Simulation), um durch eigenständiges Experimentieren ein tieferes Verständnis der behandelten Methoden zu erlangen.

Als [offene Bildungsressource](https://github.com/mca91/kasa_book) ermöglichen wir Dozierenden, ihre bestehenden Lehrveranstaltungen durch den Einsatz von KLMR um relevante Themen zu erweitern und ihren Studierenden eine innovative und praxisnahe Lernerfahrung zu bieten.

Wir verwenden folgende Konventionen hinsichtlich der Formatierung und Einbindung von R-Code:

Mit `so formatiertem Text` referenzieren wir einzeilige Bestandteile komplexerer Code-Statements, häufig R-Objekte oder Funktionsargumente. Solcher *Inline-Code* wird häufig im Fließtext verwendet, um nicht ausführbare und ausführbare Code-Anweisungen besser unterscheidbar zu machen und insbesondere letztere zu erläutern.

Grundsätzlich wird ausführbarer mehrzeiliger R-Code in Form von Blöcken dargestellt, die als *Code-Chunks* bezeichnet werden. In Code-Chunks wird gezeigt, wie die im Fließtext beschriebenen Schritte einer Analyse mit R umgesetzt werden können. Für eine bessere Nachvollziehbarkeit einzelner Bestandteile des Codes werden durch `#` gekennzeichnete `# Kommentare` verwendet.^[Code-Chunks können per Klick auf das Clipboard-Symbol <i class="bi bi-clipboard"></i> (bei mouse-over) in die Zwischenablage kopiert werden.]

Beispiel: Der nächste Code-Chunk definiert das `tibble`-Objekt `dat` mit vier Beobachtungen der Variable `Alter` und berechnet das Durchschnittsalter.

```{r}
library(tibble)

# Beispiel-Datensatz erzeugen  
dat <- tibble(
  Alter = c(28, 34, 23, 45)
)

# Durchschnittsalter berechnen
mean(dat$Alter)
```

Das Ergebnis der Berechnung wird direkt unterhalb des Code-Chunks dargestellt. Der gezeigte *Output* eines Chunks entspricht meist einer solchen Ausgabe in der R-Konsole oder einer Grafik, wie im nächsten Beispiel.
  
```{r}
#| fig-cap: "Die mit `plot(dat$Alter)` erzeugte Grafik"
#| label: fig-replotex
# Alter plotten
plot(dat$Alter)
```

Ein Großteil des gezeigten R-Codes wird in WebR-Chunks eingebunden. Ein WebR-Chunk kann am besten als ein interaktiver R-Editor verstanden werden: R-Code kann per Klick auf *Run Code* zur Auswertung an eine im Hintergrund laufende R-Session übergeben werden. Wie bei "normalen" Code-Chunks werden die Ergebnisse direkt unter dem Webr-Chunk angezeigt. Der in einem WebR-Chunk vorgegebene Code kann beliebig angepasst werden. Ein Klick auf *Start Over* stellt den ursprünglichen Zustand wieder her. 

Der nachfolgende WebR-Chunk macht die Definition von `dat` und die Berechnung des Durchschnittsalters unmittelbar im Browser reproduzierbar.

```{webr}
#| autorun: false
library(tibble)

# Beispiel-Datensatz erzeugen  
dat <- tibble(
  Alter = c(28, 34, 23, 45)
)

# Durchschnittsalter berechnen
mean(dat$Alter)
```

**WebR**

Bei der Interkation mit WebR-Chunks sollte Folgendes beachtet werden:
  
Innerhalb eines Kapitels sind die WebR-Chunks durch eine im Hintergrund laufende R-Session verknüpft und greifen damit auf den selben Speicher für R-Objekte zu. Wir nutzen diese Eigenschaft für prozedurale Analysen, in denen bspw. zunächst einen Datensatz geladen und aufbreitet wird, um im folgenden Chunk ein ökonometrisches Modell zu schätzen.
  
Die WebR-Session und die WebR-Chunks werden bei jeder Aktualisierung des Browser-Tabs auf den durch uns (die Autoren) definierten Zustand zurückgesetzt. Das Bedeutet, dass durch den Nutzer geschriebener Code, berechnete Ergebnisse und definierte Objekte *bei einer Aktualisierung gelöscht werden*.
  
Sämtliche für die Analyse nötigen Pakete sind bereits vorinstalliert und müssen *nicht* durch den Nutzer installiert werden.^[Eine Installation weiterer Pakete ist möglich, sofern diese in einer WebR-kompatiblen Version vorliegen. Installation und laden eines Pakets erfolgen mit `library(Paketname)`.]
  
WebR-Chunks und "nicht-interaktiver" R-Code sind *nicht* miteinander verknüpft: R-Objekte, die wir in normalen Code-Chunks definieren, sind nicht notwendigerweise in WebR-Chunks verfügbar.
  
Insbsondere in Fallstudien werden WebR-Chunks oft automatisch beim Laden des Kapitels ausgeführt, um die Nachvollziehbarkeit der Erläuterungen im Fließtext zu gewährleisten. Hierbei werden oft relevante R-Pakete heruntergeladen, installiert und Berechnungen durchgeführt. Die WebR-Chunk sind erst nach Abschluss dieses Prozesses interaktiv. Der Status des Installationsprozesses wird unten rechts im Browser angezeigt. Bei laufenden Berechnung erscheint in der Kopfzeile der Chunks ein Indikator.^[Laufe Vorbereitungen und Berechnungen werden durch <span class="exercise-editor-eval-indicator spinner-grow spinner-grow-sm" role="status"></span> angezeigt.]
  
Der nächste Code-Chunk simuliert eine über 5 Sekunden laufende Berechnung und anschließende Ausgabe des Ergebnisses.

```{webr}
#| autorun: false
# Die Laufzeit dieser Zeile beträgt 5 Sekunden
Sys.sleep(time = 5) # 5 Sekunden nichts tun

# Leser*innen begrüßen
cat("Hey, willkommen bei KLMR!")
```

**Interaktive Visualisierungen**

<iframe width="100%" height="682" frameborder="0" class="box-shadow" src="https://observablehq.com/embed/@mca91/latent-variable-cdf?cells=plot%2Cviewof+beta0%2Cviewof+beta"></iframe>


